#include "defines.h"
#include "IP_init.h"

const RECT SCREEN = {0, RESOLUTION_X-1, 0, RESOLUTION_Y-1, BACKGROUND_COLOR};

const U16  calibPointsX[2] = { 17, 303 };
const U16  calibPointsY[2] = { 17, 223 };

const RECT CALIB_ULCORNER = {0,   33,  0,   33,  CALB_RECTS_COLOR};
const RECT CALIB_URCORNER = {286, 319, 0,   33,  CALB_RECTS_COLOR};
const RECT CALIB_DLCORNER = {0,   33,  206, 239, CALB_RECTS_COLOR};
const RECT CALIB_DRCORNER = {286, 319, 206, 239, CALB_RECTS_COLOR};
const RECT CALIB_CENTER   = {143, 176, 103, 136, CALB_RECTS_COLOR};

const RECT MESSAGEBOX = {MESSAGEBOX_SX, MESSAGEBOX_EX, MESSAGEBOX_SY, MESSAGEBOX_EY, MESSAGEBOX_COLOR};

const RECT MESSAGEBOX_LBUTTON = {MESSAGEBOX_LBUTTON_SX, MESSAGEBOX_LBUTTON_EX, MESSAGEBOX_BUTTONS_SY, MESSAGEBOX_BUTTONS_EY, MESSAGEBOX_COLOR};
const RECT MESSAGEBOX_CBUTTON = {MESSAGEBOX_CBUTTON_SX, MESSAGEBOX_CBUTTON_EX, MESSAGEBOX_BUTTONS_SY, MESSAGEBOX_BUTTONS_EY, MESSAGEBOX_COLOR};
const RECT MESSAGEBOX_RBUTTON = {MESSAGEBOX_RBUTTON_SX, MESSAGEBOX_RBUTTON_EX, MESSAGEBOX_BUTTONS_SY, MESSAGEBOX_BUTTONS_EY, MESSAGEBOX_COLOR};

const RECT HEADER = {HEADER_SX, HEADER_EX, HEADER_SY, HEADER_EY, HEADER_COLOR};
const RECT TOPIC = {TOPIC_SX, TOPIC_EX, CAPTIONS_SY, CAPTIONS_EY, RED};
const RECT TITLE  = {LTITLE_SX, RTITLE_EX, TITLES_SY, TITLES_EY, PURPLE};
const RECT LTITLE = {LTITLE_SX, LTITLE_EX, TITLES_SY, TITLES_EY, PURPLE};
const RECT RTITLE = {RTITLE_SX, RTITLE_EX, TITLES_SY, TITLES_EY, PURPLE};
const RECT TIME  = {TIME_SX, TIME_EX, CAPTIONS_SY, CAPTIONS_EY, RED};

const RECT BODY = {CHANNELS_SX, RIGHT_PARAMS_EX, UPPERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, BACKGROUND_COLOR};

//const RECT MEASURES = {LEFT_PARAMS_SX, RIGHT_PARAMS_EX, UPPERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, YELLOW};

const RECT CHANNEL0 = {CHANNELS_SX, CHANNELS_EX, CHANNEL0_SY, CHANNEL0_EY, ODD_GRAY};
const RECT CHANNEL1 = {CHANNELS_SX, CHANNELS_EX, CHANNEL1_SY, CHANNEL1_EY, GREEN};
const RECT CHANNEL2 = {CHANNELS_SX, CHANNELS_EX, CHANNEL2_SY, CHANNEL2_EY, GREEN};
const RECT CHANNEL3 = {CHANNELS_SX, CHANNELS_EX, CHANNEL3_SY, CHANNEL3_EY, GREEN};
const RECT CHANNEL4 = {CHANNELS_SX, CHANNELS_EX, CHANNEL4_SY, CHANNEL4_EY, GREEN};
const RECT* CHANNELS[4] = {&CHANNEL1, &CHANNEL2, &CHANNEL3, &CHANNEL4};

const RECT CHANNEL1_BIG = {CHANNELS_SX, CHANNELS_EX, CHANNEL1_SY, CHANNEL2_EY, GREEN};
const RECT CHANNEL2_BIG = {CHANNELS_SX, CHANNELS_EX, CHANNEL3_SY, CHANNEL4_EY, GREEN};
const RECT* CHANNELS_BIG[2] = {&CHANNEL1_BIG, &CHANNEL2_BIG};

const RECT MENU0 = {CHANNELS_SX, CHANNELS_EX, 0,   59,  EVEN_YELLOW};
const RECT MENU1 = {CHANNELS_SX, CHANNELS_EX, 60,  119, EVEN_YELLOW};
const RECT MENU2 = {CHANNELS_SX, CHANNELS_EX, 120, 179, EVEN_YELLOW};
const RECT MENU3 = {CHANNELS_SX, CHANNELS_EX, 180, 239, EVEN_YELLOW};

const RECT UMLPARAM = {LEFT_PARAMS_SX,   LEFT_PARAMS_EX,   UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, RED};
const RECT UMRPARAM = {RIGHT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, RED};
const RECT ULPARAM =  {LEFT_PARAMS_SX,   LEFT_PARAMS_EX,   UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     RED};
const RECT URPARAM =  {RIGHT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     RED};
const RECT LLPARAM =  {LEFT_PARAMS_SX,   LEFT_PARAMS_EX,   LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     RED};
const RECT LRPARAM =  {RIGHT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     RED};
const RECT LMLPARAM = {LEFT_PARAMS_SX,   LEFT_PARAMS_EX,   LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};
const RECT LMCPARAM = {CENTER_PARAMS_SX, CENTER_PARAMS_EX, LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};
const RECT LMRPARAM = {RIGHT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};

const RECT UMPARAM = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, RED};
const RECT UPARAM  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     RED};
const RECT LPARAM  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     RED};
const RECT LMPARAM = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};

const RECT* PARAMS[4]  = {&UMPARAM,  &UPARAM,  &LPARAM,  &LMPARAM};
const RECT* LPARAMS[4] = {&UMLPARAM, &ULPARAM, &LLPARAM, &LMLPARAM};
const RECT* RPARAMS[4] = {&UMRPARAM, &URPARAM, &LRPARAM, &LMRPARAM};
const RECT* PARAMS_SEQUENCE[12] = {&UMLPARAM, &UMRPARAM, &ULPARAM, &URPARAM, &LLPARAM, &LRPARAM, &LMLPARAM, &LMRPARAM, &UMPARAM, &UPARAM, &LPARAM, &LMPARAM};

const RECT UMCAPTION = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT UMVALUE   = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT UCAPTION  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT UVALUE    = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT LCAPTION  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT LVALUE    = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT LMCAPTION = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT LMVALUE   = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};

const RECT UMLCAPTION = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT UMRCAPTION = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT UMLVALUE   = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT UMRVALUE   = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT ULCAPTION  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT URCAPTION  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT ULVALUE    = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT URVALUE    = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT LLCAPTION  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT LRCAPTION  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT LLVALUE    = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT LRVALUE    = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT LMLCAPTION = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT LMRCAPTION = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT LMLVALUE   = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};
const RECT LMRVALUE   = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};

const RECT* CAPTIONS[4]  = {&UMCAPTION,  &UCAPTION,  &LCAPTION,  &LMCAPTION};
const RECT* LCAPTIONS[4] = {&UMLCAPTION, &ULCAPTION, &LLCAPTION, &LMLCAPTION};
const RECT* RCAPTIONS[4] = {&UMRCAPTION, &URCAPTION, &LRCAPTION, &LMRCAPTION};
const RECT* CAPTIONS_BIG[2]  = {&UMVALUE,   &LVALUE};
const RECT* LCAPTIONS_BIG[2] = {&UMLVALUE,  &LLVALUE};
const RECT* RCAPTIONS_BIG[2] = {&UMRVALUE,  &LRVALUE};
const RECT* CAPTIONS_SEQUENCE[12] = {&UMLCAPTION, &UMRCAPTION, &ULCAPTION, &URCAPTION, &LLCAPTION, &LRCAPTION, &LMLCAPTION, &LMRCAPTION, &UMCAPTION, &UCAPTION, &LCAPTION, &LMCAPTION};

const RECT* VALUES[4]  = {&UMVALUE,  &UVALUE,  &LVALUE,  &LMVALUE};
const RECT* LVALUES[4] = {&UMLVALUE, &ULVALUE, &LLVALUE, &LMLVALUE};
const RECT* RVALUES[4] = {&UMRVALUE, &URVALUE, &LRVALUE, &LMRVALUE};
const RECT* VALUES_BIG[2]  = {&UCAPTION,  &LMCAPTION};
const RECT* LVALUES_BIG[2] = {&ULCAPTION, &LMLCAPTION};
const RECT* RVALUES_BIG[2] = {&URCAPTION, &LMRCAPTION};
const RECT* VALUES_SEQUENCE[12] = {&UMLVALUE, &UMRVALUE, &ULVALUE, &URVALUE, &LLVALUE, &LRVALUE, &LMLVALUE, &LMRVALUE, &UMVALUE, &UVALUE, &LVALUE, &LMVALUE};

const RECT ULPARAM_BIG = {LEFT_PARAMS_SX,   LEFT_PARAMS_EX,  UPPERMOST_PARAMS_SY, UPPER_PARAMS_EY,     RED};
const RECT URPARAM_BIG = {RIGHT_PARAMS_SX,  RIGHT_PARAMS_EX, UPPERMOST_PARAMS_SY, UPPER_PARAMS_EY,     RED};
const RECT LLPARAM_BIG = {LEFT_PARAMS_SX,   LEFT_PARAMS_EX,  LOWER_PARAMS_SY,     LOWERMOST_PARAMS_EY, RED};
const RECT LRPARAM_BIG = {RIGHT_PARAMS_SX,  RIGHT_PARAMS_EX, LOWER_PARAMS_SY,     LOWERMOST_PARAMS_EY, RED};
const RECT* PARAMS_SEQUENCE_BIG[4] = {&ULPARAM_BIG, &URPARAM_BIG, &LLPARAM_BIG, &LRPARAM_BIG};

const RECT UPARAM_BIG = {LEFT_PARAMS_SX, RIGHT_PARAMS_EX, UPPERMOST_PARAMS_SY, UPPER_PARAMS_EY,     RED};
const RECT LPARAM_BIG = {LEFT_PARAMS_SX, RIGHT_PARAMS_EX, LOWER_PARAMS_SY,     LOWERMOST_PARAMS_EY, RED};

const RECT* PARAMS_BIG[2]  = {&UPARAM_BIG,  &LPARAM_BIG};
const RECT* LPARAMS_BIG[2] = {&ULPARAM_BIG, &LLPARAM_BIG};
const RECT* RPARAMS_BIG[2] = {&URPARAM_BIG, &LRPARAM_BIG};

const RECT CENTER    = {LEFTHALF_PARAMS_SX,  RIGHTHALF_PARAMS_EX, UPPERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};
const RECT LEFTHALF  = {LEFTHALF_PARAMS_SX,  LEFTHALF_PARAMS_EX,  UPPERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};
const RECT RIGHTHALF = {RIGHTHALF_PARAMS_SX, RIGHTHALF_PARAMS_EX, UPPERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};

const RECT UPPERMOST  = {LEFTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, RED};
const RECT UPPER      = {LEFTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     RED};
const RECT LOWER      = {LEFTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     RED};
const RECT LOWERMOST  = {LEFTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};

const RECT UPPERMOST_TOP      = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT UPPERMOST_BOTTOM   = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT UPPER_TOP          = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT UPPER_BOTTOM       = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT LOWER_TOP          = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT LOWER_BOTTOM       = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT LOWERMOST_TOP      = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT LOWERMOST_BOTTOM   = {LEFTHALF_PARAMS_SX,    RIGHTHALF_PARAMS_EX,    LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};

const RECT LEFTHALF_UPPERMOST  = {LEFTHALF_PARAMS_SX,   LEFTHALF_PARAMS_EX,   UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, RED};
const RECT LEFTHALF_UPPER      = {LEFTHALF_PARAMS_SX,   LEFTHALF_PARAMS_EX,   UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     RED};
const RECT LEFTHALF_LOWER      = {LEFTHALF_PARAMS_SX,   LEFTHALF_PARAMS_EX,   LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     RED};
const RECT LEFTHALF_LOWERMOST  = {LEFTHALF_PARAMS_SX,   LEFTHALF_PARAMS_EX,   LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};
const RECT RIGHTHALF_UPPERMOST = {RIGHTHALF_PARAMS_SX,  RIGHTHALF_PARAMS_EX,  UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, RED};
const RECT RIGHTHALF_UPPER     = {RIGHTHALF_PARAMS_SX,  RIGHTHALF_PARAMS_EX,  UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     RED};
const RECT RIGHTHALF_LOWER     = {RIGHTHALF_PARAMS_SX,  RIGHTHALF_PARAMS_EX,  LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     RED};
const RECT RIGHTHALF_LOWERMOST = {RIGHTHALF_PARAMS_SX,  RIGHTHALF_PARAMS_EX,  LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, RED};

const RECT LEFTHALF_UPPERMOST_TOP      = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT LEFTHALF_UPPERMOST_BOTTOM   = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT LEFTHALF_UPPER_TOP          = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT LEFTHALF_UPPER_BOTTOM       = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT LEFTHALF_LOWER_TOP          = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT LEFTHALF_LOWER_BOTTOM       = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT LEFTHALF_LOWERMOST_TOP      = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT LEFTHALF_LOWERMOST_BOTTOM   = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};
const RECT RIGHTHALF_UPPERMOST_TOP     = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT RIGHTHALF_UPPERMOST_BOTTOM  = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT RIGHTHALF_UPPER_TOP         = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT RIGHTHALF_UPPER_BOTTOM      = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT RIGHTHALF_LOWER_TOP         = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT RIGHTHALF_LOWER_BOTTOM      = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT RIGHTHALF_LOWERMOST_TOP     = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT RIGHTHALF_LOWERMOST_BOTTOM  = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};

const RECT* LEFTHALFS_SMALL[8]  = {&LEFTHALF_UPPERMOST_TOP,  &LEFTHALF_UPPERMOST_BOTTOM,  &LEFTHALF_UPPER_TOP,  &LEFTHALF_UPPER_BOTTOM,  &LEFTHALF_LOWER_TOP,  &LEFTHALF_LOWER_BOTTOM,  &LEFTHALF_LOWERMOST_TOP,  &LEFTHALF_LOWERMOST_BOTTOM};
const RECT* RIGHTHALFS_SMALL[8] = {&RIGHTHALF_UPPERMOST_TOP, &RIGHTHALF_UPPERMOST_BOTTOM, &RIGHTHALF_UPPER_TOP, &RIGHTHALF_UPPER_BOTTOM, &RIGHTHALF_LOWER_TOP, &RIGHTHALF_LOWER_BOTTOM, &RIGHTHALF_LOWERMOST_TOP, &RIGHTHALF_LOWERMOST_BOTTOM};

const RECT LEFT_UPPERMOST_TOP        = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT LEFT_UPPERMOST_BOTTOM     = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT LEFT_UPPER_TOP            = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT LEFT_UPPER_BOTTOM         = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT LEFT_LOWER_TOP            = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT LEFT_LOWER_BOTTOM         = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT LEFT_LOWERMOST_TOP        = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT LEFT_LOWERMOST_BOTTOM     = {LEFT_CONTROLS_SX,       LEFT_CONTROLS_EX,       LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};
const RECT CENTER_UPPERMOST_TOP      = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT CENTER_UPPERMOST_BOTTOM   = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT CENTER_UPPER_TOP          = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT CENTER_UPPER_BOTTOM       = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT CENTER_LOWER_TOP          = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT CENTER_LOWER_BOTTOM       = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT CENTER_LOWERMOST_TOP      = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT CENTER_LOWERMOST_BOTTOM   = {CENTRAL_CONTROLS_SX,    CENTRAL_CONTROLS_EX,    LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};
const RECT RIGHT_UPPERMOST_TOP       = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      UPPERMOST_UPPER_PARAMS_SY, UPPERMOST_UPPER_PARAMS_EY, RED};
const RECT RIGHT_UPPERMOST_BOTTOM    = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      UPPERMOST_LOWER_PARAMS_SY, UPPERMOST_LOWER_PARAMS_EY, RED};
const RECT RIGHT_UPPER_TOP           = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      UPPER_UPPER_PARAMS_SY,     UPPER_UPPER_PARAMS_EY,     RED};
const RECT RIGHT_UPPER_BOTTOM        = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      UPPER_LOWER_PARAMS_SY,     UPPER_LOWER_PARAMS_EY,     RED};
const RECT RIGHT_LOWER_TOP           = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      LOWER_UPPER_PARAMS_SY,     LOWER_UPPER_PARAMS_EY,     RED};
const RECT RIGHT_LOWER_BOTTOM        = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      LOWER_LOWER_PARAMS_SY,     LOWER_LOWER_PARAMS_EY,     RED};
const RECT RIGHT_LOWERMOST_TOP       = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      LOWERMOST_UPPER_PARAMS_SY, LOWERMOST_UPPER_PARAMS_EY, RED};
const RECT RIGHT_LOWERMOST_BOTTOM    = {RIGHT_CONTROLS_SX,      RIGHT_CONTROLS_EX,      LOWERMOST_LOWER_PARAMS_SY, LOWERMOST_LOWER_PARAMS_EY, RED};

const RECT* RIGHTS_SMALL[8] = {&RIGHT_UPPERMOST_TOP, &RIGHT_UPPERMOST_BOTTOM, &RIGHT_UPPER_TOP, &RIGHT_UPPER_BOTTOM, &RIGHT_LOWER_TOP, &RIGHT_LOWER_BOTTOM, &RIGHT_LOWERMOST_TOP, &RIGHT_LOWERMOST_BOTTOM};

const RECT LEFTHALF_TOP     = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    UPPERMOST_LOWER_PARAMS_SY, UPPER_LOWER_PARAMS_EY, RED};
const RECT RIGHTHALF_TOP    = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPERMOST_LOWER_PARAMS_SY, UPPER_LOWER_PARAMS_EY, RED};
//const RECT LEFTHALF_MIDDLE  = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    LOWER_UPPER_PARAMS_SY,     LOWERMOST_UPPER_PARAMS_EY, RED};
//const RECT RIGHTHALF_MIDDLE = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   LOWER_UPPER_PARAMS_SY,     LOWERMOST_UPPER_PARAMS_EY, RED};
//const RECT LEFTHALF_BOTTOM  = {LEFTHALF_PARAMS_SX,    LEFTHALF_PARAMS_EX,    UPPERMOST_LOWER_PARAMS_SY, UPPER_LOWER_PARAMS_EY, RED};
//const RECT RIGHTHALF_BOTTOM = {RIGHTHALF_PARAMS_SX,   RIGHTHALF_PARAMS_EX,   UPPERMOST_LOWER_PARAMS_SY, UPPER_LOWER_PARAMS_EY, RED};

const RECT LINE0 = {CHANNELS_SX, RIGHT_PARAMS_EX, 0,                   48,                  GREEN};
const RECT LINE1 = {CHANNELS_SX, RIGHT_PARAMS_EX, UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, GREEN};
const RECT LINE2 = {CHANNELS_SX, RIGHT_PARAMS_EX, UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     GREEN};
const RECT LINE3 = {CHANNELS_SX, RIGHT_PARAMS_EX, LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     GREEN};
const RECT LINE4 = {CHANNELS_SX, RIGHT_PARAMS_EX, LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, GREEN};

const RECT LINE1_BIG = {CHANNELS_SX, RIGHT_PARAMS_EX, UPPERMOST_PARAMS_SY, UPPER_PARAMS_EY,     GREEN};
const RECT LINE2_BIG = {CHANNELS_SX, RIGHT_PARAMS_EX, LOWER_PARAMS_SY,     LOWERMOST_PARAMS_EY, GREEN};

const RECT* LINES[4] = {&LINE1, &LINE2, &LINE3, &LINE4};
const RECT* LINES_BIG[2] = {&LINE1_BIG, &LINE2_BIG};

const RECT* LINES_SMALL[8] = {&UPPERMOST_TOP, &UPPERMOST_BOTTOM, &UPPER_TOP, &UPPER_BOTTOM, &LOWER_TOP, &LOWER_BOTTOM, &LOWERMOST_TOP, &LOWERMOST_BOTTOM};

const RECT ULCONTROL = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    UPPER_CONTROLS_SY, UPPER_CONTROLS_EY, YELLOW};
const RECT LLCONTROL = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    LOWER_CONTROLS_SY, LOWER_CONTROLS_EY, YELLOW};
const RECT UCCONTROL = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, UPPER_CONTROLS_SY, UPPER_CONTROLS_EY, YELLOW};
const RECT LCCONTROL = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, LOWER_CONTROLS_SY, LOWER_CONTROLS_EY, YELLOW};
const RECT URCONTROL = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   UPPER_CONTROLS_SY, UPPER_CONTROLS_EY, YELLOW};
const RECT LRCONTROL = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   LOWER_CONTROLS_SY, LOWER_CONTROLS_EY, YELLOW};

const RECT* CONTROLS[6] = {&ULCONTROL, &UCCONTROL, &URCONTROL, &LLCONTROL, &LCCONTROL, &LRCONTROL};

const RECT ULCONTROL_TOP    = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    UPPER_CONTROLS_TOP_SY,    UPPER_CONTROLS_TOP_EY,    ORANGE};
const RECT ULCONTROL_MIDDLE = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    UPPER_CONTROLS_MIDDLE_SY, UPPER_CONTROLS_MIDDLE_EY, ORANGE};
const RECT ULCONTROL_BOTTOM = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    UPPER_CONTROLS_BOTTOM_SY, UPPER_CONTROLS_BOTTOM_EY, ORANGE};
const RECT LLCONTROL_TOP    = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    LOWER_CONTROLS_TOP_SY,    LOWER_CONTROLS_TOP_EY,    ORANGE};
const RECT LLCONTROL_MIDDLE = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    LOWER_CONTROLS_MIDDLE_SY, LOWER_CONTROLS_MIDDLE_EY, ORANGE};
const RECT LLCONTROL_BOTTOM = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    LOWER_CONTROLS_BOTTOM_SY, LOWER_CONTROLS_BOTTOM_EY, ORANGE};
const RECT UCCONTROL_TOP    = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, UPPER_CONTROLS_TOP_SY,    UPPER_CONTROLS_TOP_EY,    ORANGE};
const RECT UCCONTROL_MIDDLE = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, UPPER_CONTROLS_MIDDLE_SY, UPPER_CONTROLS_MIDDLE_EY, ORANGE};
const RECT UCCONTROL_BOTTOM = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, UPPER_CONTROLS_BOTTOM_SY, UPPER_CONTROLS_BOTTOM_EY, ORANGE};
const RECT LCCONTROL_TOP    = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, LOWER_CONTROLS_TOP_SY,    LOWER_CONTROLS_TOP_EY,    ORANGE};
const RECT LCCONTROL_MIDDLE = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, LOWER_CONTROLS_MIDDLE_SY, LOWER_CONTROLS_MIDDLE_EY, ORANGE};
const RECT LCCONTROL_BOTTOM = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, LOWER_CONTROLS_BOTTOM_SY, LOWER_CONTROLS_BOTTOM_EY, ORANGE};
const RECT URCONTROL_TOP    = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   UPPER_CONTROLS_TOP_SY,    UPPER_CONTROLS_TOP_EY,    ORANGE};
const RECT URCONTROL_MIDDLE = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   UPPER_CONTROLS_MIDDLE_SY, UPPER_CONTROLS_MIDDLE_EY, ORANGE};
const RECT URCONTROL_BOTTOM = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   UPPER_CONTROLS_BOTTOM_SY, UPPER_CONTROLS_BOTTOM_EY, ORANGE};
const RECT LRCONTROL_TOP    = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   LOWER_CONTROLS_TOP_SY,    LOWER_CONTROLS_TOP_EY,    ORANGE};
const RECT LRCONTROL_MIDDLE = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   LOWER_CONTROLS_MIDDLE_SY, LOWER_CONTROLS_MIDDLE_EY, ORANGE};
const RECT LRCONTROL_BOTTOM = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   LOWER_CONTROLS_BOTTOM_SY, LOWER_CONTROLS_BOTTOM_EY, ORANGE};

const RECT* CONTROLS_TOP[6] = {&ULCONTROL_TOP, &UCCONTROL_TOP, &URCONTROL_TOP, &LLCONTROL_TOP, &LCCONTROL_TOP, &LRCONTROL_TOP};
const RECT* CONTROLS_MIDDLE[6] = {&ULCONTROL_MIDDLE, &UCCONTROL_MIDDLE, &URCONTROL_MIDDLE, &LLCONTROL_MIDDLE, &LCCONTROL_MIDDLE, &LRCONTROL_MIDDLE};
const RECT* CONTROLS_BOTTOM[6] = {&ULCONTROL_BOTTOM, &UCCONTROL_BOTTOM, &URCONTROL_BOTTOM, &LLCONTROL_BOTTOM, &LCCONTROL_BOTTOM, &LRCONTROL_BOTTOM};

const RECT ULCONTROL_IMAGE  = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    UPPER_CONTROLS_TOP_SY,    UPPER_CONTROLS_MIDDLE_EY, YELLOW};
const RECT LLCONTROL_IMAGE  = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    LOWER_CONTROLS_TOP_SY,    LOWER_CONTROLS_MIDDLE_EY, YELLOW};
const RECT UCCONTROL_IMAGE  = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, UPPER_CONTROLS_TOP_SY,    UPPER_CONTROLS_MIDDLE_EY, YELLOW};
const RECT LCCONTROL_IMAGE  = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, LOWER_CONTROLS_TOP_SY,    LOWER_CONTROLS_MIDDLE_EY, YELLOW};
const RECT URCONTROL_IMAGE  = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   UPPER_CONTROLS_TOP_SY,    UPPER_CONTROLS_MIDDLE_EY, YELLOW};
const RECT LRCONTROL_IMAGE  = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   LOWER_CONTROLS_TOP_SY,    LOWER_CONTROLS_MIDDLE_EY, YELLOW};

const RECT* CONTROLS_IMAGE[6] = {&ULCONTROL_IMAGE, &UCCONTROL_IMAGE, &URCONTROL_IMAGE, &LLCONTROL_IMAGE, &LCCONTROL_IMAGE, &LRCONTROL_IMAGE};

const RECT LEFT_BOTTOM_BUTTON   = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    BOTTOM_BUTTONS_SY, BOTTOM_BUTTONS_EY, RED};
const RECT CENTER_BOTTOM_BUTTON = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, BOTTOM_BUTTONS_SY, BOTTOM_BUTTONS_EY, RED};
const RECT RIGHT_BOTTOM_BUTTON  = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   BOTTOM_BUTTONS_SY, BOTTOM_BUTTONS_EY, RED};

const RECT LEFT_BOTTOM_SMALLBUTTON   = {LEFT_CONTROLS_SX,    LEFT_CONTROLS_EX,    BOTTOM_SMALLBUTTONS_SY, BOTTOM_SMALLBUTTONS_EY, RED};
const RECT CENTER_BOTTOM_SMALLBUTTON = {CENTRAL_CONTROLS_SX, CENTRAL_CONTROLS_EX, BOTTOM_SMALLBUTTONS_SY, BOTTOM_SMALLBUTTONS_EY, RED};
const RECT RIGHT_BOTTOM_SMALLBUTTON  = {RIGHT_CONTROLS_SX,   RIGHT_CONTROLS_EX,   BOTTOM_SMALLBUTTONS_SY, BOTTOM_SMALLBUTTONS_EY, RED};

const RECT LEFT_TWOTHIRDS_UPPERMOST = {LEFT_CONTROLS_SX,  CENTRAL_CONTROLS_EX, UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, BLUE};
const RECT LEFT_TWOTHIRDS_UPPER     = {LEFT_CONTROLS_SX,  CENTRAL_CONTROLS_EX, UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     BLUE};
const RECT LEFT_TWOTHIRDS_LOWER     = {LEFT_CONTROLS_SX,  CENTRAL_CONTROLS_EX, LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     BLUE};
const RECT LEFT_TWOTHIRDS_LOWERMOST = {LEFT_CONTROLS_SX,  CENTRAL_CONTROLS_EX, LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, BLUE};
const RECT RIGHT_TWOTHIRDS_UPPERMOST = {CENTRAL_CONTROLS_SX,  RIGHT_CONTROLS_EX, UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, BLUE};
const RECT RIGHT_TWOTHIRDS_UPPER     = {CENTRAL_CONTROLS_SX,  RIGHT_CONTROLS_EX, UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     BLUE};
const RECT RIGHT_TWOTHIRDS_LOWER     = {CENTRAL_CONTROLS_SX,  RIGHT_CONTROLS_EX, LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     BLUE};
const RECT RIGHT_TWOTHIRDS_LOWERMOST = {CENTRAL_CONTROLS_SX,  RIGHT_CONTROLS_EX, LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, BLUE};
const RECT LEFT_THIRD_UPPERMOST     = {LEFT_CONTROLS_SX,  LEFT_CONTROLS_EX,    UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, BLUE};
const RECT LEFT_THIRD_UPPER         = {LEFT_CONTROLS_SX,  LEFT_CONTROLS_EX,    UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     BLUE};
const RECT LEFT_THIRD_LOWER         = {LEFT_CONTROLS_SX,  LEFT_CONTROLS_EX,    LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     BLUE};
const RECT LEFT_THIRD_LOWERMOST     = {LEFT_CONTROLS_SX,  LEFT_CONTROLS_EX,    LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, BLUE};
const RECT RIGHT_THIRD_UPPERMOST    = {RIGHT_CONTROLS_SX, RIGHT_CONTROLS_EX,   UPPERMOST_PARAMS_SY, UPPERMOST_PARAMS_EY, BLUE};
const RECT RIGHT_THIRD_UPPER        = {RIGHT_CONTROLS_SX, RIGHT_CONTROLS_EX,   UPPER_PARAMS_SY,     UPPER_PARAMS_EY,     BLUE};
const RECT RIGHT_THIRD_LOWER        = {RIGHT_CONTROLS_SX, RIGHT_CONTROLS_EX,   LOWER_PARAMS_SY,     LOWER_PARAMS_EY,     BLUE};
const RECT RIGHT_THIRD_LOWERMOST    = {RIGHT_CONTROLS_SX, RIGHT_CONTROLS_EX,   LOWERMOST_PARAMS_SY, LOWERMOST_PARAMS_EY, BLUE};

const RECT KEY_1 = {LEFTMOST_KEYS_SX,  LEFTMOST_KEYS_EX,  UPPER_KEYS_SY,     UPPER_KEYS_EY,     WHITE};
const RECT KEY_2 = {LEFT_KEYS_SX,      LEFT_KEYS_EX,      UPPER_KEYS_SY,     UPPER_KEYS_EY,     WHITE};
const RECT KEY_3 = {RIGHT_KEYS_SX,     RIGHT_KEYS_EX,     UPPER_KEYS_SY,     UPPER_KEYS_EY,     WHITE};
const RECT KEY_M = {RIGHTMOST_KEYS_SX, RIGHTMOST_KEYS_EX, UPPER_KEYS_SY,     UPPER_KEYS_EY,     WHITE};
const RECT KEY_4 = {LEFTMOST_KEYS_SX,  LEFTMOST_KEYS_EX,  LOWER_KEYS_SY,     LOWER_KEYS_EY,     WHITE};
const RECT KEY_5 = {LEFT_KEYS_SX,      LEFT_KEYS_EX,      LOWER_KEYS_SY,     LOWER_KEYS_EY,     WHITE};
const RECT KEY_6 = {RIGHT_KEYS_SX,     RIGHT_KEYS_EX,     LOWER_KEYS_SY,     LOWER_KEYS_EY,     WHITE};
const RECT KEY_D = {RIGHTMOST_KEYS_SX, RIGHTMOST_KEYS_EX, LOWER_KEYS_SY,     LOWER_KEYS_EY,     WHITE};
const RECT KEY_7 = {LEFTMOST_KEYS_SX,  LEFTMOST_KEYS_EX,  LOWERMOST_KEYS_SY, LOWERMOST_KEYS_EY, WHITE};
const RECT KEY_8 = {LEFT_KEYS_SX,      LEFT_KEYS_EX,      LOWERMOST_KEYS_SY, LOWERMOST_KEYS_EY, WHITE};
const RECT KEY_9 = {RIGHT_KEYS_SX,     RIGHT_KEYS_EX,     LOWERMOST_KEYS_SY, LOWERMOST_KEYS_EY, WHITE};
const RECT KEY_0 = {RIGHTMOST_KEYS_SX, RIGHTMOST_KEYS_EX, LOWERMOST_KEYS_SY, LOWERMOST_KEYS_EY, WHITE};
const RECT KEY_B = {RIGHTMOST_KEYS_SX, RIGHTMOST_KEYS_EX, UPPERMOST_KEYS_SY, UPPERMOST_KEYS_EY, WHITE};
const RECT VALUE = {LEFTMOST_KEYS_SX,  RIGHT_KEYS_EX,     UPPERMOST_KEYS_SY, UPPERMOST_KEYS_EY, GREEN};

const RECT** Lines;
const RECT** Channels;
const RECT** Params;
const RECT** LParams;
const RECT** RParams;
const RECT** Captions;
const RECT** LCaptions;
const RECT** RCaptions;
const RECT** Values;
const RECT** LValues;
const RECT** RValues;
const RECT** Params_sequence;

const char* PARAM_NAMES[] = {"Неизвестно", "Температура", "Влажность", "Давление", "Кислород", "COv2", "CO", "Водород", "Метан", "Оксид азота", "Скорость потока", "Напряжение", "Темп. управления", "Аккумулятор", "Расход", "Управление O2", "Кол-во частиц (>0.3 мкм)", "Кол-во частиц (>0.5 мкм)", "Кол-во частиц (>5.0 мкм)", "Объем жидкости", "Аммиак", "Сероводород", "Уровень сигнала", "Плотность теплового потока", "ТНС", "Термосопротивление", "Дельта"};
const char* PARAM_TYPES[] = {"?", "T", "H", "P", "O2", "CO2", "CO", "H2", "CH4", "NO", "V", "U", "Т упр.", "P", "F", "O2", "D>0.3", "D>0.5", "D>5.0", "W", "NH3", "H2S", "S", "F", "ТНС", "R", "?"};
const char* UNIT_TYPES[]  = {"?", "%", "°Cтр", "ppm", "г/м^3", "мг/м^3", "°C", "мм.рт.ст.", "об.%", "атм", "м/с", "В", "кгс/см^2", "%", "м^3/ч", "ед.", "ед.", "ед.", "кПа", "*", "мл", "кг/ч", "Вт/м^2", "°Cвт", "°Cст", "°Cшт", "м^3/с", "°C/Вт"};

const char* RELAY_CONTROL_TYPES[]   = {"Ручное", "Логическое", "Гистерезис"};
const char* CURRENT_CONTROL_TYPES[] = {"Ручное", "Логическое", "Лин. выход"};
const char* CURRENT_TYPES[] = {"", "", "0..5 мА", "0..20 мА", "4..20 мА"};
const char* LOWER_CURRENTS[] = {"", "", "0 мА", "0 мА", "4 мА"};
const char* UPPER_CURRENTS[] = {"", "", "5 мА", "20 мА", "20 мА"};
const char* END_PROGRAMM_ACTIONS[4][2] = {"Выключить", "управление", "Регулировать", "послед. знач.", "Перезапустить", "программу", "Регулировать", "знач. по умол."};

const char* DEFPARAM_TYPES[2] = {"Константа", "Параметр"};

const char* THRESHOLD_TYPES[2] = {"Нижний", "Верхний"};
const char* THRESHOLD_WEIGHTS[2] = {"Внимание", "Тревога"};

const char* PRESSURE_TYPES[2] = {"Абсолютное", "Избыточное"};
const char* PRESSURE_INPUTS[3] = {"0..5 мА", "0..20 мА", "4..20 мА"};

const char* RS_SPEEDS[8] = {"1200", "2400", "4800", "9600", "19200", "38400", "57600", "115200"};

void (*draw)  (void);
void (*update)(void);
void (*touch) (void);

Int8U  CurrentDisplay = 255;
Int8U  CurrentParam;
Int8U  CurrentThreshold;
Int8U  CurrentControl;
Int16U CurrentProgrammStep;

bool BackToAllChannels;

enum CONTROL_SCREEN ControlScreen = csDetail;

Int32U TempTime;

#pragma data_alignment = 4
static U8         buf[512];

// ################################################# TFT ###################################################
/* процедыры упраления TFT ------------------------------------------------------------ */
/* загрузка графической паямяти ТФТ из SD карты  */

#pragma optimize=none
void load_SD_TFT(U32 PixNum, U32 SDaddress)
{ 
  div_t       n;
  U32         i;

  start_write_GRAM_TFT();
  open_SDCard(SDaddress);
  
  n = div(PixNum, 256);

  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard( (pU8)buf, 1);
    TFT_Load( (pU16)buf, 256);
  }
  
  if(n.rem)
  {    
    read_opened_SDCard( (pU8)buf, 1);
    TFT_Load( (pU16)buf, n.rem);
  }
  
  close_SDCard();
  stop_write_GRAM_TFT();
}

/* скриншортпобери */
#pragma optimize=none
void ScreenShoot(U32 SDaddress)
{
  save_TFT_SD( SDaddress, 0, RESOLUTION_X * RESOLUTION_Y);
}

/* запись графической паямяти из ТФТ в SD карту */
#pragma optimize=none
void save_TFT_SD(U32 SDaddress, U32 TFTaddress, U32 PixNum)
{ 
  div_t       n;
  U32         i;
  
  n = div(PixNum, 256);  // 1 pix - 2 bytes

  for(i = 0; i < n.quot; i++, SDaddress += 512)
  { 
    TFT_Read( (pU16)buf, TFTaddress, 256);
    write_SDCard( (pU8)buf, SDaddress, 512);
    IncTFTAdr( &TFTaddress, 256);
  } 
  stop_read_GRAM_TFT();
}

// чтение в буффер из TFT
#pragma optimize = none
void TFT_Read(pU16 sourceMemory, U32 TFTaddress, U32 NumRead)
{  
  for(U32 i = 0; i < NumRead;  i++, sourceMemory++)
  {
//    OS_Use(&SemaTFT);
    
    write_control_TFT(0x20, TFTaddress >> 16);  // x
    write_control_TFT(0x21, (U16)TFTaddress );  // y    
    IncTFTAdr(&TFTaddress, 1); 
   
    start_read_GRAM_TFT();
   
    // dummy read data  
    RD_TFT_LOW; 
    __no_operation(); 
    *sourceMemory = GPIOE_IDR; 
    RD_TFT_HIGH; 
   
    // read data  
    RD_TFT_LOW;
    __no_operation();
    *sourceMemory = GPIOE_IDR;
    RD_TFT_HIGH;       
  
    stop_read_GRAM_TFT();
    
//    OS_Unuse(&SemaTFT);
  }
}

// подготовка порта Е к чтению из TFT
#pragma optimize=none
void start_read_GRAM_TFT(void)
{   
  // write to IR
  RS_TFT_LOW;
  CS_TFT_LOW;
  GPIOE_ODR = 0x22;  
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;    
  RS_TFT_HIGH;
  
  CS_TFT_LOW;  
  
  GPIOE_CRL= 0x44444444;
  GPIOE_CRH= 0x44444444; 
}

// возврат порта Е в норм состояние
#pragma optimize=none
void stop_read_GRAM_TFT(void)
{     
  CS_TFT_HIGH;
  
  GPIOE_CRL= 0x33333333;
  GPIOE_CRH= 0x33333333;
}

// инкремент указателя чтения под формат экрана + кодирование x и y координат
void  IncTFTAdr(U32 * TFTaddress, U32 Inc)
{
  U16 x =  *TFTaddress, y = (*TFTaddress) >> 16;
  
  div_t n = div(Inc, RESOLUTION_X);
  x += n.rem;
  y += n.quot;
  n = div(x, RESOLUTION_X);
  x = n.rem;
  y += n.quot;
  *TFTaddress = x + (((U32)y) << 16);
}

/* загрузка графической паямяти ТФТ из буффера ------ */
#pragma optimize=none
void write_GRAM_TFT(U32 PixNum, pU16 buffer)
{ 
//  OS_Use(&SemaTFT);
  
  // write to IR
  RS_TFT_LOW;
  CS_TFT_LOW;
  GPIOE_ODR = 0x22;
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;
  RS_TFT_HIGH;
  CS_TFT_LOW;
  
  for(U32 i = 0; i < PixNum;  i++, buffer++)
  {
   // write data  
    GPIOE_ODR = *buffer;
    WR_TFT_LOW;
    WR_TFT_HIGH;    
  }
  
  CS_TFT_HIGH;
  
//  OS_Unuse(&SemaTFT);
}

/* загрузка графической паямяти ТФТ константой  ------ */
#pragma optimize=none
void fill_GRAM_TFT(U32 PixNum, U16 content)
{
//  OS_Use(&SemaTFT);
  
  // write to IR
  RS_TFT_LOW;
  CS_TFT_LOW;
  GPIOE_ODR = 0x22;  
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;
  RS_TFT_HIGH;
  CS_TFT_LOW;
  
  for(U32 i = 0; i < PixNum;  i++)
  {
   // write data      
    GPIOE_ODR = content;    
    WR_TFT_LOW;
    WR_TFT_HIGH;
  }
  
  CS_TFT_HIGH;
  
//  OS_Unuse(&SemaTFT);
}

/* подготовка графической памяти к записи или чтению -----------  */
#pragma optimize=none
void start_write_GRAM_TFT(void)
{ 
//  OS_Use(&SemaTFT);
  
  // write to IR
  RS_TFT_LOW;
  CS_TFT_LOW;
  GPIOE_ODR = 0x22;  
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;    
  RS_TFT_HIGH;

  CS_TFT_LOW;  
}

#pragma optimize=none
void TFT_Load(pU16 sourceMemory, U32 NumWrites)
{
  for(U32 i = 0; i < NumWrites;  i++, sourceMemory++)
  {
   // write data  
    GPIOE_ODR = *sourceMemory;
    WR_TFT_LOW;
    WR_TFT_HIGH;
  }
}

/* завершение записи в графическую память -----------  */
#pragma optimize=none
void stop_write_GRAM_TFT(void)
{ 
  CS_TFT_HIGH;
//  OS_Unuse(&SemaTFT);
}

/* запись управляющих регистров ТФТ ------------------ */
#pragma optimize=none
void write_control_TFT(U8 adr, U16 data)
{
//  OS_Use(&SemaTFT);
  
  // write to IR
  RS_TFT_LOW;
  CS_TFT_LOW;
  GPIOE_ODR = adr;
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;
  
  // write to control reg
  RS_TFT_HIGH;
  CS_TFT_LOW;
  GPIOE_ODR = data;
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;
  
//  OS_Unuse(&SemaTFT);
}

/* чтение управляющих регистров ТФТ ------------------ */
#pragma optimize=none
U16 read_control_TFT(U8 adr)
{ 
  U16   data;
  
//  OS_Use(&SemaTFT);
  
  // write to IR adr
  RS_TFT_LOW;
  CS_TFT_LOW; 
  GPIOE_ODR = adr;
  WR_TFT_LOW;
  WR_TFT_HIGH;
  CS_TFT_HIGH;
  
 // read from control reg
  RS_TFT_HIGH;
  CS_TFT_LOW;
  
  GPIOE_ODR = 0;
  GPIOE_CRL = 0x44444444;
  GPIOE_CRH = 0x44444444;
  
  RD_TFT_LOW;
  __no_operation();
  __no_operation();
  data = GPIOE_IDR;
  RD_TFT_HIGH;
  CS_TFT_HIGH;
  
  GPIOE_CRL = 0x33333333;
  GPIOE_CRH = 0x33333333;
  
//  OS_Unuse(&SemaTFT);
  
  return data;
}

// Установка координат для записи
void TFT_SetCoords(Int16U X, Int16U Y)
{
  write_control_TFT(0x20, RESOLUTION_Y - Y - 1);
  write_control_TFT(0x21, X);  
}

// Установка прямоугольной области для записи 
void TFT_SetArea(pInt16U sX, pInt16U eX, pInt16U sY, pInt16U eY)
{
  if (*eX < *sX) *eX = *sX;
  if (*eY < *sY) *eY = *sY;
  
  write_control_TFT(0x50, RESOLUTION_Y - *eY - 1);
  write_control_TFT(0x51, RESOLUTION_Y - *sY - 1);
  write_control_TFT(0x52, *sX );
  write_control_TFT(0x53, *eX );
  TFT_SetCoords(*sX, *sY); 
}

// Запись одного пикселя
void TFT_WritePixel(Int16U X, Int16U Y, Int16U Pixel)
{
  TFT_SetCoords(X, Y);
  fill_GRAM_TFT(1, Pixel);
}

// Запись серии пикселей
void TFT_WritePixels(Int16U X, Int16U Y, pInt16U pPixels, Int16U Count)
{
  TFT_SetCoords(X, Y);
  write_GRAM_TFT(X*Y, pPixels);
}

// Запись серии пикселей в прямоугольную область
void TFT_WritePixelsAt(Int16U sX, Int16U eX, Int16U sY, Int16U eY, pInt16U pPixels)
{
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  write_GRAM_TFT((eX - sX + 1)*(eY - sY + 1), pPixels);
}

// Заполнение всего экрана цветом
void TFT_FillScreen(Int16U Color)
{
  Int16U sX, eX, sY, eY;
  sX = 0;
  eX = RESOLUTION_X - 1;
  sY = 0;
  eY = RESOLUTION_Y - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY);
  fill_GRAM_TFT(RESOLUTION_X*RESOLUTION_Y, Color);
}

// Заполнение прямоугольной области цветом
void TFT_FillRect(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U Color)
{
  TFT_SetArea(&sX, &eX, &sY, &eY);
  fill_GRAM_TFT((eX - sX + 1)*(eY - sY + 1), Color);
}

void TFT_FillRect_(RECT rect, Int16U color)
{
  TFT_FillRect(rect.sX, rect.eX, rect.sY, rect.eY, color);
}

void TFT_FillRect_Offset(RECT rect, Int16U color, Int8S x_offset, Int8S y_offset)
{
  TFT_FillRect(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, color);
}

void TFT_FillRect_Shift(RECT rect, Int16U color, Int8S x_shift, Int8S y_shift)
{
  TFT_FillRect(rect.sX + x_shift, rect.eX + x_shift, rect.sY + y_shift, rect.eY + y_shift, color);
}

// Рисует прямоугольник цветом по умолчанию
void TFT_DrawRect(RECT r)
{
  TFT_FillRect(r.sX, r.eX, r.sY, r.eY, r.color);
}

// Рисует прямоугольник заданным цветом
void TFT_DrawRectWithColor(RECT r, Int16U color)
{
  TFT_FillRect(r.sX, r.eX, r.sY, r.eY, color);
}

// Затемняет прямоугольник цветом
void TFT_GrayoutRect(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U color)
{
  for (int y = sY; y <= eY; y += 2)
  {
    TFT_FillRect(sX, eX, y, y, color);
  }
}

void TFT_GrayoutRect_(RECT rect, Int16U color)
{
  TFT_GrayoutRect(rect.sX, rect.eX, rect.sY, rect.eY, color);
}

void TFT_UnderlineRect_Offset(RECT rect, Int16U color, Int8U line, Int8S x_offset, Int8S y_offset)
{
  TFT_FillRect(rect.sX + x_offset, rect.eX - x_offset, rect.eY - line - y_offset + 1, rect.eY - y_offset, color);
}

// Рисует прямоугольник со скруглёнными углами
void TFT_DrawRoundedRect(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U head_color, Int16U body_color, Int16U back_color)
{
  if ((eX - sX < 40) || (eY - sY < 40)) return;
  
  TFT_FillRect(sX, eX, sY, eY, body_color);
  TFT_FillRect(sX, eX, sY, sY+19-1, head_color);
  
  GUI_DrawImageSwapTwoColors(ULCORNER_19x19, sX, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  GUI_DrawImageSwapTwoColors(URCORNER_19x19, eX-19+1, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  GUI_DrawImageSwapTwoColors(DLCORNER_19x19, sX, eY-19+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
  GUI_DrawImageSwapTwoColors(DRCORNER_19x19, eX-19+1, eY-19+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
}

void TFT_DrawRoundedRectEx(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U head_color, Int16U body_color, Int16U back_color, Int8U rects_mask)
{
  if ((eX - sX < 40) || (eY - sY < 40)) return;
  
  TFT_FillRect(sX, eX, sY, eY, body_color);
  TFT_FillRect(sX, eX, sY, sY+19-1, head_color);
  
  if (rects_mask & 1) GUI_DrawImageSwapTwoColors(ULCORNER_19x19, sX, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  if (rects_mask & 2) GUI_DrawImageSwapTwoColors(URCORNER_19x19, eX-19+1, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  if (rects_mask & 4) GUI_DrawImageSwapTwoColors(DRCORNER_19x19, eX-19+1, eY-19+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
  if (rects_mask & 8) GUI_DrawImageSwapTwoColors(DLCORNER_19x19, sX, eY-19+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
}

// Рисует прямоугольник со скруглёнными углами
void TFT_DrawRoundedRect_(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color)
{
  TFT_DrawRoundedRect(rect.sX, rect.eX, rect.sY, rect.eY, head_color, body_color, back_color);
}

void TFT_DrawRoundedRectEx_(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8U rects_mask)
{
  TFT_DrawRoundedRectEx(rect.sX, rect.eX, rect.sY, rect.eY, head_color, body_color, back_color, rects_mask);
}

void TFT_DrawRoundedRect_TwoColored(RECT rect, Int16U top_color, Int16U bottom_color, Int16U back_color)
{
  TFT_DrawRoundedRect(rect.sX, rect.eX, rect.sY, rect.eY, top_color, bottom_color, back_color);
  Int16U top_eY = (rect.eY - rect.sY)/2;
  TFT_FillRect(rect.sX, rect.eX, rect.sY+19, top_eY, top_color);
}

void TFT_DrawRoundedRect_Offset(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8S x_offset, Int8S y_offset)
{
  TFT_DrawRoundedRect(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, head_color, body_color, back_color);
}

void TFT_DrawRoundedRect_OffsetWithImageAndCaption(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8S x_offset, Int8S y_offset, U32 image_index, char* caption)
{
  TFT_DrawRoundedRect_Offset(rect, head_color, body_color, back_color, x_offset, y_offset);
  if (image_index != 255)
  {
    GUI_DrawImageSwapColor(image_index, rect.sX + 10 + x_offset, rect.sY + y_offset, TEMPLATE_COLOR, head_color);
    TFT_WriteString(caption, BLACK, head_color, rect.sX + 10 + x_offset + 19 + 3, rect.sY + y_offset, &Tahoma19B);
  }
  else
  {
    int width = TFT_StringWidth(caption, &Tahoma19B);
    TFT_WriteString(caption, BLACK, head_color, abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset, rect.sY + y_offset, &Tahoma19B);
  }
}

void TFT_DrawRoundedRectEx_Offset(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8S x_offset, Int8S y_offset, Int8U rects_mask)
{
  TFT_DrawRoundedRectEx(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, head_color, body_color, back_color, rects_mask);
}

void TFT_DrawBorder(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U width, Int16U color)
{
  if (!width) return;
  
  width--;
  TFT_FillRect(sX, eX, sY, sY + width, color);
  TFT_FillRect(eX - width, eX, sY, eY, color);
  TFT_FillRect(sX, eX, eY - width, eY, color);
  TFT_FillRect(sX, sX + width, sY, eY, color);
}

void TFT_DrawBorder_(RECT rect, Int16U width, Int16U color)
{
  TFT_DrawBorder(rect.sX, rect.eX, rect.sY, rect.eY, width, color);
}

void TFT_DrawBorder_WithOffset(RECT rect, Int16U width, Int16U color, Int8S x_offset, Int8S y_offset)
{
  TFT_DrawBorder(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, width, color);
}

// Вывод символа на экран
void TFT_WriteChar(const tImage* ch, Int16U FontColor, Int16U BackColor, Int16U sX, Int16U sY)
{
  const Int8U *data;
  data = (*ch).data;
  
  Int16U eX, eY;
  eX = sX + (*ch).width - 1;
  eY = sY + (*ch).height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  
  start_write_GRAM_TFT();
  for (int i = 0; i < (*ch).height; i++)
    for (int j = 0; j < (*ch).width; j++)
    {
      U8 data_bytes_count = ((*ch).width-1)/8 + 1;
      U8 data_byte_number = i*data_bytes_count + j/8;
      U8 offset = 7 - (j%8);
      switch ((data[data_byte_number] >> offset) & 1)
      {
        case 0: TFT_Load(&BackColor, 1); break;
        case 1: TFT_Load(&FontColor, 1); break;
      }
    }
  stop_write_GRAM_TFT();
}

// Вывод строки на экран
void TFT_WriteString(char* st, Int16U FontColor, Int16U BackColor, Int16U sX, Int16U sY, const tFont* Font)
{
  const tImage* ch = NULL;
  const tFont* font_;
  while (*st)
  {
    font_ = Font;
    if ((*st == '^') && (font_ != &Tahoma10B))
    {
      if (font_ == &Tahoma19B) font_ = &Tahoma10B;
      if (font_ == &Tahoma43) font_ = &Tahoma19B;
      st++;
    }
    
    if ((*st == 'v') && (font_ != &Tahoma10B))
    {
      int height = TFT_StringHeight(st, font_);
      if (font_ == &Tahoma19B) font_ = &Tahoma10B;
      if (font_ == &Tahoma43) font_ = &Tahoma19B;
      sY = sY + height - TFT_StringHeight(st, font_);
      st++;
    }
    
    for (int i = 0; i < (*font_).length; i++)
      if (*st == (*font_).chars[i].code)
      {
        ch = (*font_).chars[i].image;
      }
    if (!ch) goto end;
       
    TFT_WriteChar(ch, FontColor, BackColor, sX, sY);
    sX += (*ch).width;
end:
    st++;
  }
}

void TFT_WriteStringInRectCenter(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U width, height, sX, sY;
  width = TFT_StringWidth(st, Font);
  height = TFT_StringHeight(st, Font);
  sX = abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height/2) + y_offset;
  
  TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

void TFT_WriteStringInRectCenterInTwoLines(char* line1, char* line2, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  if (strlen(line2) == 0)
  {
    TFT_WriteStringInRectCenter(line1, FontColor, BackColor, rect, x_offset, y_offset, Font);
    return;
  }
  
  Int16U width, height, sX, sY;
  
  width = TFT_StringWidth(line1, Font);
  height = TFT_StringHeight(line1, Font);
  sX = abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height) + y_offset;
  TFT_WriteString(line1, FontColor, BackColor, sX, sY, Font);
  
  width = TFT_StringWidth(line2, Font);
  height = TFT_StringHeight(line2, Font);
  sX = abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2) + y_offset;
  TFT_WriteString(line2, FontColor, BackColor, sX, sY, Font);
}

void TFT_WriteStringInRectLeft(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U height, sX, sY;
  height = TFT_StringHeight(st, Font);
  sX = rect.sX + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height/2) + y_offset;
  
  TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

void TFT_WriteStringInRectLeftInTwoLines(char* line1, char* line2, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  if (strlen(line2) == 0)
  {
    TFT_WriteStringInRectLeft(line1, FontColor, BackColor, rect, x_offset, y_offset, Font);
    return;
  }
  
  Int16U height, sX, sY;
  
  height = TFT_StringHeight(line1, Font);
  sX = rect.sX + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height) + y_offset;
  TFT_WriteString(line1, FontColor, BackColor, sX, sY, Font);
  
  height = TFT_StringHeight(line2, Font);
  sX = rect.sX + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2) + y_offset;
  TFT_WriteString(line2, FontColor, BackColor, sX, sY, Font);
}

void TFT_WriteStringInRectRight(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U width, height, sX, sY;
  width = TFT_StringWidth(st, Font);
  height = TFT_StringHeight(st, Font);
  sX = rect.eX - width - x_offset - 1;
  sY = abs((rect.sY + rect.eY + 1)/2 - height/2) + y_offset;
  
  TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

// для терминального вывода
void TFT_WriteStringT(pU8 st)
{
  U8      fY;
  
  fY=20;
  if ((TFT_String.Y + fY) > RESOLUTION_Y) TFT_String.Y = 0;
  TFT_WriteString(st, TFT_String.fColor, TFT_String.bColor, 0, TFT_String.Y, TFT_String.fontType);
  TFT_String.Y += fY;
}

// Вычисляет ширину строки
int TFT_StringWidth(char* st, const tFont* Font)
{
  int width = 0;  
  const tFont* font_;
  
  while (*st)
  {
    font_ = Font;
    if (Font != &Tahoma10B)
    {
      if (*st == 'v')
      {
        if (font_ == &Tahoma19B) font_ = &Tahoma10B;
        if (font_ == &Tahoma43) font_ = &Tahoma19B;
        st++;
        continue;
      }
      
      if (*st == '^')
      {
        if (font_ == &Tahoma19B) font_ = &Tahoma10B;
        if (font_ == &Tahoma43)  font_ = &Tahoma19B;
        st++;
        continue;
      }
    }
	
    for (int i = 0; i < (*font_).length; i++)
      if (*st == (*font_).chars[i].code)
      {
        width += (*(*font_).chars[i].image).width;
      }
    st++;
  }
  
  return width;
}

int TFT_StringHeight(char* st, const tFont* Font)
{
  return (*(*Font).chars[0].image).height;
}

// Ждёт, пока пользователь нажмёт на экран и возвращает координаты
void TFT_WaitForCoords(Int16U* X, Int16U* Y)
{
  Int32U Coords = 0;
  OS_GetMail(&TouchPad_MB, &Coords);
  *X = Coords & 0xFFFF;
  *Y = Coords >> 16;
}

// Проверяет, трогал ли пользователь экран, и возвращает координаты
bool TFT_Touched(Int16U* X, Int16U* Y)
{
  Int32U Coords = 0;
  *X = 65535;
  *Y = 65535;
  if (OS_GetMailCond(&TouchPad_MB, &Coords)) return false;
  
  //OS_ClearMB(&TouchPad_MB);
  *X = Coords & 0xFFFF;
  *Y = Coords >> 16;  
  return true;
}

// Проверяет, нажали пользователь кнопку
Int8U TFT_Pressed()
{
  Int8U button;
  if (OS_GetMailCond(&Key_MB, &button)) return NOT_PRESSED;
  else                                  return button;
}

// Проверяет попадание координат в прямоугольную область
bool TFT_CoordsInRect(Int16U X, Int16U Y, RECT r)
{
  if ((X > r.sX) && (X < r.eX) && (Y > r.sY) && (Y < r.eY))
  {
    OS_ClearMB(&TouchPad_MB);
    return true;
  }
  else
  {
    return false;
  }
}

#pragma optimize=none
// Рисует картинку по адресу
void TFT_DrawImage(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY); 

  load_SD_TFT(width*height, (U32)data_addr);
}

// Рисует картинку по адресу и заменяет пиксели color_to_swap на color
void TFT_DrawImageSwapColor(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height, Int16U color_to_swap, Int16U color)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY);

  Int16U p;
  div_t  n;
  U32    i, j;  
  
  start_write_GRAM_TFT();
  open_SDCard((U32)data_addr);
  n = div(width*height, 256);
  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < 512; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color_to_swap) p = color;
      TFT_Load(&p, 1);
    }
  }
  if(n.rem)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < n.rem*2; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color_to_swap) p = color;
      TFT_Load(&p, 1);
    }
  }
  close_SDCard();
  stop_write_GRAM_TFT();
}

// Рисует картинку по адресу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2
void TFT_DrawImageSwapTwoColors(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY);
  
  Int16U p;
//  U8     buf[512];
  div_t  n;
  U32    i, j;  
  
  start_write_GRAM_TFT();
  open_SDCard((U32)data_addr);
  n = div(width*height, 256);
  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < 512; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;
      TFT_Load(&p, 1);
    }
  }
  if(n.rem)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < n.rem*2; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;      
      TFT_Load(&p, 1);
    }
  }
  close_SDCard();
  stop_write_GRAM_TFT();
}

// Рисует картинку по адресу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2 и color3_to_swap на color3
void TFT_DrawImageSwapThreeColors(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2, Int16U color3_to_swap, Int16U color3)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  
  Int16U p;
//  U8     buf[512];
  div_t  n;
  U32    i, j;  
  
  start_write_GRAM_TFT();
  open_SDCard((U32)data_addr);
  n = div(width*height, 256);
  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < 512; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;
      if (p == color3_to_swap) p = color3;
      TFT_Load(&p, 1);
    }
  }
  if(n.rem)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < n.rem*2; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;
      if (p == color3_to_swap) p = color3;
      TFT_Load(&p, 1);
    }
  }
  close_SDCard();
  stop_write_GRAM_TFT();
}

// Рисует новое окно с сообщением и кнопками
void TFT_DrawMessageBox(char* caption, char* line1, char* line2, char* line3, Int8U type, Int16U background_color)
{
  TFT_GrayoutRect_(SCREEN, background_color);
  TFT_DrawRoundedRectEx_(MESSAGEBOX, MESSAGEBOX_HEAD_COLOR, MESSAGEBOX_COLOR, background_color, 0);
  
  TFT_WriteString(caption, BLACK, MESSAGEBOX_HEAD_COLOR, MESSAGEBOX_CAPTION_SX, MESSAGEBOX_CAPTION_SY, &Tahoma19B);
  TFT_WriteString(line1, BLACK, MESSAGEBOX_COLOR, MESSAGEBOX_LINES_SX, MESSAGEBOX_LINE1_SY, &Tahoma19B);
  TFT_WriteString(line2, BLACK, MESSAGEBOX_COLOR, MESSAGEBOX_LINES_SX, MESSAGEBOX_LINE2_SY, &Tahoma19B);
  TFT_WriteString(line3, BLACK, MESSAGEBOX_COLOR, MESSAGEBOX_LINES_SX, MESSAGEBOX_LINE3_SY, &Tahoma19B);   
  
  switch (type)
  {
  case MESSAGEBOX_OK:
    GUI_DrawImageInRectCenterSwapColor(OK_30x30, MESSAGEBOX_CBUTTON, TEMPLATE_COLOR, MESSAGEBOX_COLOR);
    break;
    
  case MESSAGEBOX_YESNO:
    GUI_DrawImageInRectCenterSwapColor(OK_30x30, MESSAGEBOX_LBUTTON, TEMPLATE_COLOR, MESSAGEBOX_COLOR);
    GUI_DrawImageInRectCenterSwapColor(CANCEL_30x30, MESSAGEBOX_RBUTTON, TEMPLATE_COLOR, MESSAGEBOX_COLOR);
    break;
  }
}

void TFT_DrawKeyboard(char* topic, char* title, bool is_unsigned, bool is_float, bool is_ip)
{
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, topic, title);

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  TFT_DrawRoundedRect_Offset(KEY_1, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("1", BLACK, ODD_GREEN, KEY_1, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_2, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("2", BLACK, ODD_GREEN, KEY_2, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_3, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("3", BLACK, ODD_GREEN, KEY_3, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_4, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("4", BLACK, ODD_GREEN, KEY_4, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_5, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("5", BLACK, ODD_GREEN, KEY_5, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_6, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("6", BLACK, ODD_GREEN, KEY_6, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_7, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("7", BLACK, ODD_GREEN, KEY_7, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_8, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("8", BLACK, ODD_GREEN, KEY_8, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_9, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("9", BLACK, ODD_GREEN, KEY_9, 0, 0, &Tahoma43);
  TFT_DrawRoundedRect_Offset(KEY_0, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("0", BLACK, ODD_GREEN, KEY_0, 0, 0, &Tahoma43);
  if (is_float || is_ip)
  {
    TFT_DrawRoundedRect_Offset(KEY_D, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
    TFT_WriteStringInRectCenter(".", BLACK, ODD_GREEN, KEY_D, 0, 0, &Tahoma43);
  }
  if (!is_unsigned && !is_ip)
  {
    TFT_DrawRoundedRect_Offset(KEY_M, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
    TFT_WriteStringInRectCenter("±", BLACK, ODD_GREEN, KEY_M, 0, 0, &Tahoma43);
  }
  TFT_DrawRoundedRect_Offset(KEY_B, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  GUI_DrawImageInRectCenterSwapColor(DELETE_30x30, KEY_B, TEMPLATE_COLOR, ODD_GREEN);
}

// Рисует картинку по индексу
void GUI_DrawImage(U32 image_index, Int16U sX, Int16U sY)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImage(data_addr, sX, sY, width, height);
}

// Рисует картинку по индексу и заменяет пиксели color_to_swap на color
void GUI_DrawImageSwapColor(U32 image_index, Int16U sX, Int16U sY, Int16U color_to_swap, Int16U color)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapColor(data_addr, sX, sY, width, height, color_to_swap, color);
}

// Рисует картинку по индексу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2
void GUI_DrawImageSwapTwoColors(U32 image_index, Int16U sX, Int16U sY, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapTwoColors(data_addr, sX, sY, width, height, color1_to_swap, color1, color2_to_swap, color2);
}

// Рисует картинку по индексу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2 и color3_to_swap на color3
void GUI_DrawImageSwapThreeColors(U32 image_index, Int16U sX, Int16U sY, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2, Int16U color3_to_swap, Int16U color3)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapThreeColors(data_addr, sX, sY, width, height, color1_to_swap, color1, color2_to_swap, color2, color3_to_swap, color3);
}

// Рисует картинку в прямоугольнике
void GUI_DrawImageInRect(U32 image_index, RECT rect)
{
  GUI_DrawImage(image_index, rect.sX, rect.sY);
}

// Рисует картинку по центру прямоугольника и замещает цвет
void GUI_DrawImageInRectCenterSwapColor(U32 image_index, RECT rect, Int16U color_to_swap, Int16U color)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapColor(data_addr, rect.sX + (rect.eX - rect.sX)/2 - width/2, rect.sY + (rect.eY - rect.sY)/2 - height/2, width, height, color_to_swap, color);
}

void GUI_DrawImageInRectCenterSwapColor_Shift(U32 image_index, RECT rect, Int16U color_to_swap, Int16U color, Int8S x_shift, Int8S y_shift)
{
  rect.sX += x_shift;
  rect.eX += x_shift;
  rect.sY += y_shift;
  rect.eY += y_shift;
  GUI_DrawImageInRectCenterSwapColor(image_index, rect, color_to_swap, color);
}

void GUI_DrawTextAndImageInRectCenter(char* st, Int16U FontColor, Int16U BackColor, const tFont* font, U32 image_index, RECT rect, Int16U color_to_swap, Int16U color)
{
  Int16U image_width, image_height, text_width, text_height;
  Int32U *data_addr;
  Int16U sX, sY;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  image_width = *((Int16U*)&buf[descriptor_addr%512+4]);
  image_height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((image_width > RESOLUTION_X) || (image_height > RESOLUTION_Y)) return;
  
  text_width  = TFT_StringWidth(st, font);
  text_height = TFT_StringHeight(st, font);
  sX = rect.sX + (rect.eX - rect.sX)/2 - (text_width+image_width)/2;
  sY = rect.sY + (rect.eY - rect.sY)/2 - text_height/2;
  TFT_WriteString(st, FontColor, BackColor, sX, sY, font);
  
  sX = rect.sX + (rect.eX - rect.sX)/2 - (text_width+image_width)/2;
  sX = sX + text_width;
  sY = rect.sY + (rect.eY - rect.sY)/2 - image_height/2;
  TFT_DrawImageSwapColor(data_addr, sX, sY, image_width, image_height, color_to_swap, color);
}

// Заполняет место картинки цветом
void GUI_FillImageRect(U32 image_index, Int16U sX, Int16U sY, Int16U color)
{
  Int16U width, height;
  Int32U *width_addr, *height_addr;

  if (image_index > MAX_IMAGES - 1) return;

  width_addr = (Int32U*)(IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE + 4);
  width = *width_addr;

  height_addr = (Int32U*)(IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE + 8);
  height = *height_addr;

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;
  
  TFT_FillRect(sX, sX+width-1, sY, sY+height-1, color);
}

// Выводит сообщение в новом окне с одной или двумя кнопками с таймаутом в секундах (0 - без такового)
bool GUI_MessageBox(char* caption, char* line1, char* line2, char* line3, Int8U timeout, Int8U type, Int16U background_color)
{
  TFT_DrawMessageBox(caption, line1, line2, line3, type, background_color);
  OS_ClearMB(&TouchPad_MB);
  
  Int16U X, Y;
  Int8U button;
  int elapsed = 0;
  while ((elapsed <= timeout*1000) || (timeout == 0))
  {
    button = TFT_Pressed();
    if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED))
    {
      OS_Delay(50);
      elapsed += 50;
      continue;
    }
    
    switch (type)
    {
    case MESSAGEBOX_OK:
      if (TFT_CoordsInRect(X, Y, MESSAGEBOX_CBUTTON))
      {
        set_sound(S_SOUND_20);
        return true;
      }
      break;
      
    case MESSAGEBOX_YESNO:
      if (TFT_CoordsInRect(X, Y, MESSAGEBOX_LBUTTON))
      {
        set_sound(S_SOUND_20);
        return true;
      }
      if (TFT_CoordsInRect(X, Y, MESSAGEBOX_RBUTTON))
      {
        set_sound(S_SOUND_20);
        return false;
      }
      if (button == BACK_BUTTON)
      {
        set_sound(S_SOUND_20);
        return false;
      }
      break;
    }
  }
  
  return false;
}

// Удаляет i-ый символ из стоки
void strdel(char *st, int i)
{
  for (int j = i; j < strlen(st) - 1 ; j++) st[j] = st[j+1];
  st[strlen(st)-1] = 0;
}

void strdel_(char *st, char c)
{
  for (int i = 0; i < strlen(st) - 1 ; i++)
    if (st[i] == c)
      strdel(st, i);
}

// Вставляет символ c на i-ую позицию в строке
void strinsert(char *st, char c, int i)
{
  int new_lenght = strlen(st) + 1;
  for (int j = strlen(st); j > i; j--) st[j] = st[j-1];
  st[i] = c;
  st[new_lenght] = 0;
}

int charcount(char *st, char c)
{
  int count = 0;
  
  for (int i = 0; i < strlen(st); i++)
    if (st[i] == c)
      count++;
  
  return count;
}

bool GUI_KeyboardChar(char* value, char* topic, char* title, bool is_unsigned, bool is_float, bool is_ip)
{
  TFT_DrawKeyboard(topic, title, is_unsigned, is_float, is_ip);
  OS_ClearMB(&TouchPad_MB);
  
  const tFont* pFont;
  if (is_ip)
    pFont = &Tahoma19B;
  else
    pFont = &Tahoma43;
  
  char display[20];
  Int16U X, Y;
  Int8U button;
  while (1)
  {
    if (!is_ip)
    {
      if (value[0] == '0')
        if ((value[1] != '.') && (value[1] != 0))
          strdel(value, 0);
      if (value[0] == '-')
        if (value[1] == '0')
          if ((value[2] != '.') && (value[2] != 0))
            strdel(value, 1);
      if (strlen(value) > 10)
        value[10] = 0;
    }
    if (is_ip)
    {
      if (value[0] == '0')
        if ((value[1] != '.') && (value[1] != 0))
          strdel(value, 0);
      if (strlen(value) > 16)
        value[16] = 0;
    }
    
    sprintf(display, "%s", value);
    TFT_WriteStringInRectCenter(display, BLACK, BACKGROUND_COLOR, VALUE, 0, 0, pFont);
    
    button = TFT_Pressed();
    if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED))
    {
      GUI_UpdateHeader();
      if( OS_WaitSingleEventTimed(1, 50) ) 
      {
        OS_SignalEvent( 1, &OS_TFT);
        return false;
      }
      continue;
    }
    
    if (TFT_CoordsInRect(X, Y, KEY_1)) {sprintf(value, "%s%c", value, '1'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_2)) {sprintf(value, "%s%c", value, '2'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_3)) {sprintf(value, "%s%c", value, '3'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_4)) {sprintf(value, "%s%c", value, '4'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_5)) {sprintf(value, "%s%c", value, '5'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_6)) {sprintf(value, "%s%c", value, '6'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_7)) {sprintf(value, "%s%c", value, '7'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_8)) {sprintf(value, "%s%c", value, '8'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_9)) {sprintf(value, "%s%c", value, '9'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_0)) {sprintf(value, "%s%c", value, '0'); set_sound(S_SOUND_20);}
    
    if (is_float)
      if (TFT_CoordsInRect(X, Y, KEY_D))
      {
        if (memchr(value, '.', strlen(value)) == NULL)
        {
          sprintf(value, "%s%c", value, '.');
          set_sound(S_SOUND_20);
        }
      }
    
    if (is_ip)
      if (TFT_CoordsInRect(X, Y, KEY_D))
        if (charcount(value, '.') < 3)
        {
          sprintf(value, "%s%c", value, '.');
          set_sound(S_SOUND_20);
        }
    
    if (!is_unsigned)
      if (TFT_CoordsInRect(X, Y, KEY_M))
      {
        if (value[0] != '-')
        {
          strinsert(value, '-', 0);
        }
        else
        {
          strdel(value, 0);
          TFT_FillRect_(VALUE, BACKGROUND_COLOR);
        }
        set_sound(S_SOUND_20);
      }
    
    if (TFT_CoordsInRect(X, Y, KEY_B))
    {
      if (value[0] == '-')
      {
        if (strlen(value) > 2)
          value[strlen(value)-1] = 0;
        else
          sprintf(value, "-0");
      }
      else
      {
        if (strlen(value) > 1)
          value[strlen(value)-1] = 0;
        else
          sprintf(value, "0");
      }
      TFT_FillRect_(VALUE, BACKGROUND_COLOR);
      set_sound(S_SOUND_20);
    }
    
    if (TFT_CoordsInRect(X, Y, CHANNEL0))
    {
      set_sound(S_SOUND_20);
      return true;
    }
    if (button == BACK_BUTTON)
    {
      set_sound(S_SOUND_20);
      return false;
    }
  }
}

bool GUI_KeyboardInt(int* value, char* topic, char* title, bool is_unsigned, int min, int max)
{
  char _int[20];
  sprintf(_int, "%d", *value);
  if (!GUI_KeyboardChar(_int, topic, title, is_unsigned, false, false))
    return false;
  
  sscanf(_int, "%d", value);
  if ((min != 0) || (max != 0))
  {
    if (*value < min) *value = min;
    if (*value > max) *value = max;
  }
  return true;
}

bool GUI_KeyboardFloat(float* value, char* topic, char* title, bool is_unsigned, float min, float max, int decimal)
{
  char _float[15];
  sprintf(_float, "%.*f", decimal, *value);
  if (!GUI_KeyboardChar(_float, topic, title, is_unsigned, decimal != 0, false))
    return false;
  
  sscanf(_float, "%f", value);
  if ((min != 0) || (max != 0))
  {
    if (*value < min) *value = min;
    if (*value > max) *value = max;
  }
  return true;
}

bool GUI_KeyboardIP(Int32U* value, char* topic, char* title)
{
  char ip[25];
  ParseIPAddress(*value, ip);
  if (!GUI_KeyboardChar(ip, topic, title, true, false, true))
    return false;
  
  if (charcount(ip, '.')  !=  3)
    return false;
  
  PackIPAddress(value, ip);
  return true;
}

void GUI_ShowNotification()
{
}

// Устанавливает функции графического пользовательского интерфейса
void GUI_SetGUI(void (*draw_function)(void), void (*update_function)(void), void (*touch_function)(void))
{
  draw   = draw_function;
  update = update_function;
  touch  = touch_function;
  
  if (draw) draw();
}

// Позволяет откалибровать тач-панель
void GUI_CalibTouch()
{  
  F32       new_TFT_Calib[2][2];
  U16       X, Y;
  U16       x[4], y[4];
  U16       xL, xR, yU, yD;
  
  OS_Use(&SemaRAM);
  system_flags.touch_calib = 1;
  OS_Unuse(&SemaRAM);
  
  TFT_FillScreen(WHITE);  
  TFT_WriteStringInRectCenterInTwoLines("Нажимайте в центр", "появляющихся квадратов", BLACK, WHITE, LOWER, 0, 0, &Tahoma19B);

  // U, L  
  OS_ClearMB(&TouchPad_MB);  
  TFT_DrawRect(CALIB_ULCORNER);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[0] = X;
  y[0] = Y;
  set_sound(S_SOUND_20);
  
  // U, R
  TFT_DrawRectWithColor(CALIB_ULCORNER, WHITE);
  TFT_DrawRect(CALIB_URCORNER);
  OS_Delay(1000);
  
  OS_ClearMB(&TouchPad_MB);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[1] = X;
  y[1] = Y;
  set_sound(S_SOUND_20);

  // D, R
  TFT_DrawRectWithColor(CALIB_URCORNER, WHITE);
  TFT_DrawRect(CALIB_DRCORNER);
  OS_Delay(1000);
  
  OS_ClearMB(&TouchPad_MB);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[2] = X;
  y[2] = Y;
  set_sound(S_SOUND_20);
  
  // D, L
  TFT_DrawRectWithColor(CALIB_DRCORNER, WHITE);  
  TFT_DrawRect(CALIB_DLCORNER);
  OS_Delay(1000);
  
  OS_ClearMB(&TouchPad_MB);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[3] = X;
  y[3] = Y;
  set_sound(S_SOUND_20);
  
  TFT_DrawRectWithColor(CALIB_DLCORNER, WHITE);
  
  xL = (x[0] + x[3]) / 2; xR = (x[1] + x[2]) / 2;
  yU = (y[0] + y[1]) / 2; yD = (y[2] + y[3]) / 2;  

  new_TFT_Calib[0][1] = (F32)(calibPointsX[1] - calibPointsX[0]) / (xR - xL);                // B0   
  new_TFT_Calib[0][0] = (F32)calibPointsX[0] - new_TFT_Calib[0][1] * xL ;                   // A0   x = A0 + B0 * X 
  new_TFT_Calib[1][1] = (F32)(calibPointsY[1] - calibPointsY[0]) / (yD - yU);                // B1   
  new_TFT_Calib[1][0] = (F32)calibPointsY[0] - new_TFT_Calib[1][1] * yU ;                   // A1   y = A1 + B1 * Y 
      
  OS_Use(&SemaRAM);
  
  TFT_Calib[0][0] = new_TFT_Calib[0][0];
  TFT_Calib[0][1] = new_TFT_Calib[0][1];
  TFT_Calib[1][0] = new_TFT_Calib[1][0];
  TFT_Calib[1][1] = new_TFT_Calib[1][1];
  system_flags.touch_calib = 0;
  
  OS_Unuse(&SemaRAM);  
  
  TFT_DrawRect(CALIB_CENTER);
  OS_Delay(1000);
  OS_ClearMB(&TouchPad_MB);
  TFT_WaitForCoords(&X, &Y);
  set_sound(S_SOUND_20);
  
  if (TFT_CoordsInRect(X, Y, CALIB_CENTER))
  {
    TFT_FillRect(X-5, X+5, Y-5, Y+5, YELLOW);
    TFT_WriteStringInRectCenter("Экран откалиброван", DARKGREEN, WHITE, LOWERMOST, 0, 0, &Tahoma19B);
    
    OS_Use(&SemaRAM);
    SAVE_CONFIG(TFT_Calib);
    SAVE_DEFAULT_CONFIG(TFT_Calib);
    OS_Unuse(&SemaRAM);
  }
  else
  {
    TFT_FillRect(X-5, X+5, Y-5, Y+5, RED);
    TFT_WriteStringInRectCenter("Ошибка калибровки", RED, WHITE, LOWERMOST, 0, 0, &Tahoma19B);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(TFT_Calib);
    OS_Unuse(&SemaRAM);
  }
  
  OS_Delay(2000);
  OS_ClearMB(&TouchPad_MB);    
  
  if (draw) draw();
}

// Показывает приветственный экран с логотипом
void GUI_LogoScreen()
{
  TFT_FillScreen(BLACK);
  GUI_DrawImage(EKSIS_LOGO_320x240, 0, 0);
  OS_Delay(4000);
  TFT_FillScreen(WHITE);
}

// Рисует заголовок
void GUI_DrawHeader(Int8U button_image, Int16U back_color, char* topic, char* title)
{
  TFT_FillRect_Offset(CHANNEL0, back_color, 0, 0);
  if (button_image != 255)
    GUI_DrawImageInRectCenterSwapColor(button_image, CHANNEL0, TEMPLATE_COLOR, back_color);

  TFT_FillRect_(TOPIC, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC, 3, 0, &Tahoma19B);
  TFT_FillRect_(TIME, ODD_GRAY);
 
  TFT_FillRect_(TITLE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE, 0, 0, &Tahoma19B);
  
  GUI_DrawStatusIcons();
  
  GUI_UpdateHeader();
}

void GUI_DrawHeaderGrayoutButton(Int8U button_image, Int16U back_color, char* topic, char* title)
{
  TFT_FillRect_Offset(CHANNEL0, back_color, 0, 0);
  if (button_image != 255)
    GUI_DrawImageInRectCenterSwapColor(button_image, CHANNEL0, TEMPLATE_COLOR, back_color);
  TFT_GrayoutRect_(CHANNEL0, BACKGROUND_COLOR);

  TFT_FillRect_(TOPIC, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC, 3, 0, &Tahoma19B);
  TFT_FillRect_(TIME, ODD_GRAY);
 
  TFT_FillRect_(TITLE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE, 0, 0, &Tahoma19B);
  
  GUI_DrawStatusIcons();
  
  GUI_UpdateHeader();
}

// Обновляет заголовок
void GUI_UpdateHeader()
{
  GUI_DrawStatusIcons();
  GUI_DrawTime();
}

void GUI_UpdateHeaderImage(Int8U button_image, Int16U back_color)
{
  GUI_UpdateHeader();
  
  TFT_FillRect_Offset(CHANNEL0, back_color, 0, 0);
  if (button_image != 255)
    GUI_DrawImageInRectCenterSwapColor(button_image, CHANNEL0, TEMPLATE_COLOR, back_color);
}

void GUI_UpdateHeaderText(char* topic, char* title)
{
  GUI_UpdateHeader();
  TFT_FillRect_(TOPIC, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC, 3, 0, &Tahoma19B);
  TFT_FillRect_(TITLE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE, 0, 0, &Tahoma19B);
}

// Рисует время
void GUI_DrawTime()
{
  int y, m, d, h, mi, s;
  ParseDate(&Time, &s, &mi, &h, &d, &m, &y);
  char text[6];
  sprintf(text, "%.2d:%.2d", h, mi);
  TFT_WriteStringInRectCenter(text, BLACK, ODD_GRAY, TIME, 0, 0, &Tahoma19B);
}

// Рисует значки рядом с часами
void GUI_DrawStatusIcons()
{
  int sX, sY;
  sY = TIME.sY + 2;
  
  sX = TIME.sX - 28;
  if (USB_IsConfigured()) TFT_WriteString("\x00A4", DEEPBLUE, ODD_GRAY, sX, sY, &Tahoma19B);
  else                    TFT_WriteString("\x00A4", ODD_GRAY, ODD_GRAY, sX, sY, &Tahoma19B);

  sX -= 24;
  if (IP_IFaceIsReady(0)) TFT_WriteString("\x00AB", DEEPBLUE, ODD_GRAY, sX, sY, &Tahoma19B);
  else                    TFT_WriteString("\x00AB", ODD_GRAY, ODD_GRAY, sX, sY, &Tahoma19B);
}

// Рисует экран измерений
void GUI_DrawMeasuresScreen()
{
  GUI_DrawHeader(NO_IMAGE, EVEN_YELLOW, "Измерение", "");

  if (GetDisplayChannelsCount() == 1)
  {
    CurrentDisplay = 0;
    GUI_DrawMeasuresChannelOne();
  }  
  else if (CurrentDisplay == 255)
    GUI_DrawMeasuresAll();
  else
    GUI_DrawMeasuresChannel();
}

// Обновляет экран измерений
void GUI_UpdateMeasuresScreen()
{
  GUI_UpdateHeader();
  
  if (GetDisplayChannelsCount() == 1)
    GUI_UpdateMeasuresChannelOne();
  else if (CurrentDisplay == 255)
    GUI_UpdateMeasuresAll();
  else
    GUI_UpdateMeasuresChannel();
}

// Проверяет нажатия на экране измерений
void GUI_TouchMeasuresScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if ((button == SWITCH_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    if ((CurrentDisplay != 255) && (GetDisplayChannelsCount() != 1))
    {
      set_sound(S_SOUND_20);
      CurrentDisplay = 255;
      GUI_DrawMeasuresAll();
      return;
    }
  }
  
  if (GetDisplayChannelsCount() == 1)
    GUI_TouchMeasuresChannelOne(X, Y);
  else if (CurrentDisplay == 255)
    GUI_TouchMeasuresAll(X, Y);
  else
    GUI_TouchMeasuresChannel(X, Y);
}

// Рисует тело главного экрана
void GUI_DrawMeasuresAll()
{
  GUI_UpdateHeaderImage(SETTINGS_30x30, EVEN_YELLOW);
  GUI_UpdateHeaderText("Измерение", "Все каналы");
  
  TFT_DrawRect(BODY);
  
  Int8U count = GetDisplayChannelsCount();
  if (count > 4) count = 4;
  
  Int16U color;
  char display[25];
  int first, second;
  for (int i = 0; i < count; i++)
  {
    color = (i % 2) == 0 ? ODD_GREEN : EVEN_GREEN;
    TFT_FillRect_(*Channels[i], color/*+3*/);
    sprintf(display, "%d", i+1);
    TFT_WriteString(display, BLACK, color/*+3*/, (*Channels[i]).sX+1, (*Channels[i]).sY, &Tahoma19B);
    GUI_DrawImageInRectCenterSwapColor(MAGNIFIER_30x30, *Channels[i], TEMPLATE_COLOR, color/*+3*/);
    
    TFT_FillRect_(*Params[i], color);
    
    GetChosenParams(i, &first, &second);
    if ((first != -1) && (second != -1))
    {
      GetParamName(i, first, display);
      TFT_WriteStringInRectCenter(display, BLACK, color, *LCaptions[i], 0, 0, &Tahoma19B);
      
      GetParamName(i, second, display);
      TFT_WriteStringInRectCenter(display, BLACK, color, *RCaptions[i], 0, 0, &Tahoma19B);
    }
    else if (first != -1)
    {
      GetParamName(i, first, display);
      TFT_WriteStringInRectCenter(display, BLACK, color, *Captions[i], 0, 0, &Tahoma19B);
    }
  }
  
  GUI_UpdateMeasuresAll();
}

// Обновляет главный экран - показания
void GUI_UpdateMeasuresAll()
{
  Int16U color;
  char display[25];
  
  Int8U channels_count = GetDisplayChannelsCount();
  if (channels_count > 4) channels_count = 4;
  
  int first, second;
  for (int i = 0; i < channels_count; i++)
  {
    Int16U back_color = (i % 2) == 0 ? ODD_GREEN : EVEN_GREEN;
        
    GetChosenParams(i, &first, &second);
    if ((first != -1) && (second != -1))
    {
      GetMeasureString(i, first, display, &color);
      TFT_FillRect_(*LValues[i], back_color);
      TFT_WriteStringInRectCenter(display, color, back_color, *LValues[i], 0, 0, &Tahoma19B);
          
      GetMeasureString(i, second, display, &color);
      TFT_FillRect_(*RValues[i], back_color);
      TFT_WriteStringInRectCenter(display, color, back_color, *RValues[i], 0, 0, &Tahoma19B);
    }
    else if (first != -1)
    {
      GetMeasureString(i, first, display, &color);
      TFT_FillRect_(*Values[i], back_color);
      TFT_WriteStringInRectCenter(display, color, back_color, *Values[i], 0, 0, &Tahoma19B);
    }
  }
}

void GUI_TouchMeasuresAll(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  Int8U channels_count = GetDisplayChannelsCount();
  if (channels_count > 4) channels_count = 4;
  
  int first, second;
  for (int i = 0; i < channels_count; i++)
  {
    if (TFT_CoordsInRect(X, Y, *Channels[i]))
    {
      set_sound(S_SOUND_20);
      CurrentDisplay = i;
      GUI_DrawMeasuresChannel();
      return;
    }
    
    GetChosenParams(i, &first, &second);
    if ((first != -1) && (second != -1))
    {
      if (TFT_CoordsInRect(X, Y, *LParams[i]))
      {
        set_sound(S_SOUND_20);
        CurrentDisplay = i;
        CurrentParam = first;
        BackToAllChannels = true;
        GUI_SetGUI(GUI_DrawParamRootScreen, GUI_UpdateParamRootScreen, GUI_TouchParamRootScreen);
        return;
      }
      if (TFT_CoordsInRect(X, Y, *RParams[i]))
      {
        set_sound(S_SOUND_20);
        CurrentDisplay = i;
        CurrentParam = second;
        BackToAllChannels = true;
        GUI_SetGUI(GUI_DrawParamRootScreen, GUI_UpdateParamRootScreen, GUI_TouchParamRootScreen);
        return;
      }
    }
    else if (first != -1)
    {
      if (TFT_CoordsInRect(X, Y, *Params[i]))
      {
        set_sound(S_SOUND_20);
        CurrentDisplay = i;
        CurrentParam = first;
        BackToAllChannels = true;
        GUI_SetGUI(GUI_DrawParamRootScreen, GUI_UpdateParamRootScreen, GUI_TouchParamRootScreen);
        return;
      }
    }
  }
}

void GUI_DrawMeasuresChannel()
{
  char display[25];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_UpdateHeaderImage(SETTINGS_CHANNEL_30x30, EVEN_YELLOW);
  GUI_UpdateHeaderText("Измерение", display);
  
  TFT_DrawRect(BODY);
  
  Int8U count = GetDisplayChannelsCount();
  if (count > 4) count = 4;

  Int16U font_color, color;
  int first, second;
  for (int i = 0; i < count; i++)
  {
    if (CurrentDisplay == i)
    {
      color = (i % 2) == 0 ? ODD_GREEN : EVEN_GREEN;
      TFT_FillRect_(*Channels[i], color);
      sprintf(display, "%d", i+1);
      TFT_WriteString(display, BLACK, color, (*Channels[i]).sX+1, (*Channels[i]).sY, &Tahoma19B);
      GUI_DrawImageInRectCenterSwapColor(MAGNIFIER_30x30, *Channels[i], TEMPLATE_COLOR, color);
      
      TFT_FillRect_(UMPARAM, color);
      TFT_FillRect_(UPARAM, color);
      TFT_FillRect_(LPARAM, color);
      TFT_FillRect_(LMPARAM, color);
      
      Int8U params_count = GetDisplayChannelParamsCount(i);
      if (params_count > 6) params_count = 6;
      
      for (int j = 0; j < params_count; j++)
      {
        GetParamName(i, j, display);
        GetChosenParams(CurrentDisplay, &first, &second);
        
        font_color = (j == first) || (j == second) ? BROWN : BLACK;
        int k = DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_PLACEMENT_MASK;
        if (k >= 12) k = 11;
        RECT placement = *CAPTIONS_SEQUENCE[k];
        TFT_WriteStringInRectCenter(display, font_color, color, placement, 0, 0, &Tahoma19B);
      }
    }
    
    if (CurrentDisplay != i)
    {
      color = BACKGROUND_COLOR;
      TFT_FillRect_(*Channels[i], color);
      sprintf(display, "%d", i+1);
      TFT_WriteString(display, BLACK, color, (*Channels[i]).sX+1, (*Channels[i]).sY, &Tahoma19B);
      GUI_DrawImageInRectCenterSwapColor(MAGNIFIER_30x30, *Channels[i], TEMPLATE_COLOR, color);
    }
  }
  
  GUI_UpdateMeasuresChannel();
}

// Обновляет главный экран - показания
void GUI_UpdateMeasuresChannel()
{
  Int16U color;
  char display[25];
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
  
  for (int i = 0; i < params_count; i++)
  {
    Int16U back_color = (CurrentDisplay % 2) == 0 ? ODD_GREEN : EVEN_GREEN;

    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *VALUES_SEQUENCE[k];
    TFT_FillRect_(placement, back_color);
    GetMeasureString(CurrentDisplay, i, display, &color);
    TFT_WriteStringInRectCenter(display, color, back_color, placement, 0, 0, &Tahoma19B);
  }
}

void GUI_TouchMeasuresChannel(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U channels_count = GetDisplayChannelsCount();
  if (channels_count > 4) channels_count = 4;
  
  for (int i = 0; i < channels_count; i++)
  {
    if (TFT_CoordsInRect(X, Y, *Channels[i]))
    {
      if (GetDisplayChannelsCount() == 1) return;
      
      set_sound(S_SOUND_20);
      if (CurrentDisplay == i) 
      {
        CurrentDisplay = 255;
        GUI_DrawMeasuresAll();
      }
      else
      {
        CurrentDisplay = i;
        GUI_DrawMeasuresChannel();
      }
      return;
    }
  }
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT caption_placemnt = *CAPTIONS_SEQUENCE[k];
    RECT value_placemnt = *VALUES_SEQUENCE[k];
    if (TFT_CoordsInRect(X, Y, caption_placemnt) || TFT_CoordsInRect(X, Y, value_placemnt))
    {
      set_sound(S_SOUND_20);
      CurrentParam = i;
      BackToAllChannels = false;
      GUI_SetGUI(GUI_DrawParamRootScreen, GUI_UpdateParamRootScreen, GUI_TouchParamRootScreen);
      return;
    }
  }
}

void GUI_DrawMeasuresChannelOne()
{
  char display[25];
  GUI_UpdateHeaderText("Измерение", "Канал 1");
  
  TFT_DrawRect(BODY);
  
  TFT_FillRect_(MENU0, EVEN_YELLOW);
  TFT_FillRect_(MENU1, EVEN_YELLOW);
  TFT_FillRect_(MENU2, EVEN_YELLOW);
  TFT_FillRect_(MENU3, EVEN_YELLOW);

  GUI_DrawImageInRectCenterSwapColor(INFO_MENU_30x30,       MENU0, TEMPLATE_COLOR, EVEN_YELLOW);
  GUI_DrawImageInRectCenterSwapColor(CONNECTION_MENU_30x30, MENU1, TEMPLATE_COLOR, EVEN_YELLOW);
  GUI_DrawImageInRectCenterSwapColor(STATISTIC_MENU_30x30,  MENU2, TEMPLATE_COLOR, EVEN_YELLOW);
  GUI_DrawImageInRectCenterSwapColor(OTHER_MENU_30x30,      MENU3, TEMPLATE_COLOR, EVEN_YELLOW);

  TFT_FillRect_(UMPARAM, ODD_GREEN);
  TFT_FillRect_(UPARAM, ODD_GREEN);
  TFT_FillRect_(LPARAM, ODD_GREEN);
  TFT_FillRect_(LMPARAM, ODD_GREEN);
  
  Int8U params_count = GetDisplayChannelParamsCount(0);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    GetParamName(0, j, display);
    
    int k = DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *CAPTIONS_SEQUENCE[k];
    TFT_WriteStringInRectCenter(display, BLACK, ODD_GREEN, placement, 0, 0, &Tahoma19B);
  }
  
  if (ConfigWord & PUMP_CONTROL_DEVICE)
    GUI_DrawPumpControlPanel();
  
  GUI_UpdateMeasuresChannelOne();
}

void GUI_UpdateMeasuresChannelOne()
{
  Int16U color;
  char display[25];
  
  Int8U params_count = GetDisplayChannelParamsCount(0);
  if (params_count > 6) params_count = 6;
  
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *VALUES_SEQUENCE[k];
    TFT_FillRect_(placement, ODD_GREEN);
    GetMeasureString(CurrentDisplay, i, display, &color);
    TFT_WriteStringInRectCenter(display, color, ODD_GREEN, placement, 0, 0, &Tahoma19B);
  }
  
  if (ConfigWord & PUMP_CONTROL_DEVICE)
    GUI_UpdatePumpControlPanel();
}

void GUI_TouchMeasuresChannelOne(Int16U X, Int16U Y)
{
  Int8U channels_count = GetDisplayChannelsCount();
  if (channels_count > 4) channels_count = 4;
  
  if (TFT_CoordsInRect(X, Y, MENU0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsInfoScreen, GUI_UpdateSettingsInfoScreen, GUI_TouchSettingsInfoScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU1))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU2))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsStatisticScreen, GUI_UpdateSettingsStatisticScreen, GUI_TouchSettingsStatisticScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU3))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  Int8U params_count = GetDisplayChannelParamsCount(0);
  if (params_count > 6) params_count = 6;
      
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT caption_placemnt = *CAPTIONS_SEQUENCE[k];
    RECT value_placemnt = *VALUES_SEQUENCE[k];
    if (TFT_CoordsInRect(X, Y, caption_placemnt) || TFT_CoordsInRect(X, Y, value_placemnt))
    {
      set_sound(S_SOUND_20);
      CurrentParam = i;
      BackToAllChannels = false;
      GUI_SetGUI(GUI_DrawParamRootScreen, GUI_UpdateParamRootScreen, GUI_TouchParamRootScreen);
      return;
    }
  }
  
  if (ConfigWord & PUMP_CONTROL_DEVICE)
    GUI_TouchPumpControlPanel(X, Y);
}

void GUI_DrawPumpControlPanel()
{
  TFT_FillRect_(LPARAM, EVEN_GREEN);
  TFT_WriteStringInRectCenter("Измерения", BLACK, EVEN_GREEN, LLCAPTION, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Состояние", BLACK, EVEN_GREEN, LRCAPTION, 0, 0, &Tahoma19B);
  
  TFT_FillRect_(LMPARAM, EVEN_GREEN);
  TFT_DrawRoundedRect_Offset(LMCPARAM, ODD_GREEN+3, ODD_GREEN+3, EVEN_GREEN, 0, 0);
}

void GUI_UpdatePumpControlPanel()
{
  char display[25];
 
  if (ConfigWord & MEASURE_MODE_AUTO)
  {
    TFT_FillRect_(LLVALUE, EVEN_GREEN);
    TFT_WriteStringInRectCenter("непрерывные", BROWN, EVEN_GREEN, LLVALUE, 0, 0, &Tahoma19B);
    
    TFT_FillRect_(LRVALUE, EVEN_GREEN);
    if (CHECK_PUMP)
    {
      TFT_WriteStringInRectCenter("ВКЛ", DEEPBLUE, EVEN_GREEN, LRVALUE, 0, 0, &Tahoma19B);
      GUI_DrawImageInRectCenterSwapColor(PAUSE_30x30, LMCPARAM, TEMPLATE_COLOR, ODD_GREEN+3);
    }
    else
    {
      TFT_WriteStringInRectCenter("ВЫКЛ", RED, EVEN_GREEN, LRVALUE, 0, 0, &Tahoma19B);
      GUI_DrawImageInRectCenterSwapColor(PLAY_30x30, LMCPARAM, TEMPLATE_COLOR, ODD_GREEN+3);
    }
  }
  else
  {
    TFT_FillRect_(LLVALUE, EVEN_GREEN);
    TFT_WriteStringInRectCenter("ручные", BROWN, EVEN_GREEN, LLVALUE, 0, 0, &Tahoma19B);
    
    TFT_FillRect_(LRVALUE, EVEN_GREEN);
    if (CHECK_PUMP)
      sprintf(display, "%d/%d", PumpTime - DownCount, PumpTime);
    else
      sprintf(display, "%d сек", PumpTime);
    TFT_WriteStringInRectCenter(display, DEEPBLUE, EVEN_GREEN, LRVALUE, 0, 0, &Tahoma19B);
    
    GUI_DrawImageInRectCenterSwapColor(PROBE_30x30, LMCPARAM, TEMPLATE_COLOR, ODD_GREEN+3);
  }
}

void GUI_TouchPumpControlPanel(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, LLPARAM))
  {
    set_sound(S_SOUND_20);

    OS_STOPTIMER_IF_NOT(&PumpTimer);
    PUMP_OFF;

    if (ConfigWord & MEASURE_MODE_AUTO)
      ConfigWord &= ~MEASURE_MODE_AUTO;
    else
      ConfigWord |= MEASURE_MODE_AUTO;
    InvConfigWord = ~ConfigWord;

    OS_Use(&SemaRAM);
    SAVE_CONFIG(ConfigWord);
    SAVE_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
    
    GUI_UpdatePumpControlPanel();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LRPARAM))
    if (!(ConfigWord & MEASURE_MODE_AUTO))
    {
      set_sound(S_SOUND_20);
      
      OS_STOPTIMER_IF_NOT(&PumpTimer);
      PUMP_OFF;
      
      int temp = PumpTime;
      if (GUI_KeyboardInt(&temp, "Настройки", "Прокачка, сек", true, 1, 3000)) 
      {
        PumpTime = temp;
        OS_Use(&SemaRAM);
        SAVE_CONFIG(PumpTime);
        OS_Unuse(&SemaRAM);
      }

      draw();
      return;
    }
  
  if (TFT_CoordsInRect(X, Y, LMCPARAM))
  {
    set_sound(S_SOUND_20);
    if (ConfigWord & MEASURE_MODE_AUTO)
    {
      if (CHECK_PUMP)
        PUMP_OFF;
      else
      {
        PUMP_ON;
        StatTimer = 0;
      }
    }
    else
    {
      if (CHECK_PUMP)
      {
        OS_SetTimerPeriod(&PumpTimer, 1);
        OS_RetriggerTimer(&PumpTimer);
        DownCount = 0;
      }
      else
      {
        set_sound(S_SOUND_300);
        PUMP_ON;
        OS_SetTimerPeriod(&PumpTimer, PumpTime*1000);
        OS_RetriggerTimer(&PumpTimer);
        DownCount = PumpTime;
      }
    }

    GUI_UpdatePumpControlPanel();
    return;
  }
}

void GUI_DrawChannelSettingsRootScreen()
{
  char display[25];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Параметры на главном экране", DARKGREEN, BACKGROUND_COLOR, UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  if (HumidityCalculationPossible(CurrentDisplay))
  {
    TFT_WriteStringInRectCenter("Параметры пересчёта влажности", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
  
  if (PressureCalculationPossible(CurrentDisplay))
  {
    TFT_WriteStringInRectCenter("Параметры датчика давления", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
  
  GUI_UpdateChannelSettingsRootScreen();
}

void GUI_UpdateChannelSettingsRootScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchChannelSettingsRootScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }

  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawChannelSettingsDisplayScreen, GUI_UpdateChannelSettingsDisplayScreen, GUI_TouchChannelSettingsDisplayScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    if (HumidityCalculationPossible(CurrentDisplay))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawChannelSettingsCalculateHumidityScreen, GUI_UpdateChannelSettingsCalculateHumidityScreen, GUI_TouchChannelSettingsCalculateHumidityScreen);
      return;
    }
  
    if (PressureCalculationPossible(CurrentDisplay))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawChannelSettingsCalculatePressureScreen, GUI_UpdateChannelSettingsCalculatePressureScreen, GUI_TouchChannelSettingsCalculatePressureScreen);
      return;
    }
  }
}

void GUI_DrawChannelSettingsDisplayScreen()
{
  char display[25];
  sprintf(display, "Канал %d: отображение", CurrentDisplay+1);
  GUI_UpdateHeaderImage(OK_30x30, EVEN_YELLOW);
  GUI_UpdateHeaderText("Настройки", display);
  
  TFT_DrawRect(BODY);
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    GetParamNameAndUnits(CurrentDisplay, j, display);
    
    TFT_WriteStringInRectLeft(display, BLACK, BACKGROUND_COLOR, *LEFTHALFS_SMALL[j], 3, 0, &Tahoma19B);
    if (j != 7) TFT_UnderlineRect_Offset(*LINES_SMALL[j], BLACK, 1, 40, 0);
  }
  
  GUI_UpdateChannelSettingsDisplayScreen();
}

void GUI_UpdateChannelSettingsDisplayScreen()
{
  GUI_UpdateHeader();

  Int8U chosen_count = GetDisplayChannelChosenParamsCount(CurrentDisplay);
  GUI_DrawImageInRectCenterSwapColor(OK_30x30, CHANNEL0, TEMPLATE_COLOR, EVEN_YELLOW);
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    TFT_FillRect_(*RIGHTS_SMALL[j], BACKGROUND_COLOR);
    if (DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_ON_MAINSCREEN)
      TFT_WriteStringInRectCenter("Да", DARKGREEN, BACKGROUND_COLOR, *RIGHTS_SMALL[j], 0, 0, &Tahoma19B);
    else
      TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, *RIGHTS_SMALL[j], 0, 0, &Tahoma19B);
    if (j != 7) TFT_UnderlineRect_Offset(*LINES_SMALL[j], BLACK, 1, 40, 0);
  }
}

void GUI_TouchChannelSettingsDisplayScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  Int8U chosen_count = GetDisplayChannelChosenParamsCount(CurrentDisplay);
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
  
  for (int j = 0; j < params_count; j++)
  {
    if (TFT_CoordsInRect(X, Y, *LINES_SMALL[j]))
    {
      if (DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_ON_MAINSCREEN)
      {
        set_sound(S_SOUND_20);
        DisplayConfig[CurrentDisplay].ParamConfig[j] &= ~PARAM_ON_MAINSCREEN;
      }
      else if (chosen_count < 2)
      {
        set_sound(S_SOUND_20);
        DisplayConfig[CurrentDisplay].ParamConfig[j] |= PARAM_ON_MAINSCREEN;
      }
      GUI_UpdateChannelSettingsDisplayScreen();
      return;
    }
  }
}

void GUI_DrawChannelSettingsCalculateHumidityScreen()
{
  char display[25];
  sprintf(display, "Канал %d: пересчёт", CurrentDisplay+1);
  GUI_UpdateHeaderImage(OK_30x30, EVEN_YELLOW);
  GUI_UpdateHeaderText("Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeftInTwoLines("Давление в", "точке измерения", BLACK, BACKGROUND_COLOR, UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeftInTwoLines("Давление в", "точке пересчёта", BLACK, BACKGROUND_COLOR, LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  GUI_UpdateChannelSettingsCalculateHumidityScreen();
}

void GUI_UpdateChannelSettingsCalculateHumidityScreen()
{
  char display[25];
  Int8U index = GetDewPointParamIndex(CurrentDisplay);

  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);  
  TFT_FillRect_(UPPER, BACKGROUND_COLOR);
  if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE1_SOURCE)
  {
    TFT_WriteStringInRectCenter("Датчик", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
    TFT_WriteStringInRectLeft("Преобразователь", BLACK, BACKGROUND_COLOR, UPPER, 3, 0, &Tahoma19B);
    GetParamStringByMeasureAttribute((Int8U)DisplayConfig[CurrentDisplay].Constant[index*2], display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Константа", PressureTransducerExists() ? DARKGREEN : BROWN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
    TFT_WriteStringInRectLeft("Значение, атм.", BLACK, BACKGROUND_COLOR, UPPER, 3, 0, &Tahoma19B);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[index*2].DecPoint, DisplayConfig[CurrentDisplay].Constant[index*2]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  TFT_FillRect_(LOWERMOST, BACKGROUND_COLOR);
  if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE2_SOURCE)
  {
    TFT_WriteStringInRectCenter("Датчик", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
    TFT_WriteStringInRectLeft("Преобразователь", BLACK, BACKGROUND_COLOR, LOWERMOST, 3, 0, &Tahoma19B);
    GetParamStringByMeasureAttribute((Int8U)DisplayConfig[CurrentDisplay].Constant[index*2+1], display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Константа", PressureTransducerExists() ? DARKGREEN : BROWN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
    TFT_WriteStringInRectLeft("Значение, атм.", BLACK, BACKGROUND_COLOR, LOWERMOST, 3, 0, &Tahoma19B);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[index*2+1].DecPoint, DisplayConfig[CurrentDisplay].Constant[index*2+1]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchChannelSettingsCalculateHumidityScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U measure_attribute;
  Int8U index = GetDewPointParamIndex(CurrentDisplay);
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPERMOST) && PressureTransducerExists())
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE1_SOURCE)
    {
      DisplayConfig[CurrentDisplay].Constant[index*2] = 1;
      SetPressure1Source(CurrentDisplay, false);
    }
    else
    {
      measure_attribute = 0;
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index*2] = measure_attribute;
      SetPressure1Source(CurrentDisplay, true);
    }
    GUI_UpdateChannelSettingsCalculateHumidityScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE1_SOURCE)
    {
      measure_attribute = (Int8U)DisplayConfig[CurrentDisplay].Constant[index*2];
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index*2] = measure_attribute;
      GUI_UpdateChannelSettingsCalculateHumidityScreen();
      return;
    }
    else
    {
      Int8U decimal = DisplayConfig[CurrentDisplay].ConstConfig[index*2].DecPoint;
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[index*2], "Настройки", "Значение, атм", true, 0, 1000, decimal);
      GUI_DrawChannelSettingsCalculateHumidityScreen();
      return;
    }
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER) && PressureTransducerExists())
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE2_SOURCE)
    {
      DisplayConfig[CurrentDisplay].Constant[index*2+1] = 1;
      SetPressure2Source(CurrentDisplay, false);
    }
    else
    {
      measure_attribute = 0;
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index*2+1] = measure_attribute;
      SetPressure2Source(CurrentDisplay, true);
    }
    GUI_UpdateChannelSettingsCalculateHumidityScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE2_SOURCE)
    {
      measure_attribute = (Int8U)DisplayConfig[CurrentDisplay].Constant[index*2+1];
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index*2+1] = measure_attribute;
      GUI_UpdateChannelSettingsCalculateHumidityScreen();
      return;
    }
    else
    {
      Int8U decimal = DisplayConfig[CurrentDisplay].ConstConfig[index*2+1].DecPoint;
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[index*2+1], "Настройки", "Значение, атм", true, 0, 1000, decimal);
      GUI_DrawChannelSettingsCalculateHumidityScreen();
      return;
    }
  }
}

void GUI_DrawChannelSettingsCalculatePressureScreen()
{
  char display[25];
  sprintf(display, "Канал %d: давление", CurrentDisplay+1);
  GUI_UpdateHeaderImage(OK_30x30, EVEN_YELLOW);
  GUI_UpdateHeaderText("Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Тип давления", BLACK, BACKGROUND_COLOR, UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Выходной диапазон", BLACK, BACKGROUND_COLOR, UPPER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Нижняя граница, кПа", BLACK, BACKGROUND_COLOR, LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Верхняя граница, кПа", BLACK, BACKGROUND_COLOR, LOWERMOST, 3, 0, &Tahoma19B);
  
  GUI_UpdateChannelSettingsCalculatePressureScreen();
}

void GUI_UpdateChannelSettingsCalculatePressureScreen()
{
  char display[25];
  Int8U index;

  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);  
  index = (Int8U)DisplayConfig[CurrentDisplay].Constant[0];
  if (index > 1) index = 0;
  sprintf(display, "%s", PRESSURE_TYPES[index]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);  
  index = (Int8U)DisplayConfig[CurrentDisplay].Constant[1];
  if (index > 2) index = 0;
  sprintf(display, "%s", PRESSURE_INPUTS[index]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);  
  sprintf(display, "%.0f", DisplayConfig[CurrentDisplay].Constant[2]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);  
  sprintf(display, "%.0f", DisplayConfig[CurrentDisplay].Constant[3]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
}

void GUI_TouchChannelSettingsCalculatePressureScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U index;
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    index = (Int8U)DisplayConfig[CurrentDisplay].Constant[0];
    index++;
    if (index > 1) index = 0;
    DisplayConfig[CurrentDisplay].Constant[0] = index;
    GUI_UpdateChannelSettingsCalculatePressureScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    index = (Int8U)DisplayConfig[CurrentDisplay].Constant[1];
    index++;
    if (index > 2) index = 0;
    DisplayConfig[CurrentDisplay].Constant[1] = index;
    GUI_UpdateChannelSettingsCalculatePressureScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[2], "Настройки", "Нижняя граница, кПа", false, -999999, 999999, 0);
    GUI_DrawChannelSettingsCalculatePressureScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[3], "Настройки", "Верхняя граница, кПа", false, -999999, 999999, 0);
    GUI_DrawChannelSettingsCalculatePressureScreen();
    return;
  }
}

void GUI_DrawParamRootScreen()
{
  char display[25];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Измерение", display);
  
  int first, second;
  if (BackToAllChannels) // пользователь зашёл из общего экрана
  {
    for (int i = 0; i < GetDisplayChannelsCount(); i++)
    {
      if (CurrentDisplay == i)
      {
        GetChosenParams(i, &first, &second);
        if ((first != -1) && (second != -1))
        {
          if (CurrentParam != first)
            TFT_GrayoutRect_(*Params_sequence[i*2],   BACKGROUND_COLOR);
          if (CurrentParam != second)
            TFT_GrayoutRect_(*Params_sequence[i*2+1],   BACKGROUND_COLOR);
        }
      }
      
      if (CurrentDisplay != i)
      {
        TFT_GrayoutRect_(*Params_sequence[i*2], BACKGROUND_COLOR);
        TFT_GrayoutRect_(*Params_sequence[i*2+1], BACKGROUND_COLOR);
      }
    }
  }
  if (!BackToAllChannels) // пользователь зашёл из экрана канала
  {
    int param_rect = GetParamRect(CurrentDisplay, CurrentParam);
    int start_rect, end_rect;
    if (param_rect < 8)
    {
      start_rect = 0;
      end_rect = 8;
    }
    else
    {
      start_rect = 8;
      end_rect = 12;
    }
    for (int i = start_rect; i < end_rect; i++)
    {
      if (CurrentParam != GetRectParam(CurrentDisplay, i))
      {
        TFT_GrayoutRect_(*PARAMS_SEQUENCE[i], BACKGROUND_COLOR);
      }
    }
  }
  
  TFT_FillRect_(MENU0, EVEN_YELLOW);
  TFT_FillRect_(MENU1, EVEN_YELLOW);
  TFT_FillRect_(MENU2, EVEN_YELLOW);
  TFT_FillRect_(MENU3, EVEN_YELLOW);

  GUI_DrawImageInRectCenterSwapColor(SETTINGS_PARAM_30x30, MENU0, TEMPLATE_COLOR, EVEN_YELLOW);
  GUI_DrawImageInRectCenterSwapColor(INFO_PARAM_30x30,     MENU1, TEMPLATE_COLOR, EVEN_YELLOW);

  GUI_UpdateParamRootScreen();
}

void GUI_UpdateParamRootScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  int first, second;
  Int16U color, back_color;
  
  back_color = (CurrentDisplay % 2) == 0 ? ODD_GREEN : EVEN_GREEN;
  if (BackToAllChannels) // пользователь зашёл из общего экрана
  {
    GetChosenParams(CurrentDisplay, &first, &second);
    if ((first != -1) && (second != -1))
    {
      if (CurrentParam == first)
      {
        GetMeasureString(CurrentDisplay, first, display, &color);
        TFT_FillRect_(*LValues[CurrentDisplay], back_color);
        TFT_WriteStringInRectCenter(display, color, back_color, *LValues[CurrentDisplay], 0, 0, &Tahoma19B);
      }
      if (CurrentParam == second)
      {
        GetMeasureString(CurrentDisplay, second, display, &color);
        TFT_FillRect_(*RValues[CurrentDisplay], back_color);
        TFT_WriteStringInRectCenter(display, color, back_color, *RValues[CurrentDisplay], 0, 0, &Tahoma19B);
      }
    }
    else if (first != -1)
    {
      GetMeasureString(CurrentDisplay, first, display, &color);
      TFT_FillRect_(*Values[CurrentDisplay], back_color);
      TFT_WriteStringInRectCenter(display, color, back_color, *Values[CurrentDisplay], 0, 0, &Tahoma19B);
    }
  }
  if (!BackToAllChannels) // пользователь зашёл из экрана канала
  {
    GetMeasureString(CurrentDisplay, CurrentParam, display, &color);
    int k = DisplayConfig[CurrentDisplay].ParamConfig[CurrentParam] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *VALUES_SEQUENCE[k];
    TFT_FillRect_(placement, back_color);
    TFT_WriteStringInRectCenter(display, color, back_color, placement, 0, 0, &Tahoma19B);
  }
}

void GUI_TouchParamRootScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, MENU0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawParamThreshAndConstScreen, GUI_UpdateParamThreshAndConstScreen, GUI_TouchParamThreshAndConstScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU1))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawParamStateScreen, GUI_UpdateParamStateScreen, GUI_TouchParamStateScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, BODY))
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
}

void GUI_DrawParamThreshAndConstScreen()
{
  char display[25];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Измерение", display);

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  GetParamNameAndUnits(CurrentDisplay, CurrentParam, display);
  TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 1, PARAMETER_19x19, display);

  Int8U decimal = MeasureAttribute[DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam]].DecPoint;
  
  TFT_WriteStringInRectCenter("Порог 1", BLACK, EVEN_GREEN, UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  sprintf(display, "%s", THRESHOLD_TYPES[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2].Up]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, LEFT_UPPER_TOP, 0, 0, &Tahoma19B);
  sprintf(display, "%.*f", decimal, DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, CENTER_UPPER_TOP, 0, 0, &Tahoma19B);
  sprintf(display, "%s", THRESHOLD_WEIGHTS[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2].Weight]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, RIGHT_UPPER_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER_TOP, BLACK, 1, 40, 0);

  TFT_WriteStringInRectCenter("Порог 2", BLACK, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma19B);
  sprintf(display, "%s", THRESHOLD_TYPES[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+1].Up]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma19B);
  sprintf(display, "%.*f", decimal, DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+1]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma19B);
  sprintf(display, "%s", THRESHOLD_WEIGHTS[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+1].Weight]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER_TOP, BLACK, 1, 40, 0);
  
  Int8U const_decimal;
  Int16U color;
  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].ShowStat != DO_NOT_SHOW)
  {
    const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].DecPoint;
    TFT_WriteStringInRectCenter("Константа 1", BLACK, EVEN_GREEN, LEFTHALF_LOWER_BOTTOM, 0, 0, &Tahoma19B);
    DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].Name[8] = 0;
    sprintf(display, "%s", DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].Name);
    TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
    sprintf(display, "%.*f", const_decimal, DisplayConfig[CurrentDisplay].Constant[CurrentParam*2]);
    color = (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].ShowStat == SHOW_AN_EDIT) ? DARKGREEN : BROWN;
    TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, LEFTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma19B);
  }

  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].ShowStat != DO_NOT_SHOW)
  {
    const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].DecPoint;
    TFT_WriteStringInRectCenter("Константа 2", BLACK, EVEN_GREEN, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma19B);
    DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].Name[8] = 0;
    sprintf(display, "%s", DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].Name);
    TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
    sprintf(display, "%.*f", const_decimal, DisplayConfig[CurrentDisplay].Constant[CurrentParam*2+1]);
    color = (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].ShowStat == SHOW_AN_EDIT) ? DARKGREEN : BROWN;
    TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma19B);
  }
  
  GUI_UpdateParamThreshAndConstScreen();
}

void GUI_UpdateParamThreshAndConstScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchParamThreshAndConstScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPERMOST_BOTTOM) || TFT_CoordsInRect(X, Y, UPPER_TOP))
  {
    set_sound(S_SOUND_20);
    CurrentThreshold = 0;
    GUI_SetGUI(GUI_DrawThresholdConfigScreen, GUI_UpdateThresholdConfigScreen, GUI_TouchThresholdConfigScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER_BOTTOM) || TFT_CoordsInRect(X, Y, LOWER_TOP))
  {
    set_sound(S_SOUND_20);
    CurrentThreshold = 1;
    GUI_SetGUI(GUI_DrawThresholdConfigScreen, GUI_UpdateThresholdConfigScreen, GUI_TouchThresholdConfigScreen);
    return;
  }
  
  Int8U const_decimal;
  char display[25], param[25];
  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].ShowStat == SHOW_AN_EDIT)
  {
    if (TFT_CoordsInRect(X, Y, LEFTHALF_LOWER_BOTTOM) || TFT_CoordsInRect(X, Y, LEFTHALF_LOWERMOST_TOP) || TFT_CoordsInRect(X, Y, LEFTHALF_LOWERMOST_BOTTOM))
    {
      set_sound(S_SOUND_20);
      GetParamString(CurrentDisplay, CurrentParam, param);
      sprintf(display, "%s: константа 1", param);
      const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].DecPoint;
      if (GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[CurrentParam*2], "Настройки", display, false, 0, 0, const_decimal))
      {
        OS_Use(&SemaRAM);
        SAVE_CONFIG(DisplayConfig[CurrentDisplay].Constant[CurrentParam*2]);
        OS_Unuse(&SemaRAM);
      }
      GUI_DrawParamThreshAndConstScreen();
    }
  }
  
  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].ShowStat == SHOW_AN_EDIT)
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER_BOTTOM) || TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST_TOP) || TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST_BOTTOM))
    {
      set_sound(S_SOUND_20);
      GetParamString(CurrentDisplay, CurrentParam, param);
      sprintf(display, "%s: константа 2", param);
      const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].DecPoint;
      if (GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[CurrentParam*2+1], "Настройки", display, false, 0, 0, const_decimal))
      {
        OS_Use(&SemaRAM);
        SAVE_CONFIG(DisplayConfig[CurrentDisplay].Constant[CurrentParam*2+1]);
        OS_Unuse(&SemaRAM);
      }
      GUI_DrawParamThreshAndConstScreen();
    }
  }
}

void GUI_DrawParamStateScreen()
{
  char display[25];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Измерение", display);

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  GetParamNameAndUnits(CurrentDisplay, CurrentParam, display);
  TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 1, PARAMETER_19x19, display);

  GUI_UpdateParamStateScreen();
}

void GUI_UpdateParamStateScreen()
{
  GUI_UpdateHeader();
  
  Int8U param_index = DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam];
  
  int row = 1;
//  char display[25];
  if (ErrorArray[param_index] == NO_ERR)
  {
    TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    TFT_WriteStringInRectCenter("Ошибок не обнаружено", BROWN, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma19B);
    row++;
  }

  if (ErrorArray[param_index] & CONNECT_ERR)
  {
    TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    TFT_WriteStringInRectCenter("Ошибка связи с преобразователем", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma19B);
    row++;
  }
    
  if (ErrorArray[param_index] & LOWLIMIT_ERR)
  {
    TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    TFT_WriteStringInRectCenter("Нарушение нижней границы", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma19B);
    row++;
  }
    
  if (ErrorArray[param_index] & UPLIMIT_ERR)
  {
    TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    TFT_WriteStringInRectCenter("Нарушение верхней границы", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma19B);
    row++;
  }
   
  if (ErrorArray[param_index] & INTERNAL_ERR)
  {
    TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    TFT_WriteStringInRectCenter("Внутренняя ошибка преобразователя", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma19B);
    row++;
  }
    
  if (ErrorArray[param_index] & (COMPLEX_ERR | ASSIGNED_ERR))
  {
    TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    TFT_WriteStringInRectCenter("Ошибка пересчёта", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma19B);
    row++;
  }
  
  TFT_UnderlineRect_Offset(*LINES_SMALL[row-1], BLACK, 1, 40, 0);
  
  for (int i = row; i < 7; i++)
    TFT_FillRect_(*LINES_SMALL[i], EVEN_GREEN);
}

void GUI_TouchParamStateScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
}

void GUI_DrawThresholdConfigScreen()
{
  char display[25], param[25];
  GetParamString(CurrentDisplay, CurrentParam, param);
  sprintf(display, "%s: порог %d", param, CurrentThreshold+1);
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Тип", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
    
  TFT_WriteStringInRectLeft("Значение", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  Int8U decimal = MeasureAttribute[DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam]].DecPoint;
  sprintf(display, "%.*f", decimal, DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Важность", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);

  GUI_UpdateThresholdConfigScreen();
}

void GUI_UpdateThresholdConfigScreen()
{
  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", THRESHOLD_TYPES[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Up]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  sprintf(display, "%s", THRESHOLD_WEIGHTS[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Weight]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchThresholdConfigScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold]);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawParamThreshAndConstScreen, GUI_UpdateParamThreshAndConstScreen, GUI_TouchParamThreshAndConstScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold]);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold]);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawParamThreshAndConstScreen, GUI_UpdateParamThreshAndConstScreen, GUI_TouchParamThreshAndConstScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Up++;
    GUI_UpdateThresholdConfigScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    char display[25], param[25];
    Int8U decimal = MeasureAttribute[DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam]].DecPoint;
    float min, max;
    GetParamMinMax(CurrentDisplay, CurrentParam, &min, &max);
    GetParamString(CurrentDisplay, CurrentParam, param);
    sprintf(display, "%s: порог %d", param, CurrentThreshold+1);
    GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold], "Настройки", display, false, min, max, decimal);
    GUI_DrawThresholdConfigScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Weight++;
    GUI_UpdateThresholdConfigScreen();
    return;
  }
}

void GUI_DrawControlsScreen()
{
  GUI_DrawHeader(SWITCH_30x30, EVEN_YELLOW, "Управление", "Все каналы");
  
  TFT_DrawRect(BODY);
  
  Int8U count = GetOutChannelsCount();
  if (count > 6) count = 6;
  
  char display[10];
  for (int i = 0; i < count; i++)
  {
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      sprintf(display, "Реле %d", i+1);
      TFT_DrawRoundedRect_OffsetWithImageAndCaption(*CONTROLS[i], ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 1, RELAY_19x19, display);
    }
    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      sprintf(display, "Ток %d", i+1);
      TFT_DrawRoundedRect_OffsetWithImageAndCaption(*CONTROLS[i], ODD_BLUE, EVEN_BLUE, BACKGROUND_COLOR, 0, 1, CURRENT_19x19, display);
    }
  }
  
  if (ControlScreen == csDetail)
    GUI_DrawDetailControls();
  if (ControlScreen == csBrief)
    GUI_DrawBriefControls();

  GUI_UpdateControlsScreen();
}

void GUI_UpdateControlsScreen()
{
  GUI_UpdateHeader();
  
  if (ControlScreen == csDetail)
    GUI_UpdateDetailControls();
  if (ControlScreen == csBrief)
    GUI_UpdateBriefControls();
}

void GUI_TouchControlsScreen()
{
  Int16U X, Y;
  Int8U button =  TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    if (ControlScreen == csDetail)
    {
      ControlScreen = csBrief;
      GUI_DrawBriefControls();
    }
    else if (ControlScreen == csBrief)
    {
      ControlScreen = csDetail;
      GUI_DrawDetailControls();
    }   
    GUI_UpdateControlsScreen();
    return;
  }
  
  if ((button == SWITCH_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  Int8U count = GetOutChannelsCount();
  if (count > 6) count = 6;
  
  for (int i = 0; i < count; i++)
  {
    if (TFT_CoordsInRect(X, Y, *CONTROLS[i]))
    {
      set_sound(S_SOUND_20);
      CurrentControl = i;
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
}

void GUI_DrawDetailControls()
{
  Int8U count = GetOutChannelsCount();
  if (count > 6) count = 6;

  char param[20], control_type[20], info[20];
  for (int i = 0; i < count; i++)
  {
    GetControlChannelInputParamString(OutConfig[i].Input, param);
    
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      sprintf(control_type, "%s", RELAY_CONTROL_TYPES[OutConfig[i].CntrAttr]);      
      if (OutConfig[i].CntrAttr == OFF_CONTROL)
      {
        TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_GREEN);
        TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, *CONTROLS_TOP[i], 0, 0, &Tahoma19B);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_GREEN, *CONTROLS_MIDDLE[i], 0, 0, &Tahoma19B);
        TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_GREEN);
      }
      if (OutConfig[i].CntrAttr == LOGIC_CONTROL)
      {
        TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_GREEN);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_GREEN, *CONTROLS_TOP[i], 0, 0, &Tahoma19B);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_GREEN, *CONTROLS_MIDDLE[i], 0, 0, &Tahoma19B);
        TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_GREEN);
      }
      if (OutConfig[i].CntrAttr == HEST_CONTROL)
      {
        TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_GREEN);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_GREEN, *CONTROLS_TOP[i], 0, 0, &Tahoma19B);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_GREEN, *CONTROLS_MIDDLE[i], 0, 0, &Tahoma19B);
        TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_GREEN);
        if (OutConfig[i].ProgUse)
          TFT_WriteStringInRectCenter("Программа", BLACK, EVEN_GREEN, *CONTROLS_BOTTOM[i], 0, 0, &Tahoma19B);
      }
    }
    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      sprintf(control_type, "%s", CURRENT_CONTROL_TYPES[OutConfig[i].CntrAttr]);
      if (OutConfig[i].CntrAttr == OFF_CONTROL)
      {
        TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_BLUE);
        TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, *CONTROLS_TOP[i], 0, 0, &Tahoma19B);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_BLUE, *CONTROLS_MIDDLE[i], 0, 0, &Tahoma19B);
        TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_BLUE);
        sprintf(info, "%s", CURRENT_TYPES[OutConfig[i].ChanelType]);
        TFT_WriteStringInRectCenter(info, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i], 0, 0, &Tahoma19B);
      }
      if (OutConfig[i].CntrAttr == LOGIC_CONTROL)
      {
        TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_BLUE);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_BLUE, *CONTROLS_TOP[i], 0, 0, &Tahoma19B);        
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_BLUE, *CONTROLS_MIDDLE[i], 0, 0, &Tahoma19B);
        TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_BLUE);
        sprintf(info, "%s", CURRENT_TYPES[OutConfig[i].ChanelType]);
        TFT_WriteStringInRectCenter(info, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i], 0, 0, &Tahoma19B);
      }
      if (OutConfig[i].CntrAttr == LINE_CONTROL)
      {
        TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_BLUE);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_BLUE, *CONTROLS_TOP[i], 0, 0, &Tahoma19B);        
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_BLUE, *CONTROLS_MIDDLE[i], 0, 0, &Tahoma19B);
        TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_BLUE);
        sprintf(info, "%s", CURRENT_TYPES[OutConfig[i].ChanelType]);
        TFT_WriteStringInRectCenter(info, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i], 0, 0, &Tahoma19B);
      }
    }
  }
}

void GUI_UpdateDetailControls()
{
  // NO OP REQUIRED
}

void GUI_DrawBriefControls()
{
  Int8U count = GetOutChannelsCount();
  if (count > 6) count = 6;

  for (int i = 0; i < count; i++)
  {
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      TFT_FillRect_Shift(*CONTROLS_IMAGE[i], EVEN_GREEN, 0, 0);
    }
    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      TFT_FillRect_(*CONTROLS_IMAGE[i], EVEN_BLUE);
    }
  }
}

void GUI_UpdateBriefControls()
{
  Int8U count = GetOutChannelsCount();
  if (count > 6) count = 6;

  char display[20];
  for (int i = 0; i < count; i++)
  {
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      if ((RelayOuts >> i) & 1)
      {
        GUI_DrawImageInRectCenterSwapColor(RELAY_UP_30x30, *CONTROLS_IMAGE[i], TEMPLATE_COLOR, EVEN_GREEN);
        sprintf(display, "Замкнуто");
      }
      else
      {
        GUI_DrawImageInRectCenterSwapColor(RELAY_DOWN_30x30, *CONTROLS_IMAGE[i], TEMPLATE_COLOR, EVEN_GREEN);
        sprintf(display, "Разомкнуто");
      }
      TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_GREEN);
      TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, *CONTROLS_BOTTOM[i], 0, 0, &Tahoma19B);
    }

    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      GUI_DrawImageInRectCenterSwapColor(CURRENT_ON_30x30, *CONTROLS_IMAGE[i], TEMPLATE_COLOR, EVEN_BLUE);
      TFT_FillRect_(*CONTROLS_BOTTOM[i], EVEN_BLUE);
      sprintf(display, "%.1f", OutCurrents[i]);
      TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i], 0, 0, &Tahoma19B);
    }
  }
}

void GUI_DrawControlScreen()
{
  char display[20];
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    sprintf(display, "Канал %d (реле)", CurrentControl+1);
    GUI_DrawHeader(SETTINGS_RELAY_30x30, EVEN_YELLOW, "Управление", display);
  }
  else
  {
    sprintf(display, "Канал %d (ток)", CurrentControl+1);
    GUI_DrawHeader(SETTINGS_CURRENT_30x30, EVEN_YELLOW, "Управление", display);
  }
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    sprintf(display, "Реле %d", CurrentControl+1);
    TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 1, RELAY_19x19, display);
  }
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    sprintf(display, "Ток %d", CurrentControl+1);
    TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_BLUE, EVEN_BLUE, BACKGROUND_COLOR, 0, 1, CURRENT_19x19, display);
  }
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_DrawControlRelayManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_DrawControlRelayLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_DrawControlRelayHesterScreen();
  }
  
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_DrawControlCurrentManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_DrawControlCurrentLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_DrawControlCurrentLineoutScreen();
  }
  
  GUI_UpdateControlScreen();
}

void GUI_UpdateControlScreen()
{
  GUI_UpdateHeader();
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_UpdateControlRelayManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_UpdateControlRelayLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_UpdateControlRelayHesterScreen();
  }
  
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_UpdateControlCurrentManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_UpdateControlCurrentLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_UpdateControlCurrentLineoutScreen();
  }
}

void GUI_TouchControlScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawRelayConfigurationCommonScreen, GUI_UpdateRelayConfigurationCommonScreen, GUI_TouchRelayConfigurationCommonScreen);
      return;
    }
    if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawCurrentConfigurationCommonScreen, GUI_UpdateCurrentConfigurationCommonScreen, GUI_TouchCurrentConfigurationCommonScreen);
      return;
    }
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_TouchControlRelayManualScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_TouchControlRelayLogicScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_TouchControlRelayHesterScreen(X, Y);
    return;
  }
  
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_TouchControlCurrentManualScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_TouchControlCurrentLogicScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_TouchControlCurrentLineoutScreen(X, Y);
    return;
  }
}

void GUI_DrawControlRelayManualScreen()
{
  TFT_WriteStringInRectCenter("Ручное управление", BROWN, EVEN_GREEN, UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_UPPER_TOP, 0, 0, &Tahoma19B);
  
  TFT_DrawRoundedRect_Offset(LCCONTROL_IMAGE, ODD_GREEN, ODD_GREEN, EVEN_GREEN, 0, 1);
  TFT_WriteStringInRectCenter("Нажмите для переключения", BLACK, EVEN_GREEN, LCCONTROL_BOTTOM, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlRelayManualScreen()
{
  TFT_FillRect_(RIGHTHALF_UPPER_TOP, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
  {
    TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_UPPER_TOP, 0, 0, &Tahoma19B);
    GUI_DrawImageInRectCenterSwapColor(RELAY_UP_30x30, LCCONTROL_IMAGE, TEMPLATE_COLOR, ODD_GREEN);
  }
  else
  {
    TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_UPPER_TOP, 0, 0, &Tahoma19B);
    GUI_DrawImageInRectCenterSwapColor(RELAY_DOWN_30x30, LCCONTROL_IMAGE, TEMPLATE_COLOR, ODD_GREEN);
  }
}

void GUI_TouchControlRelayManualScreen(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, LCCONTROL_IMAGE))
  {
    set_sound(S_SOUND_20);
    Int16U mask = (1 << CurrentControl);
    if (ManualControl & mask)
      ManualControl &= ~mask;
    else
      ManualControl |= mask;
    GUI_UpdateControlRelayManualScreen();
    return;
  }
}

void GUI_DrawControlRelayLogicScreen()
{
  char display[25];
  TFT_WriteStringInRectCenter("Логическое управление", BROWN, EVEN_GREEN, UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST_BOTTOM, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_UPPER_TOP, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Срабатывание на:", BLACK, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma19B);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma19B);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
    TFT_WriteStringInRectCenter("Ошибки", BROWN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].ControlType)
    TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlRelayLogicScreen()
{
  char display[25];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  TFT_FillRect_(RIGHT_UPPER_TOP, EVEN_GREEN);
  TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHT_UPPER_TOP, 0, 0, &Tahoma19B);
  
  TFT_FillRect_(RIGHTHALF_LOWERMOST_TOP, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
    TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
}

void GUI_TouchControlRelayLogicScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawControlRelayHesterScreen()
{
  if (OutConfig[CurrentControl].ProgUse)
    GUI_DrawControlRelayHesterProgrammScreen();
  else
    GUI_DrawControlRelayHesterNoProgrammScreen();
}

void GUI_UpdateControlRelayHesterScreen()
{
  if (OutConfig[CurrentControl].ProgUse)
    GUI_UpdateControlRelayHesterProgrammScreen();
  else
    GUI_UpdateControlRelayHesterNoProgrammScreen();
}

void GUI_TouchControlRelayHesterScreen(Int16U X, Int16U Y)
{
  if (OutConfig[CurrentControl].ProgUse)
    GUI_TouchControlRelayHesterProgrammScreen(X, Y);
  else
    GUI_TouchControlRelayHesterNoProgrammScreen(X, Y);
}

void GUI_DrawControlRelayHesterNoProgrammScreen()
{
  char display[25];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  TFT_WriteStringInRectCenter("Гистерезис (без программы)", BROWN, EVEN_GREEN, UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST_BOTTOM, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_UPPER_TOP, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("Рег. значение:", BLACK, EVEN_GREEN, LEFTHALF_UPPER_BOTTOM, 15, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("Гистерезис:", BLACK, EVEN_GREEN, LEFTHALF_LOWER_TOP, 15, 0, &Tahoma19B);
  sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].Hesteresis);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].ControlType)
    TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlRelayHesterNoProgrammScreen()
{
  char display[25];
  Int16U color;
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  TFT_FillRect_(RIGHT_UPPER_TOP, EVEN_GREEN);
  TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHT_UPPER_TOP, 0, 0, &Tahoma19B);
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    char param[25], value[25];
    GetControlChannelInputParamString((Int8U)OutConfig[CurrentControl].DefParam, param);
    GetControlChannelInputMeasureStringNoUnits((Int8U)OutConfig[CurrentControl].DefParam, value, &color);
    sprintf(display, "%s: %s", param, value);
    TFT_FillRect_(RIGHT_UPPER_BOTTOM, EVEN_GREEN);
    TFT_WriteStringInRectRight(display, DEEPBLUE, EVEN_GREEN, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  }
  else
  {
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  }
  
  TFT_FillRect_(RIGHTHALF_LOWERMOST_TOP, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
    TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
}

void GUI_TouchControlRelayHesterNoProgrammScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawControlRelayHesterProgrammScreen()
{
  char display[25];
  TFT_WriteStringInRectCenter("Гистерезис (по программе)", BROWN, EVEN_GREEN, UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST_BOTTOM, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_UPPER_TOP, 0, 0, &Tahoma19B);
  
  TFT_WriteStringInRectCenter("Параметр", BLACK, EVEN_GREEN, LEFT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Гистерезис", BLACK, EVEN_GREEN, CENTER_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Шаг", BLACK, EVEN_GREEN, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].Hesteresis);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma19B);
  //if (OutConfig[CurrentControl].ControlType)
  //  TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma19B);
  //else
  //  TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma19B);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_LOWER_BOTTOM, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlRelayHesterProgrammScreen()
{
  char display[25];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  TFT_FillRect_(RIGHT_UPPER_TOP, EVEN_GREEN);
  TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHT_UPPER_TOP, 0, 0, &Tahoma19B);
  
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  int index = ProgramStatus[CurrentControl].CurrentStep;
  if ((ProgramStatus[CurrentControl].ProgFinished) && (OutConfig[CurrentControl].EndProgCond == ENDP_LOADDEF))
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
  else
    sprintf(display, "%.*f", decimal, Program[index].Param);
  TFT_FillRect_(LEFT_LOWER_TOP, EVEN_GREEN);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma19B);
  
  sprintf(display, "%d/%d/%d", OutConfig[CurrentControl].StartStep+1, index+1, OutConfig[CurrentControl].StopStep+1);
  TFT_FillRect_(RIGHT_LOWER_TOP, EVEN_GREEN);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER_TOP, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHTHALF_LOWER_BOTTOM, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
    TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  
  if (ProgramStatus[CurrentControl].ProgStatus == PAUSE_PROGRAM)
  {
    TFT_DrawRoundedRect_Offset(LEFT_BOTTOM_BUTTON, ODD_GREEN, ODD_GREEN, EVEN_GREEN, 0, 1);
    GUI_DrawImageInRectCenterSwapColor(PAUSE_30x30, LEFT_BOTTOM_BUTTON, TEMPLATE_COLOR, ODD_GREEN);
  }
  else
  {
    TFT_DrawRoundedRect_Offset(LEFT_BOTTOM_BUTTON, EVEN_GREEN, EVEN_GREEN, EVEN_GREEN, 0, 1);
    GUI_DrawImageInRectCenterSwapColor(PAUSE_30x30, LEFT_BOTTOM_BUTTON, TEMPLATE_COLOR, EVEN_GREEN);
  }
  
  if ((ProgramStatus[CurrentControl].ProgStatus == START_PROGRAM) || (ProgramStatus[CurrentControl].ProgStatus == WORK_PROGRAM))
  {
    TFT_DrawRoundedRect_Offset(CENTER_BOTTOM_BUTTON, ODD_GREEN, ODD_GREEN, EVEN_GREEN, 0, 1);
    GUI_DrawImageInRectCenterSwapColor(PLAY_30x30, CENTER_BOTTOM_BUTTON, TEMPLATE_COLOR, ODD_GREEN);
  }
  else
  {
    TFT_DrawRoundedRect_Offset(CENTER_BOTTOM_BUTTON, EVEN_GREEN, EVEN_GREEN, EVEN_GREEN, 0, 1);
    GUI_DrawImageInRectCenterSwapColor(PLAY_30x30, CENTER_BOTTOM_BUTTON, TEMPLATE_COLOR, EVEN_GREEN);
  }
  
  if (ProgramStatus[CurrentControl].ProgStatus == STOP_PROGRAM)
  {
    TFT_DrawRoundedRect_Offset(RIGHT_BOTTOM_BUTTON, ODD_GREEN, ODD_GREEN, EVEN_GREEN, 0, 1);
    GUI_DrawImageInRectCenterSwapColor(STOP_30x30, RIGHT_BOTTOM_BUTTON, TEMPLATE_COLOR, ODD_GREEN);
  }
  else
  {
    TFT_DrawRoundedRect_Offset(RIGHT_BOTTOM_BUTTON, EVEN_GREEN, EVEN_GREEN, EVEN_GREEN, 0, 1);
    GUI_DrawImageInRectCenterSwapColor(STOP_30x30, RIGHT_BOTTOM_BUTTON, TEMPLATE_COLOR, EVEN_GREEN);
  }
}

void GUI_TouchControlRelayHesterProgrammScreen(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, LEFT_BOTTOM_BUTTON))
  {
    set_sound(S_SOUND_20);
    ProgramStatus[CurrentControl].ProgStatus = PAUSE_PROGRAM;
    GUI_UpdateControlRelayHesterProgrammScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, CENTER_BOTTOM_BUTTON))
  {
    set_sound(S_SOUND_20);
    ProgramStatus[CurrentControl].ProgStatus = START_PROGRAM;
    GUI_UpdateControlRelayHesterProgrammScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_BOTTOM_BUTTON))
  {
    set_sound(S_SOUND_20);
    ProgramStatus[CurrentControl].ProgStatus = STOP_PROGRAM;
    GUI_UpdateControlRelayHesterProgrammScreen();
    return;
  }
}

void GUI_DrawControlCurrentManualScreen()
{
  char display[25];
  TFT_WriteStringInRectLeft("Выходной диапазон:", BLACK, EVEN_BLUE, LEFT_UPPERMOST_BOTTOM, 15, 0, &Tahoma19B);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Ручное управление", BROWN, EVEN_BLUE, UPPER_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER_TOP, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Выход, мА:", BLACK, EVEN_BLUE, LEFTHALF_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  
  TFT_DrawRoundedRect_Offset(LCCONTROL_IMAGE, ODD_BLUE, ODD_BLUE, EVEN_BLUE, 0, 1);
  TFT_WriteStringInRectCenter("Нажмите для переключения", BLACK, EVEN_BLUE, LCCONTROL_BOTTOM, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlCurrentManualScreen()
{
  char display[10];
  TFT_FillRect_(RIGHTHALF_UPPER_BOTTOM, EVEN_BLUE);
  sprintf(display, "%.1f", OutCurrents[CurrentControl]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  
  if ((ManualControl >> CurrentControl) & 1)
    GUI_DrawImageInRectCenterSwapColor(CURRENT_ON_30x30, LCCONTROL_IMAGE, TEMPLATE_COLOR, ODD_BLUE);
  else
    GUI_DrawImageInRectCenterSwapColor(CURRENT_OFF_30x30, LCCONTROL_IMAGE, TEMPLATE_COLOR, ODD_BLUE);
}

void GUI_TouchControlCurrentManualScreen(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, LCCONTROL_IMAGE))
  {
    set_sound(S_SOUND_20);
    Int16U mask = (1 << CurrentControl);
    if (ManualControl & mask)
      ManualControl &= ~mask;
    else
      ManualControl |= mask;
    GUI_UpdateControlCurrentManualScreen();
    return;
  }
}

void GUI_DrawControlCurrentLogicScreen()
{
  char display[25];
  TFT_WriteStringInRectLeft("Выходной диапазон:", BLACK, EVEN_BLUE, LEFT_UPPERMOST_BOTTOM, 15, 0, &Tahoma19B);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Логическое управление", BROWN, EVEN_BLUE, UPPER_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER_TOP, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, LEFTHALF_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Срабатывание на:", BLACK, EVEN_BLUE, LOWER_TOP, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, LEFT_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, LEFT_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, CENTER_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, CENTER_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
    TFT_WriteStringInRectCenter("Ошибки", BROWN, EVEN_BLUE, RIGHT_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, RIGHT_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  if (OutConfig[CurrentControl].ControlType)
    TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_BLUE, LOWERMOST_TOP, 0, 0, &Tahoma19B);
  else
    TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_BLUE, LOWERMOST_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWERMOST_TOP, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Выход, мА:", BLACK, EVEN_BLUE, LEFTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlCurrentLogicScreen()
{
  char display[25];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  TFT_FillRect_(RIGHT_UPPER_BOTTOM, EVEN_BLUE);
  TFT_WriteStringInRectCenter(display, color, EVEN_BLUE, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  
  TFT_FillRect_Offset(RIGHTHALF_LOWERMOST_BOTTOM, EVEN_BLUE, 0, -1);
  sprintf(display, "%.1f", OutCurrents[CurrentControl]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWERMOST_BOTTOM, 0, 0, &Tahoma19B);
}

void GUI_TouchControlCurrentLogicScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawControlCurrentLineoutScreen()
{
  char display[25];
  TFT_WriteStringInRectLeft("Выходной диапазон:", BLACK, EVEN_BLUE, LEFT_UPPERMOST_BOTTOM, 15, 0, &Tahoma19B);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPERMOST_BOTTOM, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Линейный выход", BROWN, EVEN_BLUE, UPPER_TOP, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER_TOP, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, LEFTHALF_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  sprintf(display, "Значение для %s:", LOWER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectLeft(display, BLACK, EVEN_BLUE, LEFTHALF_LOWER_TOP, 15, 0, &Tahoma19B);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][0]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWER_TOP, 0, 0, &Tahoma19B);
  sprintf(display, "Значение для %s:", UPPER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectLeft(display, BLACK, EVEN_BLUE, LEFTHALF_LOWER_BOTTOM, 15, 0, &Tahoma19B);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][1]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Выход, мА:", BLACK, EVEN_BLUE, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
}

void GUI_UpdateControlCurrentLineoutScreen()
{
  char display[25];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  TFT_FillRect_(RIGHT_UPPER_BOTTOM, EVEN_BLUE);
  TFT_WriteStringInRectCenter(display, color, EVEN_BLUE, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  
  TFT_FillRect_Offset(RIGHTHALF_LOWERMOST_BOTTOM, EVEN_BLUE, 0, -1);
  sprintf(display, "%.1f", OutCurrents[CurrentControl]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWERMOST_TOP, 0, 0, &Tahoma19B);
}

void GUI_TouchControlCurrentLineoutScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawRelayConfigurationCommonScreen()
{
  char display[20];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Тип управления", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    TFT_WriteStringInRectLeftInTwoLines("Управляемый", "параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
    TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  }

  GUI_UpdateRelayConfigurationCommonScreen();
}

void GUI_UpdateRelayConfigurationCommonScreen()
{
  GUI_UpdateHeader();
  
  char display[20];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", RELAY_CONTROL_TYPES[OutConfig[CurrentControl].CntrAttr]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    TFT_FillRect_Offset(CHANNEL0, EVEN_YELLOW, 0, 0);
    GUI_DrawImageInRectCenterSwapColor(OK_30x30, CHANNEL0, TEMPLATE_COLOR, EVEN_YELLOW);
    TFT_FillRect_(UPPER, BACKGROUND_COLOR);
    TFT_FillRect_(LOWER, BACKGROUND_COLOR);
    TFT_FillRect_(LOWERMOST, BACKGROUND_COLOR);
  }
    
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    TFT_GrayoutRect_(CHANNEL0, BACKGROUND_COLOR);
    TFT_WriteStringInRectLeftInTwoLines("Управляемый", "параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
    TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
    GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
    TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  }
}

void GUI_TouchRelayConfigurationCommonScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, CHANNEL0))
    {
      set_sound(S_SOUND_20);

      OS_Use(&SemaRAM);
      SAVE_CONFIG(OutConfig[CurrentControl]);
      OS_Unuse(&SemaRAM);
    
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].CntrAttr++;
    if (OutConfig[CurrentControl].CntrAttr > HEST_CONTROL) OutConfig[CurrentControl].CntrAttr = OFF_CONTROL;
    GUI_UpdateRelayConfigurationCommonScreen();
    return;
  }
  
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
    {
      set_sound(S_SOUND_20);
      IncrementControlChannelInputParam(&OutConfig[CurrentControl].Input);
      GUI_UpdateRelayConfigurationCommonScreen();
      return;
    }
    
    if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
    {
      set_sound(S_SOUND_20);
      if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_SetGUI(GUI_DrawRelayConfigurationLogic1Screen, GUI_UpdateRelayConfigurationLogic1Screen, GUI_TouchRelayConfigurationLogic1Screen);
      if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
      return;
    }
  }
}

void GUI_DrawRelayConfigurationLogic1Screen()
{
  char display[25];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Порог 1", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Порог 2", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeftInTwoLines("Срабатывание", "на ошибку", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateRelayConfigurationLogic1Screen();
}

void GUI_UpdateRelayConfigurationLogic1Screen()
{
  GUI_UpdateHeader();
  
  char display[25];  
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
  {
    TFT_WriteStringInRectCenter("Да", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchRelayConfigurationLogic1Screen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR1;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR1;
    GUI_UpdateRelayConfigurationLogic1Screen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR2;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR2;
    GUI_UpdateRelayConfigurationLogic1Screen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_ERR;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_ERR;
    GUI_UpdateRelayConfigurationLogic1Screen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationCommonScreen, GUI_UpdateRelayConfigurationCommonScreen, GUI_TouchRelayConfigurationCommonScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationLogic2Screen, GUI_UpdateRelayConfigurationLogic2Screen, GUI_TouchRelayConfigurationLogic2Screen);
    return;
  }
}

void GUI_DrawRelayConfigurationLogic2Screen()
{
  char display[25];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeftInTwoLines("Инвертировать", "выход", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateRelayConfigurationLogic2Screen();
}

void GUI_UpdateRelayConfigurationLogic2Screen()
{
  GUI_UpdateHeader();
  
  char display[25];

  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ControlType ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
}

void GUI_TouchRelayConfigurationLogic2Screen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ControlType = !OutConfig[CurrentControl].ControlType;
    GUI_UpdateRelayConfigurationLogic2Screen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationLogic1Screen, GUI_UpdateRelayConfigurationLogic1Screen, GUI_TouchRelayConfigurationLogic1Screen);
    return;
  }
}

void GUI_DrawRelayConfigurationHesterScreen()
{
  char display[25];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeftInTwoLines("Регулируемое", "значение", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeftInTwoLines("Величина", "гистерезиса", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeftInTwoLines("Инвертировать", "выход", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateRelayConfigurationHesterScreen();
}

void GUI_UpdateRelayConfigurationHesterScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
    GetControlChannelInputParamString((Int8U)OutConfig[CurrentControl].DefParam, display);
    TFT_WriteStringInRectCenter(display, DEEPBLUE, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
    TFT_WriteStringInRectCenter(display, DEEPBLUE, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  }

  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].Hesteresis);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ControlType ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchRelayConfigurationHesterScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  float min, max;
  GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterParamScreen, GUI_UpdateRelayConfigurationHesterParamScreen, GUI_TouchRelayConfigurationHesterParamScreen);
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_KeyboardFloat(&OutConfig[CurrentControl].Hesteresis, "Настройки", "Гистерезис", false, 0, 0, decimal);
    GUI_DrawRelayConfigurationHesterScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ControlType = !OutConfig[CurrentControl].ControlType;
    GUI_UpdateRelayConfigurationHesterScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationCommonScreen, GUI_UpdateRelayConfigurationCommonScreen, GUI_TouchRelayConfigurationCommonScreen);
    return;
  }

  if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationProgrammCommonScreen, GUI_UpdateRelayConfigurationProgrammCommonScreen, GUI_TouchRelayConfigurationProgrammCommonScreen);
    return;
  }
}

void GUI_DrawRelayConfigurationHesterParamScreen()
{
  char display[25];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeftInTwoLines("Тип", "значения", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    TFT_WriteStringInRectLeft("Параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_WriteStringInRectLeft("Значение", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
  
  GUI_UpdateRelayConfigurationHesterParamScreen();
}

void GUI_UpdateRelayConfigurationHesterParamScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", DEFPARAM_TYPES[OutConfig[CurrentControl].DefParamIsIndex]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
    GetControlChannelInputParamString((Int8U)OutConfig[CurrentControl].DefParam, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
}

void GUI_TouchRelayConfigurationHesterParamScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
    return;
  }
  
  float min, max;
  GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].DefParamIsIndex = !OutConfig[CurrentControl].DefParamIsIndex;
    GUI_UpdateRelayConfigurationHesterParamScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    if (OutConfig[CurrentControl].DefParamIsIndex)
    {
      set_sound(S_SOUND_20);
      Int8U unit_type = GetControlChannelUnitType(OutConfig[CurrentControl].Input);
      Int8U index = (Int8U)OutConfig[CurrentControl].DefParam;
      IncrementControlChannelHesterParam(&index, unit_type);
      OutConfig[CurrentControl].DefParam = index;
      GUI_UpdateRelayConfigurationHesterParamScreen();
      return;
    }
    else
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardFloat(&OutConfig[CurrentControl].DefParam, "Настройки", "Значение", false, min, max, decimal);
      GUI_DrawRelayConfigurationHesterParamScreen();
      return;
    }
  }
}

void GUI_DrawRelayConfigurationProgrammCommonScreen()
{
  char display[25];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeftInTwoLines("Использовать", "программу", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateRelayConfigurationProgrammCommonScreen();
}

void GUI_UpdateRelayConfigurationProgrammCommonScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ProgUse ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].ProgUse)
  {
    TFT_GrayoutRect_(CHANNEL0, BACKGROUND_COLOR);
    
    TFT_WriteStringInRectCenter("Настроить шаги программы", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
    TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  }
  
  if (!OutConfig[CurrentControl].ProgUse)
  {
    TFT_FillRect_Offset(CHANNEL0, EVEN_YELLOW, 0, 0);
    GUI_DrawImageInRectCenterSwapColor(OK_30x30, CHANNEL0, TEMPLATE_COLOR, EVEN_YELLOW);
    
    TFT_FillRect_(UPPER, BACKGROUND_COLOR);
    TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);
  }
}

void GUI_TouchRelayConfigurationProgrammCommonScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (!OutConfig[CurrentControl].ProgUse)
  {
    if (TFT_CoordsInRect(X, Y, CHANNEL0))
    {
      set_sound(S_SOUND_20);

      OS_Use(&SemaRAM);
      SAVE_CONFIG(OutConfig[CurrentControl]);
      OS_Unuse(&SemaRAM);
    
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ProgUse = !OutConfig[CurrentControl].ProgUse;
    GUI_UpdateRelayConfigurationProgrammCommonScreen();
    return;
  }
    
  if (OutConfig[CurrentControl].ProgUse)
  {
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
    {
      set_sound(S_SOUND_20);
      CurrentProgrammStep = OutConfig[CurrentControl].StartStep;
      GUI_SetGUI(GUI_DrawProgrammStepScreen, GUI_UpdateProgrammStepScreen, GUI_TouchProgrammStepScreen);
      return;
    }
  }
  
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
    return;
  }

  if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationProgrammDetailScreen, GUI_UpdateRelayConfigurationProgrammDetailScreen, GUI_TouchRelayConfigurationProgrammDetailScreen);
    return;
  }
}

void GUI_DrawRelayConfigurationProgrammDetailScreen()
{
  char display[25];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Начальный шаг", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  sprintf(display, "%d", OutConfig[CurrentControl].StartStep+1);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Конечный шаг", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  sprintf(display, "%d", OutConfig[CurrentControl].StopStep+1);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeftInTwoLines("После окончания", "программы", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateRelayConfigurationProgrammDetailScreen();
}

void GUI_UpdateRelayConfigurationProgrammDetailScreen()
{
  GUI_UpdateHeader();
  
  char line1[20];
  char line2[20];
  TFT_FillRect_(RIGHTHALF_LOWER, BACKGROUND_COLOR);
  sprintf(line1, "%s", END_PROGRAMM_ACTIONS[OutConfig[CurrentControl].EndProgCond][0]);
  sprintf(line2, "%s", END_PROGRAMM_ACTIONS[OutConfig[CurrentControl].EndProgCond][1]);
  TFT_WriteStringInRectCenterInTwoLines(line1, line2, DARKGREEN, BACKGROUND_COLOR, RIGHTHALF_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchRelayConfigurationProgrammDetailScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    write_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  int step;
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    step = OutConfig[CurrentControl].StartStep + 1;
    if (GUI_KeyboardInt(&step, "Настройки", "Начальный шаг", true, 1, 512)) OutConfig[CurrentControl].StartStep = step - 1;
    GUI_DrawRelayConfigurationProgrammDetailScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    step = OutConfig[CurrentControl].StopStep + 1;
    if (GUI_KeyboardInt(&step, "Настройки", "Конечный шаг", true, 1, 512)) OutConfig[CurrentControl].StopStep = step - 1;
    GUI_DrawRelayConfigurationProgrammDetailScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].EndProgCond++;
    GUI_UpdateRelayConfigurationProgrammDetailScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationProgrammCommonScreen, GUI_UpdateRelayConfigurationProgrammCommonScreen, GUI_TouchRelayConfigurationProgrammCommonScreen);
    return;
  }
}

void GUI_DrawProgrammStepScreen()
{
  char display[25];
  sprintf(display, "Программа (шаг %d)", CurrentProgrammStep+1);
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Значение параметра", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Время выхода, с", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Время удержания, с", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  GUI_UpdateProgrammStepScreen();
}

void GUI_UpdateProgrammStepScreen()
{
  char display[25];
  sprintf(display, "Программа (шаг %d)", CurrentProgrammStep+1);
  GUI_UpdateHeaderText("Настройки", display);
  
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%.*f", decimal, Program[CurrentProgrammStep].Param);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%d", Program[CurrentProgrammStep].SetlTime);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  sprintf(display, "%d", Program[CurrentProgrammStep].HoldTime);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  if (CurrentProgrammStep > 0)   TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  else                           TFT_FillRect_(LEFT_THIRD_LOWERMOST, BACKGROUND_COLOR);
  if (CurrentProgrammStep < 511) TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  else                           TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);
}

void GUI_TouchProgrammStepScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationProgrammCommonScreen, GUI_UpdateRelayConfigurationProgrammCommonScreen, GUI_TouchRelayConfigurationProgrammCommonScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    read_spimem(CONFIG_ROM_ADR(Program), (pInt8U)Program, 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    float min, max;
    Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
    GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
    GUI_KeyboardFloat(&Program[CurrentProgrammStep].Param, "Настройки", "Значение параметра", false, min, max, decimal);
    GUI_DrawProgrammStepScreen();
    return;
  }
  
  int time;
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    time = Program[CurrentProgrammStep].SetlTime;
    if (GUI_KeyboardInt(&time, "Настройки", "Время выхода, с", true, 0, 65535)) Program[CurrentProgrammStep].SetlTime = time;
    GUI_DrawProgrammStepScreen();
    return;
  }

  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    time = Program[CurrentProgrammStep].HoldTime;
    if (GUI_KeyboardInt(&time, "Настройки", "Время удержания, с", true, 0, 65535)) Program[CurrentProgrammStep].HoldTime = time;
    GUI_DrawProgrammStepScreen();
    return;
  }

  if (CurrentProgrammStep > 0)
  {
    if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
    {
      set_sound(S_SOUND_20);
      CurrentProgrammStep--;
      GUI_UpdateProgrammStepScreen();
      return;
    }
  }
  
  if (CurrentProgrammStep < 511)
  {
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWERMOST))
    {
      set_sound(S_SOUND_20);
      CurrentProgrammStep++;
      GUI_UpdateProgrammStepScreen();
      return;
    }
  }
}

void GUI_DrawCurrentConfigurationCommonScreen()
{
  char display[20];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Выходной диапазон", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Тип управления", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  GUI_UpdateCurrentConfigurationCommonScreen();
}

void GUI_UpdateCurrentConfigurationCommonScreen()
{
  GUI_UpdateHeader();
  
  char display[20];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", CURRENT_CONTROL_TYPES[OutConfig[CurrentControl].CntrAttr]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    TFT_FillRect_Offset(CHANNEL0, EVEN_YELLOW, 0, 0);
    GUI_DrawImageInRectCenterSwapColor(OK_30x30, CHANNEL0, TEMPLATE_COLOR, EVEN_YELLOW);
    TFT_FillRect_(LOWER, BACKGROUND_COLOR);
    TFT_FillRect_(LOWERMOST, BACKGROUND_COLOR);
  }
    
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    TFT_GrayoutRect_(CHANNEL0, BACKGROUND_COLOR);
    TFT_WriteStringInRectLeftInTwoLines("Управляемый", "параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
    TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
    GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
    TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  }
}

void GUI_TouchCurrentConfigurationCommonScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, CHANNEL0))
    {
      set_sound(S_SOUND_20);

      OS_Use(&SemaRAM);
      SAVE_CONFIG(OutConfig[CurrentControl]);
      OS_Unuse(&SemaRAM);
    
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ChanelType++;
    if (OutConfig[CurrentControl].ChanelType > ANALOG_TYPE_420) OutConfig[CurrentControl].ChanelType = ANALOG_TYPE_05;
    GUI_UpdateCurrentConfigurationCommonScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].CntrAttr++;
    if (OutConfig[CurrentControl].CntrAttr > LINE_CONTROL) OutConfig[CurrentControl].CntrAttr = OFF_CONTROL;
    GUI_UpdateCurrentConfigurationCommonScreen();
    return;
  }
  
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
    {
      set_sound(S_SOUND_20);
      IncrementControlChannelInputParam(&OutConfig[CurrentControl].Input);
      GUI_UpdateCurrentConfigurationCommonScreen();
      return;
    }
    
    if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
    {
      set_sound(S_SOUND_20);
      if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_SetGUI(GUI_DrawCurrentConfigurationLogic1Screen, GUI_UpdateCurrentConfigurationLogic1Screen, GUI_TouchCurrentConfigurationLogic1Screen);
      if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_SetGUI(GUI_DrawCurrentConfigurationLineoutScreen, GUI_UpdateCurrentConfigurationLineoutScreen, GUI_TouchCurrentConfigurationLineoutScreen);
      return;
    }
  }
}

void GUI_DrawCurrentConfigurationLogic1Screen()
{
  char display[25];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Порог 1", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Порог 2", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeftInTwoLines("Срабатывание", "на ошибку", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);

  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateCurrentConfigurationLogic1Screen();
}

void GUI_UpdateCurrentConfigurationLogic1Screen()
{
  GUI_UpdateHeader();
  
  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
  {
    TFT_WriteStringInRectCenter("Да", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  }
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchCurrentConfigurationLogic1Screen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR1;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR1;
    GUI_UpdateCurrentConfigurationLogic1Screen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR2;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR2;
    GUI_UpdateCurrentConfigurationLogic1Screen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_ERR;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_ERR;
    GUI_UpdateCurrentConfigurationLogic1Screen();
    return;
  }
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawCurrentConfigurationCommonScreen, GUI_UpdateCurrentConfigurationCommonScreen, GUI_TouchCurrentConfigurationCommonScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawCurrentConfigurationLogic2Screen, GUI_UpdateCurrentConfigurationLogic2Screen, GUI_TouchCurrentConfigurationLogic2Screen);
    return;
  }
}

void GUI_DrawCurrentConfigurationLogic2Screen()
{
  char display[25];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeftInTwoLines("Инвертировать", "выход", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  GUI_UpdateCurrentConfigurationLogic2Screen();
}

void GUI_UpdateCurrentConfigurationLogic2Screen()
{
  GUI_UpdateHeader();
  
  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ControlType ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
}

void GUI_TouchCurrentConfigurationLogic2Screen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ControlType = !OutConfig[CurrentControl].ControlType;
    GUI_UpdateCurrentConfigurationLogic2Screen();
    return;
  }

  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawCurrentConfigurationLogic1Screen, GUI_UpdateCurrentConfigurationLogic1Screen, GUI_TouchCurrentConfigurationLogic1Screen);
    return;
  }
}

void GUI_DrawCurrentConfigurationLineoutScreen()
{
  char display[25];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  sprintf(display, "Значение для %s", LOWER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectLeft(display, BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
    
  sprintf(display, "Значение для %s", UPPER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectLeft(display, BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateCurrentConfigurationLineoutScreen();
}

void GUI_UpdateCurrentConfigurationLineoutScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
    
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][0]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][1]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
}

void GUI_TouchCurrentConfigurationLineoutScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    SAVE_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if ((button == BACK_BUTTON)/* || (TFT_CoordsInRect(X, Y, HEADER))*/)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }

  char display[25];
  float min, max;
  GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    sprintf(display, "Значение для %s", LOWER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
    GUI_KeyboardFloat(&AnalogConfig[CurrentControl][0], "Настройки", display, false, min, max, decimal);
    GUI_DrawCurrentConfigurationLineoutScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    sprintf(display, "Значение для %s", UPPER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
    GUI_KeyboardFloat(&AnalogConfig[CurrentControl][1], "Настройки", display, false, min, max, decimal);
    GUI_DrawCurrentConfigurationLineoutScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawCurrentConfigurationCommonScreen, GUI_UpdateCurrentConfigurationCommonScreen, GUI_TouchCurrentConfigurationCommonScreen);
    return;
  }
}

void GUI_DrawSettingsRootScreen()
{
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", "Меню настроек");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Информация о приборе", DARKGREEN, BACKGROUND_COLOR, UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Настройки связи", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Настройки статистики", DARKGREEN, BACKGROUND_COLOR, LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Другие настройки", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateSettingsRootScreen();
}

void GUI_UpdateSettingsRootScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsRootScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button != NOT_PRESSED)
  {
    set_sound(S_SOUND_20);
    if (button == SWITCH_BUTTON) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsInfoScreen, GUI_UpdateSettingsInfoScreen, GUI_TouchSettingsInfoScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsStatisticScreen, GUI_UpdateSettingsStatisticScreen, GUI_TouchSettingsStatisticScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
}

void GUI_DrawSettingsInfoScreen()
{
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", "Информация");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[35];
  sprintf(display, "%s", DeviceName);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Номер прибора", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  SerialNumber[8] = 0;
  sprintf(display, "%s", SerialNumber);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Версия ПО", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  sprintf(display, "1.15");
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);

  GUI_UpdateSettingsInfoScreen();
}

void GUI_UpdateSettingsInfoScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsInfoScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
}

void GUI_DrawSettingsConnectionScreen()
{
  char display[36];
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", "Настройки связи");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("RS-232 и RS-485", DARKGREEN, BACKGROUND_COLOR, UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  sprintf(display, "%s/%d", RS_SPEEDS[ConfigWord & UART_MASK], NetAddress);
  TFT_WriteStringInRectLeft("RS Скорость/Адрес", BLACK, BACKGROUND_COLOR, LEFTHALF_LOWER_BOTTOM, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma19B);

  if (ConfigWord & TCP_PRESENT)
  {
    TFT_WriteStringInRectCenter("TCP/IP и UDP/IP", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma19B);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

    TFT_WriteStringInRectLeft("Сетевое имя", BLACK, BACKGROUND_COLOR, LEFTHALF_LOWERMOST_TOP, 3, 0, &Tahoma19B);
    TFT_WriteStringInRectCenter(HostName, BROWN, BACKGROUND_COLOR, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma19B);
    
    Int32U  ip_;    
    if (TCPIPConfig.UseDHCP)  ip_    = IP_GetIPAddr(0);
    else                      ip_    = TCPIPConfig.IP;
    
    ParseIPAddress(ip_, display);        
    TFT_WriteStringInRectLeft("IP-адрес", BLACK, BACKGROUND_COLOR, LEFTHALF_LOWERMOST_BOTTOM, 3, 0, &Tahoma19B);
    TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma19B);
  }

  GUI_UpdateSettingsConnectionScreen();
}

void GUI_UpdateSettingsConnectionScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsConnectionScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }

  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsRSScreen, GUI_UpdateSettingsRSScreen, GUI_TouchSettingsRSScreen);
    return;
  }
  
  if (ConfigWord & TCP_PRESENT)
    if (TFT_CoordsInRect(X, Y, UPPER))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawSettingsTCPScreen, GUI_UpdateSettingsTCPScreen, GUI_TouchSettingsTCPScreen);
      return;
    }
}

void GUI_DrawSettingsRSScreen()
{
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", "RS-232 и RS-485");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[25];
  TFT_WriteStringInRectLeft("Скорость связи", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);

  TFT_WriteStringInRectLeft("Сетевой адрес", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  sprintf(display, "%d", NetAddress);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  GUI_UpdateSettingsRSScreen();
}

void GUI_UpdateSettingsRSScreen()
{
  GUI_UpdateHeader();

  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", RS_SPEEDS[ConfigWord & UART_MASK]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsRSScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    SAVE_CONFIG(ConfigWord);
    SAVE_CONFIG(InvConfigWord);
    SAVE_CONFIG(NetAddress);
    OS_Unuse(&SemaRAM);
    
    USART2_BRR =  select_speed(ConfigWord & UART_MASK, APB1); // обновить скорость RS
    
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    LOAD_CONFIG(NetAddress);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    LOAD_CONFIG(NetAddress);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    Int8U speed = ConfigWord & UART_MASK;
    speed++;
    if (speed > 7) speed = 0;
    ConfigWord = ConfigWord & ~(Int32U)UART_MASK;
    ConfigWord |= speed;
    InvConfigWord = ~ConfigWord;
    GUI_UpdateSettingsRSScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    int net_addr = NetAddress;
    if (GUI_KeyboardInt(&net_addr, "Настройки", "Сетевой адрес", true, 1, 255))
      NetAddress = net_addr;
    GUI_DrawSettingsRSScreen();
    return;
  }
}

void GUI_DrawSettingsTCPScreen()
{
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", "TCP/IP и UDP/IP");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Использовать DHCP", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("IP-адрес", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("Маска подсети", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("Шлюз", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWERMOST, 3, 0, &Tahoma19B);
  
  GUI_UpdateSettingsTCPScreen();
}

void GUI_UpdateSettingsTCPScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  sprintf(display, "%s", TCPIPConfig.UseDHCP ? "Да" : "Нет");
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHTHALF_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  Int16U color;
  color = TCPIPConfig.UseDHCP ? BROWN : DARKGREEN;

  char ip[25], mask[25], gate[25];
  if (TCPIPConfig.UseDHCP)
  {
    Int32U ip_, mask_, gate_;
    
    ip_   = IP_GetIPAddr(0);
    mask_ = IP_GetAddrMask(0);
    gate_ = IP_GetGWAddr(0);
    
    ParseIPAddress(ip_, ip);
    ParseIPAddress(mask_, mask);
    ParseIPAddress(gate_, gate);
  }
  else
  {
    ParseIPAddress(TCPIPConfig.IP, ip);
    ParseIPAddress(TCPIPConfig.Mask, mask);
    ParseIPAddress(TCPIPConfig.Gate, gate);
  }
  
  TFT_FillRect_(RIGHTHALF_UPPER, BACKGROUND_COLOR);
  TFT_WriteStringInRectCenter(ip, color, BACKGROUND_COLOR, RIGHTHALF_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHTHALF_LOWER, BACKGROUND_COLOR);
  TFT_WriteStringInRectCenter(mask, color, BACKGROUND_COLOR, RIGHTHALF_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHTHALF_LOWERMOST, BACKGROUND_COLOR);
  TFT_WriteStringInRectCenter(gate, color, BACKGROUND_COLOR, RIGHTHALF_LOWERMOST, 0, 0, &Tahoma19B);
}

void GUI_TouchSettingsTCPScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    TCPIPConfig.UseDHCP = !TCPIPConfig.UseDHCP;
    OS_Use(&SemaRAM);
    SAVE_CONFIG(TCPIPConfig);
    OS_Unuse(&SemaRAM);
    Initialize_TCPIP_Config(0);
    
    GUI_UpdateSettingsTCPScreen();
    return;
  }
  
  if (!TCPIPConfig.UseDHCP)
  {
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardIP(&TCPIPConfig.IP, "Настройки", "IP-адрес");
      OS_Use(&SemaRAM);
      SAVE_CONFIG(TCPIPConfig);
      OS_Unuse(&SemaRAM);
      Initialize_TCPIP_Config(0);
    
      GUI_DrawSettingsTCPScreen();
      return;
    }
    
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardIP(&TCPIPConfig.Mask, "Настройки", "Маска подсети");
      OS_Use(&SemaRAM);
      SAVE_CONFIG(TCPIPConfig);
      OS_Unuse(&SemaRAM);
      Initialize_TCPIP_Config(0);
    
      GUI_DrawSettingsTCPScreen();
      return;
    }
    
    if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWERMOST))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardIP(&TCPIPConfig.Gate, "Настройки", "Шлюз");
      OS_Use(&SemaRAM);
      SAVE_CONFIG(TCPIPConfig);
      OS_Unuse(&SemaRAM);
      Initialize_TCPIP_Config(0);
    
      GUI_DrawSettingsTCPScreen();
      return;
    }
  }
}

void GUI_DrawSettingsStatisticScreen()
{
  GUI_DrawHeader(BACK_30x30, EVEN_YELLOW, "Настройки", "Статистика");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[25];
  TFT_WriteStringInRectLeft("Период записи, с", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  sprintf(display, "%d", StatisticPeriod);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Записей", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  
  TFT_WriteStringInRectCenter("Сбросить статистику", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateSettingsStatisticScreen();
}

void GUI_UpdateSettingsStatisticScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  TFT_FillRect_(RIGHT_UPPER_TOP, BACKGROUND_COLOR);
  sprintf(display, "%d", (WriteStatAddr-SD_STATISTIC_OFFSET)/0x600);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_UPPER_TOP, 0, 0, &Tahoma19B);
  
  TFT_FillRect_(RIGHT_UPPER_BOTTOM, BACKGROUND_COLOR);
  float fullness = ((float)WriteStatAddr-(float)SD_STATISTIC_OFFSET)/(1024.*1024.*1024.);
  sprintf(display, "%.0f %%", fullness);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsStatisticScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    if (GUI_KeyboardInt(&StatisticPeriod, "Настройки", "Период статистики", true, 30, 6000))
    {
      OS_Use(&SemaRAM);
      SAVE_CONFIG(StatisticPeriod);
      OS_Unuse(&SemaRAM);
    };
    GUI_DrawSettingsStatisticScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWERMOST))
  {
    set_sound(S_SOUND_20);
    if (GUI_MessageBox("Подтверждение", "Очистить память статистики?", "Это действие не может быть", "отменено.", 60, MESSAGEBOX_YESNO, BACKGROUND_COLOR))
    {
      ConfigWord &= ~STATISCTIC_OVERFLOW;
      InvConfigWord = ~ConfigWord;
      WriteStatAddr = SD_STATISTIC_OFFSET;
      OS_Use(&SemaRAM);
        SAVE_CONFIG(ConfigWord);
        SAVE_CONFIG(InvConfigWord);
      OS_Unuse(&SemaRAM);
    }
    GUI_DrawSettingsStatisticScreen();
    return;
  }
}

void GUI_DrawSettingsOtherScreen1()
{
  GUI_DrawHeader(SWITCH_30x30, EVEN_YELLOW, "Настройки", "Другие настройки");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Дата/время", DARKGREEN, BACKGROUND_COLOR, UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Звуки", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Калибровка экрана", DARKGREEN, BACKGROUND_COLOR, LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Восстановить заводские установки", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateSettingsOtherScreen1();
}

void GUI_UpdateSettingsOtherScreen1()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsOtherScreen1()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen2, GUI_UpdateSettingsOtherScreen2, GUI_TouchSettingsOtherScreen2);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPERMOST))
  {
    set_sound(S_SOUND_20);
    TempTime = Time;
    GUI_SetGUI(GUI_DrawSettingsDateScreen, GUI_UpdateSettingsDateScreen, GUI_TouchSettingsDateScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsSoundsScreen, GUI_UpdateSettingsSoundsScreen, GUI_TouchSettingsSoundsScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWER))
  {
    set_sound(S_SOUND_20);
    GUI_CalibTouch();
    GUI_DrawSettingsOtherScreen1();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWERMOST))
  {
    set_sound(S_SOUND_20);
    if (GUI_MessageBox("Подтверждение", "Востановить заводские", "установки?", "", 60, MESSAGEBOX_YESNO, BACKGROUND_COLOR))
    {
      OS_Use( &SemaRAM);
      system_flags.readdefaultmem = 1;
      OS_Unuse( &SemaRAM);
      GUI_InitializeRects();
    }
    GUI_DrawSettingsOtherScreen1();
    return;
  }
}

void GUI_DrawSettingsOtherScreen2()
{
  GUI_DrawHeader(SWITCH_30x30, EVEN_YELLOW, "Настройки", "Другие настройки");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Веб-интерфейс", DARKGREEN, BACKGROUND_COLOR, UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);
  
  GUI_UpdateSettingsOtherScreen2();
}

void GUI_UpdateSettingsOtherScreen2()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsOtherScreen2()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsWebServerScreen, GUI_UpdateSettingsWebServerScreen, GUI_TouchSettingsWebServerScreen);
    return;
  }
}

void GUI_DrawSettingsDateScreen()
{
  GUI_DrawHeaderGrayoutButton(OK_30x30, EVEN_YELLOW, "Настройки", "Дата");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[10];
  int y, m, d, h, mi, s;
  ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);

  TFT_WriteStringInRectLeft("Год", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  sprintf(display, "%d", y);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Месяц", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  sprintf(display, "%d", m);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("День", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  sprintf(display, "%d", d);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Далее", BLACK, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateSettingsDateScreen();
}

void GUI_UpdateSettingsDateScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsDateScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  int y, m, d, h, mi, s;
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt(&y, "Настройки", "Год", true, 2014, 2100))
      TempTime = EncodeDate(&s, &mi, &h, &d, &m, &y);
    GUI_DrawSettingsDateScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt(&m, "Настройки", "Месяц", true, 1, 12))
      TempTime = EncodeDate(&s, &mi, &h, &d, &m, &y);
    GUI_DrawSettingsDateScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt(&d, "Настройки", "День", true, 1, 31))
      TempTime = EncodeDate(&s, &mi, &h, &d, &m, &y);
    GUI_DrawSettingsDateScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsTimeScreen, GUI_UpdateSettingsTimeScreen, GUI_TouchSettingsTimeScreen);
    return;
  }
}

void GUI_DrawSettingsTimeScreen()
{
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", "Время");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[10];
  int y, m, d, h, mi, s;
  ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);

  TFT_WriteStringInRectLeft("Часы", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  sprintf(display, "%d", h);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Минуты", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  sprintf(display, "%d", mi);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Назад", BLACK, BACKGROUND_COLOR, LEFT_THIRD_LOWERMOST, 0, 0, &Tahoma19B);
  
  GUI_UpdateSettingsTimeScreen();
}

void GUI_UpdateSettingsTimeScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsTimeScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
   
    OS_Use(&SemaRAM);
    PWR_CR_bit.DBP=       1;
    while(!RTC_CRL_bit.RTOFF);
    RTC_CRL_bit.CNF=      1;
    RTC_CNTL=             TempTime & 0xffff;
    RTC_CNTH=             TempTime >> 16;
    RTC_CRL_bit.CNF=      0;
    while(!RTC_CRL_bit.RTOFF);
    PWR_CR_bit.DBP=       0;
    Time = TempTime;
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  int y, m, d, h, mi, s = 0;
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt(&h, "Настройки", "Часы", true, 0, 23))
      TempTime = EncodeDate(&s, &mi, &h, &d, &m, &y);
    GUI_DrawSettingsTimeScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    ParseDate(&TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt(&mi, "Настройки", "Минуты", true, 0, 59))
      TempTime = EncodeDate(&s, &mi, &h, &d, &m, &y);
    GUI_DrawSettingsTimeScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LEFT_THIRD_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsDateScreen, GUI_UpdateSettingsDateScreen, GUI_TouchSettingsDateScreen);
    return;
  }
}

void GUI_DrawSettingsSoundsScreen()
{
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", "Звуки");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Ошибки", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("Пороги", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  
  GUI_UpdateSettingsSoundsScreen();
}

void GUI_UpdateSettingsSoundsScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", ConfigWord & ERROR_BEEP ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", ConfigWord & TRSH_BEEP ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsSoundsScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
   
    OS_Use(&SemaRAM);
    SAVE_CONFIG(ConfigWord);
    SAVE_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
  
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    if (ConfigWord & ERROR_BEEP)
      ConfigWord &= ~ERROR_BEEP;
    else
      ConfigWord |= ERROR_BEEP;
    InvConfigWord = ~ConfigWord;
    GUI_UpdateSettingsSoundsScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    if (ConfigWord & TRSH_BEEP)
      ConfigWord &= ~TRSH_BEEP;
    else
      ConfigWord |= TRSH_BEEP;
    InvConfigWord = ~ConfigWord;
    GUI_UpdateSettingsSoundsScreen();
    return;
  }
}

void GUI_DrawSettingsWebServerScreen()
{
  char display[25];
  GUI_DrawHeader(OK_30x30, EVEN_YELLOW, "Настройки", "Веб-интерфейс");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Активен", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPERMOST, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectLeftInTwoLines("Запретить сброс", "статистики", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 3, 0, &Tahoma19B);
  TFT_WriteStringInRectLeft("Автообновление, сек", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 3, 0, &Tahoma19B);
  sprintf(display, "%d", WebServerConfig.AutoRefreshPeriod);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  GUI_UpdateSettingsWebServerScreen();
}

void GUI_UpdateSettingsWebServerScreen()
{
  GUI_UpdateHeader();
  
  char display[25];
  TFT_FillRect_(RIGHT_THIRD_UPPERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", WebServerConfig.Disabled ? "Нет" : "Да");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPERMOST, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPERMOST, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", WebServerConfig.HideStatisticReset ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma19B);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsWebServerScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, CHANNEL0))
  {
    set_sound(S_SOUND_20);
   
    OS_Use(&SemaRAM);
    SAVE_CONFIG(WebServerConfig);
    SAVE_CONFIG(WebServerConfig);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsOtherScreen2, GUI_UpdateSettingsOtherScreen2, GUI_TouchSettingsOtherScreen2);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(WebServerConfig);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(WebServerConfig);
    OS_Unuse(&SemaRAM);
  
    GUI_SetGUI(GUI_DrawSettingsOtherScreen2, GUI_UpdateSettingsOtherScreen2, GUI_TouchSettingsOtherScreen2);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPERMOST))
  {
    set_sound(S_SOUND_20);
    WebServerConfig.Disabled = !WebServerConfig.Disabled;
    GUI_UpdateSettingsWebServerScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_UPPER))
  {
    set_sound(S_SOUND_20);
    WebServerConfig.HideStatisticReset = !WebServerConfig.HideStatisticReset;
    GUI_UpdateSettingsWebServerScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_TWOTHIRDS_LOWER))
  {
    set_sound(S_SOUND_20);
    int temp = WebServerConfig.AutoRefreshPeriod;
    if (GUI_KeyboardInt(&temp, "Веб-интерфейс", "Автообновление, сек", true, 0, 65535))
    if((temp < 30) && temp) temp = 30;
    WebServerConfig.AutoRefreshPeriod = temp;
    GUI_DrawSettingsWebServerScreen();
    return;
  }
}

void GUI_InitializeRects()
{
  Int8U channels_count = GetDisplayChannelsCount();
  if (channels_count > 4) channels_count = 4;
  
  switch (channels_count)
  {
    case 1:
    case 2:
      Lines = LINES_BIG;
      Channels = CHANNELS_BIG;
      Params = PARAMS_BIG;
      LParams = LPARAMS_BIG;
      RParams = RPARAMS_BIG;
      Captions = CAPTIONS_BIG;
      LCaptions = LCAPTIONS_BIG;
      RCaptions = RCAPTIONS_BIG;
      Values = VALUES_BIG;
      LValues = LVALUES_BIG;
      RValues = RVALUES_BIG;
      Params_sequence = PARAMS_SEQUENCE_BIG;
      break;
    
    case 3:
    case 4:
      Lines = LINES;
      Channels = CHANNELS;
      Params = PARAMS;
      LParams = LPARAMS;
      RParams = RPARAMS;
      Captions = CAPTIONS;
      LCaptions = LCAPTIONS;
      RCaptions = RCAPTIONS;
      Values = VALUES;
      LValues = LVALUES;
      RValues = RVALUES;
      Params_sequence = PARAMS_SEQUENCE;
      break;
  }
}

U8 TFT_init(void)
{   
/* сброс */    
  RES_TFT_LOW;
  OS_Delay (2);
  
  RES_TFT_HIGH;
  OS_Delay (50);  
  
/* Start Initial Sequence --------------------------------------------------*/  
  write_control_TFT(0x01, 0x0100);  // SS = 1
  
  // ckeck TFT
  if(read_control_TFT(0x01) != 0x0100) 
  {
    return 1;
  }
  
  write_control_TFT(0x02, 0x0000);  // B/C= 0
  write_control_TFT(0x03, 0x1028);  // AM=1 I/D1=D2= 1 TRI=DFM= 0 BGR = 1  28
  write_control_TFT(0x04, 0x0000);  // no resize
  write_control_TFT(0x05, 0x0000);  // RGB 565 формат цвета
  write_control_TFT(0x08, 0x0707); /* 7 lines each, back and front porch */
  write_control_TFT(0x09, 0x0000); /* время между кадрами */
  write_control_TFT(0x0A, 0x0000); /* FMARK function */
  write_control_TFT(0x0C, 0x0000); /* RGB interface setting */
  write_control_TFT(0x0D, 0x0000); /* Frame marker Position */
  write_control_TFT(0x0F, 0x0000); /* RGB interface polarity */
    
/* Power On sequence -------------------------------------------------------*/
  write_control_TFT(0x11, 0x0007); // set VC = 3
  write_control_TFT(0x12, 0x000a); // set VRH = A
  write_control_TFT(0x29, 0x001f); // set VCM = 1F
  write_control_TFT(0x13, 0x1800); // set VDV = 18
  write_control_TFT(0x10, 0x0200); // set BT = 2
  OS_Delay (50);
  
  write_control_TFT(0x10, 0x0290); // set BT = 2, APE = 1, AP =  1
  write_control_TFT(0x11, 0x0227); // set VC = 3, DC1=2, DC0=2
  OS_Delay (80);  
   
  write_control_TFT(0x20, 0x0000); /* GRAM horizontal Address */
  write_control_TFT(0x21, 0x0000); /* GRAM Vertical Address */
  write_control_TFT(0x2B, 0x000d); // Frame Rate = 93 Hz
  
/* Adjust the Gamma Curve --------------------------------------------------*/
  
  write_control_TFT(0x30, 0x0000);  // 0x0000);
  write_control_TFT(0x31, 0x0507);  // 0x0507);
  write_control_TFT(0x32, 0x0104);  // 0x0104);
  write_control_TFT(0x35, 0x0105);  // 0105
  write_control_TFT(0x36, 0x0404);
  
  write_control_TFT(0x37, 0x0603);
  write_control_TFT(0x38, 0x0004);
  write_control_TFT(0x39, 0x0007);
  write_control_TFT(0x3C, 0x0501);
  write_control_TFT(0x3D, 0x0404); 
  
  
/* Set GRAM area -----------------------------------------------------------*/
  write_control_TFT(0x50, 0x0000); /* Horizontal GRAM Start Address 0  */
  write_control_TFT(0x51, 0x00EF); /* Horizontal GRAM End Address  240 */
  write_control_TFT(0x52, 0x0000); /* Vertical GRAM Start Address 0    */
  write_control_TFT(0x53, 0x013F); /* Vertical GRAM End Address  320   */
  write_control_TFT(0x60, 0xA700); /* Gate Scan Line = 320 */
  write_control_TFT(0x61, 0x0001); /* NDL, VLE, REV = 1 (индикатор с инверсной поляризацией) */
  write_control_TFT(0x6A, 0x0000); /* Set scrolling line */  
  
/* Partial Display Control -------------------------------------------------*/
  write_control_TFT(0x80, 0x0000);
  write_control_TFT(0x81, 0x0000);
  write_control_TFT(0x82, 0x0000);
  write_control_TFT(0x83, 0x0000);
  write_control_TFT(0x84, 0x0000);
  write_control_TFT(0x85, 0x0000);

/* Panel Control -----------------------------------------------------------*/
  write_control_TFT(0x90, 0x0010);  // Frame Freq = 
  write_control_TFT(0x92, 0x0100);  // NOW = 1

/* Dislay ON -------------------------------------------------------------- */  
  fill_GRAM_TFT(240*320, 0);        // clear GRAM
  write_control_TFT(0x10, 0x1290);  // set BT = 2, APE = 1, AP =  1, SAP= 1 
  write_control_TFT(0x07, 0x0133);  // display ON

  if(Brightness > 100) Brightness = 100;
  TIM4_CCR4  = TIM4_ARR * (0.65 * Brightness / 100. + 0.1);  // TIM4_CCR4 = 10...75% от TIM4_ARR, скважнось ШИМ
  return 0;
}

void TFT_Task(void) 
{
  Int8U update_counter = 0;

  GUI_LogoScreen();
  GUI_InitializeRects();
  GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
  
  while (1)
  {
    // calib
    if (system_flags.ScreenCalib)
    {
      GUI_CalibTouch();
      
      OS_Use( &SemaRAM);
        system_flags.ScreenCalib = 0;
          OS_Unuse( &SemaRAM);
    }
    
    // screenshoot    
    if(system_flags.ScreenShoot)
    {
      ScreenShoot(SD_SCREENSHOT_OFFSET);
      
      OS_Use( &SemaRAM);
        system_flags.ScreenShoot = 0;
          OS_Unuse( &SemaRAM);
    }
    
    if (system_flags.redraw_gui && draw)
    {
      GUI_InitializeRects(); draw();
     
      OS_Use( &SemaRAM);
        system_flags.redraw_gui = 0;
          OS_Unuse( &SemaRAM);
    }

    if ((update_counter++ % 20 == 0) && update) 
    {
      if(read_control_TFT(0x01) != 0x0100) 
      {
        TFT_init();
        draw();
      }
      update();
    }
    
    if (touch)
    {
	touch();
	OS_ClearMB(&TouchPad_MB);
        OS_ClearMB(&Key_MB);
    }
    
    if( OS_WaitSingleEventTimed(1, 50) )
    {
      if( (draw != GUI_DrawMeasuresScreen) && 
            (draw != GUI_DrawControlsScreen) && 
              (draw != GUI_DrawControlScreen) )
      {
        GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
      }
    }
  }
}
