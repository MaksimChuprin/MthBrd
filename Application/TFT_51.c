#include "defines.h"
#include "IP_init_407.h"

const U16  calibPointsX[2] = { 25, 775 };
const U16  calibPointsY[2] = { 25, 455 };

const RECT CALIB_ULCORNER = {0,   50,  0,   50,  CALB_RECTS_COLOR};
const RECT CALIB_URCORNER = {750, 799, 0,   50,  CALB_RECTS_COLOR};
const RECT CALIB_DRCORNER = {750, 799, 430, 479, CALB_RECTS_COLOR};
const RECT CALIB_DLCORNER = {0,   50,  430, 479, CALB_RECTS_COLOR};
const RECT CALIB_CENTER   = {375, 425, 215, 265, CALB_RECTS_COLOR};

const RECT SCREEN = {0, RESOLUTION_X-1, 0, RESOLUTION_Y-1, BACKGROUND_COLOR};

const RECT MENU0_LEFT  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  0,   119, EVEN_YELLOW};
const RECT MENU1_LEFT  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  120, 239, EVEN_YELLOW};
const RECT MENU2_LEFT  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  240, 359, EVEN_YELLOW};
const RECT MENU3_LEFT  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  360, 479, EVEN_YELLOW};

const RECT UPPERMOST  = {0, RESOLUTION_X-1, UPPERMOST_LINE_SY, UPPERMOST_LINE_EY, RED};
const RECT UPPER      = {0, RESOLUTION_X-1, UPPER_LINE_SY,     UPPER_LINE_EY,     RED};
const RECT MIDDLE     = {0, RESOLUTION_X-1, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    RED};
const RECT LOWER      = {0, RESOLUTION_X-1, LOWER_LINE_SY,     LOWER_LINE_EY,     RED};
const RECT LOWERMOST  = {0, RESOLUTION_X-1, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, RED};

const RECT UPPERMOST_TOP      = {0, RESOLUTION_X-1, UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    RED};
const RECT UPPERMOST_BOTTOM   = {0, RESOLUTION_X-1, UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, RED};
const RECT UPPER_TOP          = {0, RESOLUTION_X-1, UPPER_TOP_LINE_SY,        UPPER_TOP_LINE_EY,        RED};
const RECT UPPER_BOTTOM       = {0, RESOLUTION_X-1, UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     RED};
const RECT MIDDLE_TOP         = {0, RESOLUTION_X-1, MIDDLE_TOP_LINE_SY,       MIDDLE_TOP_LINE_EY,       RED};
const RECT MIDDLE_BOTTOM      = {0, RESOLUTION_X-1, MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    RED};
const RECT LOWER_TOP          = {0, RESOLUTION_X-1, LOWER_TOP_LINE_SY,        LOWER_TOP_LINE_EY,        RED};
const RECT LOWER_BOTTOM       = {0, RESOLUTION_X-1, LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     RED};
const RECT LOWERMOST_TOP      = {0, RESOLUTION_X-1, LOWERMOST_TOP_LINE_SY,    LOWERMOST_TOP_LINE_EY,    RED};
const RECT LOWERMOST_BOTTOM   = {0, RESOLUTION_X-1, LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, RED};

const RECT* LINES_SMALL[8] = {&UPPER_TOP, &UPPER_BOTTOM, &MIDDLE_TOP, &MIDDLE_BOTTOM, &LOWER_TOP, &LOWER_BOTTOM, &LOWERMOST_TOP, &LOWERMOST_BOTTOM};

const RECT HEAD            = {0,                        RESOLUTION_X-1,           UPPERMOST_LINE_SY,        UPPERMOST_LINE_EY,        BACKGROUND_COLOR};
const RECT HEAD_MAINBUTTON = {LEFT_COLUMN_SX,           LEFT_COLUMN_EX,           UPPERMOST_LINE_SY,        UPPERMOST_LINE_EY,        EVEN_YELLOW};
const RECT HEAD_LBUTTON    = {HEADER_LEFT_BUTTON_SX,    HEADER_LEFT_BUTTON_EX,    UPPERMOST_LINE_SY,        UPPERMOST_LINE_EY,        SHIFTED_EVEN_YELLOW};
const RECT HEAD_RBUTTON    = {HEADER_RIGHT_BUTTON_SX,   HEADER_RIGHT_BUTTON_EX,   UPPERMOST_LINE_SY,        UPPERMOST_LINE_EY,        SHIFTED_EVEN_YELLOW};

const RECT HEADER          = {RIGHTHALF_SX,             RIGHTHALF_EX,             UPPERMOST_LINE_SY,        UPPERMOST_LINE_EY,        BACKGROUND_COLOR};
const RECT TOPIC           = {RIGHTHALF_SX,             RIGHT_COLUMN_SX-1,        UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    ODD_GRAY};
const RECT TITLE           = {RIGHTHALF_SX,             RIGHTHALF_EX,             UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, EVEN_GRAY};
const RECT TIME            = {RIGHT_COLUMN_SX,          RIGHT_COLUMN_EX,          UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    ODD_GRAY};

const RECT HEADER_WIDE     = {LEFT_PARAMS_SX,           RIGHTHALF_EX,             UPPERMOST_LINE_SY,        UPPERMOST_LINE_EY,        BACKGROUND_COLOR};
const RECT TOPIC_WIDE      = {LEFT_PARAMS_SX,           RIGHT_COLUMN_SX-1,        UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    ODD_GRAY};
const RECT TITLE_WIDE      = {LEFT_PARAMS_SX,           RIGHTHALF_EX,             UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, EVEN_GRAY};

const RECT BODY = {0, RESOLUTION_X-1, UPPER_LINE_SY, LOWERMOST_LINE_EY, BACKGROUND_COLOR};

const RECT ULBUTTON  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  UPPER_LINE_SY,     UPPER_LINE_EY,     ODD_GREEN};
const RECT MLBUTTON  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    EVEN_GREEN};
const RECT LLBUTTON  = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  LOWER_LINE_SY,     LOWER_LINE_EY,     ODD_GREEN};
const RECT LMLBUTTON = {LEFT_COLUMN_SX,  LEFT_COLUMN_EX,  LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, EVEN_GREEN};

const RECT* BORDER_BUTTONS_UD[4] = {&ULBUTTON, &MLBUTTON, &LLBUTTON, &LMLBUTTON};

const RECT UPARAM  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_LINE_SY,     UPPER_LINE_EY,     ODD_GREEN};
const RECT MPARAM  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    EVEN_GREEN};
const RECT LPARAM  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_LINE_SY,     LOWER_LINE_EY,     ODD_GREEN};
const RECT LMPARAM = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, EVEN_GREEN};

const RECT UCAPTION  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_TOP_LINE_SY,     UPPER_TOP_LINE_EY,     ODD_GREEN};
const RECT MCAPTION  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  MIDDLE_TOP_LINE_SY,    MIDDLE_TOP_LINE_EY,    EVEN_GREEN};
const RECT LCAPTION  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_TOP_LINE_SY,     LOWER_TOP_LINE_EY,     ODD_GREEN};
const RECT LMCAPTION = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_TOP_LINE_SY, LOWERMOST_TOP_LINE_EY, EVEN_GREEN};

const RECT UVALUE  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     ODD_GREEN};
const RECT MVALUE  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    EVEN_GREEN};
const RECT LVALUE  = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     ODD_GREEN};
const RECT LMVALUE = {LEFT_PARAMS_SX,  RIGHT_PARAMS_EX,  LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, EVEN_GREEN};

const RECT ULPARAM  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPER_LINE_SY,     UPPER_LINE_EY,     ODD_GREEN};
const RECT MLPARAM  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    EVEN_GREEN};
const RECT LLPARAM  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWER_LINE_SY,     LOWER_LINE_EY,     ODD_GREEN};
const RECT LMLPARAM = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, EVEN_GREEN};
const RECT URPARAM  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPER_LINE_SY,     UPPER_LINE_EY,     EVEN_GREEN};
const RECT MRPARAM  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    ODD_GREEN};
const RECT LRPARAM  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWER_LINE_SY,     LOWER_LINE_EY,     EVEN_GREEN};
const RECT LMRPARAM = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, ODD_GREEN};

const RECT UMLCAPTION = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPERMOST_TOP_LINE_SY, UPPERMOST_TOP_LINE_EY, BACKGROUND_COLOR};
const RECT ULCAPTION  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPER_TOP_LINE_SY,     UPPER_TOP_LINE_EY,     ODD_GREEN};
const RECT MLCAPTION  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  MIDDLE_TOP_LINE_SY,    MIDDLE_TOP_LINE_EY,    EVEN_GREEN};
const RECT LLCAPTION  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWER_TOP_LINE_SY,     LOWER_TOP_LINE_EY,     ODD_GREEN};
const RECT LMLCAPTION = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWERMOST_TOP_LINE_SY, LOWERMOST_TOP_LINE_EY, EVEN_GREEN};
const RECT UMRCAPTION = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPERMOST_TOP_LINE_SY, UPPERMOST_TOP_LINE_EY, BACKGROUND_COLOR};
const RECT URCAPTION  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPER_TOP_LINE_SY,     UPPER_TOP_LINE_EY,     EVEN_GREEN};
const RECT MRCAPTION  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, MIDDLE_TOP_LINE_SY,    MIDDLE_TOP_LINE_EY,    ODD_GREEN};
const RECT LRCAPTION  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWER_TOP_LINE_SY,     LOWER_TOP_LINE_EY,     EVEN_GREEN};
const RECT LMRCAPTION = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWERMOST_TOP_LINE_SY, LOWERMOST_TOP_LINE_EY, ODD_GREEN};

const RECT UMLVALUE = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BACKGROUND_COLOR};
const RECT ULVALUE  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     ODD_GREEN};
const RECT MLVALUE  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    EVEN_GREEN};
const RECT LLVALUE  = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     ODD_GREEN};
const RECT LMLVALUE = {LEFT_PARAMS_SX,  LEFT_PARAMS_EX,  LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, EVEN_GREEN};
const RECT UMRVALUE = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BACKGROUND_COLOR};
const RECT URVALUE  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     EVEN_GREEN};
const RECT MRVALUE  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    ODD_GREEN};
const RECT LRVALUE  = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     EVEN_GREEN};
const RECT LMRVALUE = {RIGHT_PARAMS_SX, RIGHT_PARAMS_EX, LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, ODD_GREEN};

const RECT* PARAMS_UD[8]   = {&ULPARAM,   &MLPARAM,   &LLPARAM,   &LMLPARAM,   &URPARAM,   &MRPARAM,   &LRPARAM,   &LMRPARAM};
const RECT* CAPTIONS_UD[8] = {&ULCAPTION, &MLCAPTION, &LLCAPTION, &LMLCAPTION, &URCAPTION, &MRCAPTION, &LRCAPTION, &LMRCAPTION};
const RECT* VALUES_UD[8]   = {&ULVALUE,   &MLVALUE,   &LLVALUE,   &LMLVALUE,   &URVALUE,   &MRVALUE,   &LRVALUE,   &LMRVALUE};

const RECT* PARAMS_WIDE_UD[4]  = {&UPARAM,  &MPARAM,  &LPARAM,  &LMPARAM};
const RECT* LPARAMS_WIDE_UD[4] = {&ULPARAM, &MLPARAM, &LLPARAM, &LMLPARAM};
const RECT* RPARAMS_WIDE_UD[4] = {&URPARAM, &MRPARAM, &LRPARAM, &LMRPARAM};

const RECT* PARAMS_LR[12]   = {&ULPARAM,   &URPARAM,   &MLPARAM,   &MRPARAM,   &LLPARAM,   &LRPARAM,   &LMLPARAM,   &LMRPARAM,   &UPARAM,   &MPARAM,   &LPARAM,   &LMPARAM};
const RECT* CAPTIONS_LR[12] = {&ULCAPTION, &URCAPTION, &MLCAPTION, &MRCAPTION, &LLCAPTION, &LRCAPTION, &LMLCAPTION, &LMRCAPTION, &UCAPTION, &MCAPTION, &LCAPTION, &LMCAPTION};
const RECT* VALUES_LR[12]   = {&ULVALUE,   &URVALUE,   &MLVALUE,   &MRVALUE,   &LLVALUE,   &LRVALUE,   &LMLVALUE,   &LMRVALUE,   &UVALUE,   &MVALUE,   &LVALUE,   &LMVALUE};

const RECT LEFT_TWOTHIRDS_UPPERMOST  = {LEFTTHIRD_SX,  CENTRALTHIRD_EX, UPPERMOST_LINE_SY,     UPPERMOST_LINE_EY,     BLUE};
const RECT LEFT_TWOTHIRDS_UPPER      = {LEFTTHIRD_SX,  CENTRALTHIRD_EX, UPPER_LINE_SY,         UPPER_LINE_EY,         BLUE};
const RECT LEFT_TWOTHIRDS_MIDDLE     = {LEFTTHIRD_SX,  CENTRALTHIRD_EX, MIDDLE_LINE_SY,        MIDDLE_LINE_EY,        BLUE};
const RECT LEFT_TWOTHIRDS_LOWER      = {LEFTTHIRD_SX,  CENTRALTHIRD_EX, LOWER_LINE_SY,         LOWER_LINE_EY,         BLUE};
const RECT LEFT_TWOTHIRDS_LOWERMOST  = {LEFTTHIRD_SX,  CENTRALTHIRD_EX, LOWERMOST_LINE_SY,     LOWERMOST_LINE_EY,     BLUE};
const RECT RIGHT_THIRD_UPPERMOST     = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   UPPERMOST_LINE_SY,     UPPERMOST_LINE_EY,     BLUE};
const RECT RIGHT_THIRD_UPPER         = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   UPPER_LINE_SY,         UPPER_LINE_EY,         BLUE};
const RECT RIGHT_THIRD_MIDDLE        = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   MIDDLE_LINE_SY,        MIDDLE_LINE_EY,        BLUE};
const RECT RIGHT_THIRD_LOWER         = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   LOWER_LINE_SY,         LOWER_LINE_EY,         BLUE};
const RECT RIGHT_THIRD_LOWERMOST     = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   LOWERMOST_LINE_SY,     LOWERMOST_LINE_EY,     BLUE};

const RECT RIGHT_THIRD_MIDDLE_TOP    = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   MIDDLE_TOP_LINE_SY,    MIDDLE_TOP_LINE_EY,    BLUE};
const RECT RIGHT_THIRD_MIDDLE_BOTTOM = {RIGHTTHIRD_SX, RIGHTTHIRD_EX,   MIDDLE_BOTTOM_LINE_SY, MIDDLE_BOTTOM_LINE_EY, BLUE};

const RECT LEFTHALF_UPPERMOST  = {LEFTHALF_SX,  LEFTHALF_EX,  UPPERMOST_LINE_SY,   UPPERMOST_LINE_EY, BLUE};
const RECT LEFTHALF_UPPER      = {LEFTHALF_SX,  LEFTHALF_EX,  UPPER_LINE_SY,       UPPER_LINE_EY,     BLUE};
const RECT LEFTHALF_MIDDLE     = {LEFTHALF_SX,  LEFTHALF_EX,  MIDDLE_LINE_SY,      MIDDLE_LINE_EY,    BLUE};
const RECT LEFTHALF_LOWER      = {LEFTHALF_SX,  LEFTHALF_EX,  LOWER_LINE_SY,       LOWER_LINE_EY,     BLUE};
const RECT LEFTHALF_LOWERMOST  = {LEFTHALF_SX,  LEFTHALF_EX,  LOWERMOST_LINE_SY,   LOWERMOST_LINE_EY, BLUE};
const RECT RIGHTHALF_UPPERMOST = {RIGHTHALF_SX, RIGHTHALF_EX, UPPERMOST_LINE_SY,   UPPERMOST_LINE_EY, BLUE};
const RECT RIGHTHALF_UPPER     = {RIGHTHALF_SX, RIGHTHALF_EX, UPPER_LINE_SY,       UPPER_LINE_EY,     BLUE};
const RECT RIGHTHALF_MIDDLE    = {RIGHTHALF_SX, RIGHTHALF_EX, MIDDLE_LINE_SY,      MIDDLE_LINE_EY,    BLUE};
const RECT RIGHTHALF_LOWER     = {RIGHTHALF_SX, RIGHTHALF_EX, LOWER_LINE_SY,       LOWER_LINE_EY,     BLUE};
const RECT RIGHTHALF_LOWERMOST = {RIGHTHALF_SX, RIGHTHALF_EX, LOWERMOST_LINE_SY,   LOWERMOST_LINE_EY, BLUE};

const RECT LEFTHALF_UPPERMOST_TOP     = {LEFTHALF_SX,  LEFTHALF_EX,  UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    BLUE};
const RECT LEFTHALF_UPPERMOST_BOTTOM  = {LEFTHALF_SX,  LEFTHALF_EX,  UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BLUE};
const RECT LEFTHALF_UPPER_TOP         = {LEFTHALF_SX,  LEFTHALF_EX,  UPPER_TOP_LINE_SY,        UPPER_TOP_LINE_EY,        BLUE};
const RECT LEFTHALF_UPPER_BOTTOM      = {LEFTHALF_SX,  LEFTHALF_EX,  UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     BLUE};
const RECT LEFTHALF_MIDDLE_TOP        = {LEFTHALF_SX,  LEFTHALF_EX,  MIDDLE_TOP_LINE_SY,       MIDDLE_TOP_LINE_EY,       BLUE};
const RECT LEFTHALF_MIDDLE_BOTTOM     = {LEFTHALF_SX,  LEFTHALF_EX,  MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    BLUE};
const RECT LEFTHALF_LOWER_TOP         = {LEFTHALF_SX,  LEFTHALF_EX,  LOWER_TOP_LINE_SY,        LOWER_TOP_LINE_EY,        BLUE};
const RECT LEFTHALF_LOWER_BOTTOM      = {LEFTHALF_SX,  LEFTHALF_EX,  LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     BLUE};
const RECT LEFTHALF_LOWERMOST_TOP     = {LEFTHALF_SX,  LEFTHALF_EX,  LOWERMOST_TOP_LINE_SY,    LOWERMOST_TOP_LINE_EY,    BLUE};
const RECT LEFTHALF_LOWERMOST_BOTTOM  = {LEFTHALF_SX,  LEFTHALF_EX,  LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, BLUE};
const RECT RIGHTHALF_UPPERMOST_TOP    = {RIGHTHALF_SX, RIGHTHALF_EX, UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    BLUE};
const RECT RIGHTHALF_UPPERMOST_BOTTOM = {RIGHTHALF_SX, RIGHTHALF_EX, UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BLUE};
const RECT RIGHTHALF_UPPER_TOP        = {RIGHTHALF_SX, RIGHTHALF_EX, UPPER_TOP_LINE_SY,        UPPER_TOP_LINE_EY,        BLUE};
const RECT RIGHTHALF_UPPER_BOTTOM     = {RIGHTHALF_SX, RIGHTHALF_EX, UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     BLUE};
const RECT RIGHTHALF_MIDDLE_TOP       = {RIGHTHALF_SX, RIGHTHALF_EX, MIDDLE_TOP_LINE_SY,       MIDDLE_TOP_LINE_EY,       BLUE};
const RECT RIGHTHALF_MIDDLE_BOTTOM    = {RIGHTHALF_SX, RIGHTHALF_EX, MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    BLUE};
const RECT RIGHTHALF_LOWER_TOP        = {RIGHTHALF_SX, RIGHTHALF_EX, LOWER_TOP_LINE_SY,        LOWER_TOP_LINE_EY,        BLUE};
const RECT RIGHTHALF_LOWER_BOTTOM     = {RIGHTHALF_SX, RIGHTHALF_EX, LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     BLUE};
const RECT RIGHTHALF_LOWERMOST_TOP    = {RIGHTHALF_SX, RIGHTHALF_EX, LOWERMOST_TOP_LINE_SY,    LOWERMOST_TOP_LINE_EY,    BLUE};
const RECT RIGHTHALF_LOWERMOST_BOTTOM = {RIGHTHALF_SX, RIGHTHALF_EX, LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, BLUE};

const RECT* LEFTHALFS_SMALL[8]  = {&LEFTHALF_UPPER_TOP,  &LEFTHALF_UPPER_BOTTOM,  &LEFTHALF_MIDDLE_TOP,  &LEFTHALF_MIDDLE_BOTTOM,  &LEFTHALF_LOWER_TOP,  &LEFTHALF_LOWER_BOTTOM,  &LEFTHALF_LOWERMOST_TOP,  &LEFTHALF_LOWERMOST_BOTTOM};
const RECT* RIGHTHALFS_SMALL[8] = {&RIGHTHALF_UPPER_TOP, &RIGHTHALF_UPPER_BOTTOM, &RIGHTHALF_MIDDLE_TOP, &RIGHTHALF_MIDDLE_BOTTOM, &RIGHTHALF_LOWER_TOP, &RIGHTHALF_LOWER_BOTTOM, &RIGHTHALF_LOWERMOST_TOP, &RIGHTHALF_LOWERMOST_BOTTOM};

const RECT LEFT_UPPERMOST_TOP      = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    BLUE};
const RECT LEFT_UPPERMOST_BOTTOM   = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BLUE};
const RECT LEFT_UPPER_TOP          = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      UPPER_TOP_LINE_SY,        UPPER_TOP_LINE_EY,        BLUE};
const RECT LEFT_UPPER_BOTTOM       = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     BLUE};
const RECT LEFT_MIDDLE_TOP         = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      MIDDLE_TOP_LINE_SY,       MIDDLE_TOP_LINE_EY,       BLUE};
const RECT LEFT_MIDDLE_BOTTOM      = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    BLUE};
const RECT LEFT_LOWER_TOP          = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      LOWER_TOP_LINE_SY,        LOWER_TOP_LINE_EY,        BLUE};
const RECT LEFT_LOWER_BOTTOM       = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     BLUE};
const RECT LEFT_LOWERMOST_TOP      = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      LOWERMOST_TOP_LINE_SY,    LOWERMOST_TOP_LINE_EY,    BLUE};
const RECT LEFT_LOWERMOST_BOTTOM   = {LEFTTHIRD_SX,    LEFTTHIRD_EX,      LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, BLUE};
const RECT CENTER_UPPERMOST_TOP    = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    BLUE};
const RECT CENTER_UPPERMOST_BOTTOM = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BLUE};
const RECT CENTER_UPPER_TOP        = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   UPPER_TOP_LINE_SY,        UPPER_TOP_LINE_EY,        BLUE};
const RECT CENTER_UPPER_BOTTOM     = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     BLUE};
const RECT CENTER_MIDDLE_TOP       = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   MIDDLE_TOP_LINE_SY,       MIDDLE_TOP_LINE_EY,       BLUE};
const RECT CENTER_MIDDLE_BOTTOM    = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    BLUE};
const RECT CENTER_LOWER_TOP        = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   LOWER_TOP_LINE_SY,        LOWER_TOP_LINE_EY,        BLUE};
const RECT CENTER_LOWER_BOTTOM     = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     BLUE};
const RECT CENTER_LOWERMOST_TOP    = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   LOWERMOST_TOP_LINE_SY,    LOWERMOST_TOP_LINE_EY,    BLUE};
const RECT CENTER_LOWERMOST_BOTTOM = {CENTRALTHIRD_SX, CENTRALTHIRD_EX,   LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, BLUE};
const RECT RIGHT_UPPERMOST_TOP     = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     UPPERMOST_TOP_LINE_SY,    UPPERMOST_TOP_LINE_EY,    BLUE};
const RECT RIGHT_UPPERMOST_BOTTOM  = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     UPPERMOST_BOTTOM_LINE_SY, UPPERMOST_BOTTOM_LINE_EY, BLUE};
const RECT RIGHT_UPPER_TOP         = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     UPPER_TOP_LINE_SY,        UPPER_TOP_LINE_EY,        BLUE};
const RECT RIGHT_UPPER_BOTTOM      = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     UPPER_BOTTOM_LINE_SY,     UPPER_BOTTOM_LINE_EY,     BLUE};
const RECT RIGHT_MIDDLE_TOP        = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     MIDDLE_TOP_LINE_SY,       MIDDLE_TOP_LINE_EY,       BLUE};
const RECT RIGHT_MIDDLE_BOTTOM     = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     MIDDLE_BOTTOM_LINE_SY,    MIDDLE_BOTTOM_LINE_EY,    BLUE};
const RECT RIGHT_LOWER_TOP         = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     LOWER_TOP_LINE_SY,        LOWER_TOP_LINE_EY,        BLUE};
const RECT RIGHT_LOWER_BOTTOM      = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     LOWER_BOTTOM_LINE_SY,     LOWER_BOTTOM_LINE_EY,     BLUE};
const RECT RIGHT_LOWERMOST_TOP     = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     LOWERMOST_TOP_LINE_SY,    LOWERMOST_TOP_LINE_EY,    BLUE};
const RECT RIGHT_LOWERMOST_BOTTOM  = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,     LOWERMOST_BOTTOM_LINE_SY, LOWERMOST_BOTTOM_LINE_EY, BLUE};

const RECT* RIGHTS_SMALL[8] = {&RIGHT_UPPER_TOP, &RIGHT_UPPER_BOTTOM, &RIGHT_MIDDLE_TOP, &RIGHT_MIDDLE_BOTTOM, &RIGHT_LOWER_TOP, &RIGHT_LOWER_BOTTOM, &RIGHT_LOWERMOST_TOP, &RIGHT_LOWERMOST_BOTTOM};

const RECT CENTER_LOWER     = {CENTRALTHIRD_SX, CENTRALTHIRD_EX, LOWER_LINE_SY,     LOWER_LINE_EY,     BLUE};
const RECT LEFT_LOWERMOST   = {LEFTTHIRD_SX,    LEFTTHIRD_EX,    LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, BLUE};
const RECT CENTER_LOWERMOST = {CENTRALTHIRD_SX, CENTRALTHIRD_EX, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, BLUE};
const RECT RIGHT_LOWERMOST  = {RIGHTTHIRD_SX,   RIGHTTHIRD_EX,   LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, BLUE};

const RECT ULLCONTROL = {LEFTMOSTFOURTH_SX,  LEFTMOSTFOURTH_EX,  UPPER_LINE_SY, MIDDLE_LINE_EY,    YELLOW};
const RECT LLLCONTROL = {LEFTMOSTFOURTH_SX,  LEFTMOSTFOURTH_EX,  LOWER_LINE_SY, LOWERMOST_LINE_EY, YELLOW};
const RECT ULCONTROL  = {LEFTFOURTH_SX,      LEFTFOURTH_EX,      UPPER_LINE_SY, MIDDLE_LINE_EY,    YELLOW};
const RECT LLCONTROL  = {LEFTFOURTH_SX,      LEFTFOURTH_EX,      LOWER_LINE_SY, LOWERMOST_LINE_EY, YELLOW};
const RECT URCONTROL  = {RIGHTFOURTH_SX,     RIGHTFOURTH_EX,     UPPER_LINE_SY, MIDDLE_LINE_EY,    YELLOW};
const RECT LRCONTROL  = {RIGHTFOURTH_SX,     RIGHTFOURTH_EX,     LOWER_LINE_SY, LOWERMOST_LINE_EY, YELLOW};
const RECT URRCONTROL = {RIGHTMOSTFOURTH_SX, RIGHTMOSTFOURTH_EX, UPPER_LINE_SY, MIDDLE_LINE_EY,    YELLOW};
const RECT LRRCONTROL = {RIGHTMOSTFOURTH_SX, RIGHTMOSTFOURTH_EX, LOWER_LINE_SY, LOWERMOST_LINE_EY, YELLOW};

const RECT* CONTROLS[8] = {&ULLCONTROL, &ULCONTROL, &URCONTROL, &URRCONTROL, &LLLCONTROL, &LLCONTROL, &LRCONTROL, &LRRCONTROL};

const RECT ULLCONTROL_TOP    = {LEFTMOSTFOURTH_SX,    LEFTMOSTFOURTH_EX,    UPPER_BOTTOM_LINE_SY-10,     UPPER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT ULLCONTROL_MIDDLE = {LEFTMOSTFOURTH_SX,    LEFTMOSTFOURTH_EX,    MIDDLE_TOP_LINE_SY-10,       MIDDLE_TOP_LINE_EY-10,       YELLOW};
const RECT ULLCONTROL_BOTTOM = {LEFTMOSTFOURTH_SX+7,  LEFTMOSTFOURTH_EX-7,  MIDDLE_BOTTOM_LINE_SY-10,    MIDDLE_BOTTOM_LINE_EY-10,    YELLOW};
const RECT LLLCONTROL_TOP    = {LEFTMOSTFOURTH_SX,    LEFTMOSTFOURTH_EX,    LOWER_BOTTOM_LINE_SY-10,     LOWER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT LLLCONTROL_MIDDLE = {LEFTMOSTFOURTH_SX,    LEFTMOSTFOURTH_EX,    LOWERMOST_TOP_LINE_SY-10,    LOWERMOST_TOP_LINE_EY-10,    YELLOW};
const RECT LLLCONTROL_BOTTOM = {LEFTMOSTFOURTH_SX+7,  LEFTMOSTFOURTH_EX-7,  LOWERMOST_BOTTOM_LINE_SY-10, LOWERMOST_BOTTOM_LINE_EY-10, YELLOW};
const RECT ULCONTROL_TOP     = {LEFTFOURTH_SX,        LEFTFOURTH_EX,        UPPER_BOTTOM_LINE_SY-10,     UPPER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT ULCONTROL_MIDDLE  = {LEFTFOURTH_SX,        LEFTFOURTH_EX,        MIDDLE_TOP_LINE_SY-10,       MIDDLE_TOP_LINE_EY-10,       YELLOW};
const RECT ULCONTROL_BOTTOM  = {LEFTFOURTH_SX+7,      LEFTFOURTH_EX-7,      MIDDLE_BOTTOM_LINE_SY-10,    MIDDLE_BOTTOM_LINE_EY-10,    YELLOW};
const RECT LLCONTROL_TOP     = {LEFTFOURTH_SX,        LEFTFOURTH_EX,        LOWER_BOTTOM_LINE_SY-10,     LOWER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT LLCONTROL_MIDDLE  = {LEFTFOURTH_SX,        LEFTFOURTH_EX,        LOWERMOST_TOP_LINE_SY-10,    LOWERMOST_TOP_LINE_EY-10,    YELLOW};
const RECT LLCONTROL_BOTTOM  = {LEFTFOURTH_SX+7,      LEFTFOURTH_EX-7,      LOWERMOST_BOTTOM_LINE_SY-10, LOWERMOST_BOTTOM_LINE_EY-10, YELLOW};
const RECT URCONTROL_TOP     = {RIGHTFOURTH_SX,       RIGHTFOURTH_EX,       UPPER_BOTTOM_LINE_SY-10,     UPPER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT URCONTROL_MIDDLE  = {RIGHTFOURTH_SX,       RIGHTFOURTH_EX,       MIDDLE_TOP_LINE_SY-10,       MIDDLE_TOP_LINE_EY-10,       YELLOW};
const RECT URCONTROL_BOTTOM  = {RIGHTFOURTH_SX+7,     RIGHTFOURTH_EX-7,     MIDDLE_BOTTOM_LINE_SY-10,    MIDDLE_BOTTOM_LINE_EY-10,    YELLOW};
const RECT LRCONTROL_TOP     = {RIGHTFOURTH_SX,       RIGHTFOURTH_EX,       LOWER_BOTTOM_LINE_SY-10,     LOWER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT LRCONTROL_MIDDLE  = {RIGHTFOURTH_SX,       RIGHTFOURTH_EX,       LOWERMOST_TOP_LINE_SY-10,    LOWERMOST_TOP_LINE_EY-10,    YELLOW};
const RECT LRCONTROL_BOTTOM  = {RIGHTFOURTH_SX+7,     RIGHTFOURTH_EX-7,     LOWERMOST_BOTTOM_LINE_SY-10, LOWERMOST_BOTTOM_LINE_EY-10, YELLOW};
const RECT URRCONTROL_TOP    = {RIGHTMOSTFOURTH_SX,   RIGHTMOSTFOURTH_EX,   UPPER_BOTTOM_LINE_SY-10,     UPPER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT URRCONTROL_MIDDLE = {RIGHTMOSTFOURTH_SX,   RIGHTMOSTFOURTH_EX,   MIDDLE_TOP_LINE_SY-10,       MIDDLE_TOP_LINE_EY-10,       YELLOW};
const RECT URRCONTROL_BOTTOM = {RIGHTMOSTFOURTH_SX+7, RIGHTMOSTFOURTH_EX-7, MIDDLE_BOTTOM_LINE_SY-10,    MIDDLE_BOTTOM_LINE_EY-10,    YELLOW};
const RECT LRRCONTROL_TOP    = {RIGHTMOSTFOURTH_SX,   RIGHTMOSTFOURTH_EX,   LOWER_BOTTOM_LINE_SY-10,     LOWER_BOTTOM_LINE_EY-10,     YELLOW};
const RECT LRRCONTROL_MIDDLE = {RIGHTMOSTFOURTH_SX,   RIGHTMOSTFOURTH_EX,   LOWERMOST_TOP_LINE_SY-10,    LOWERMOST_TOP_LINE_EY-10,    YELLOW};
const RECT LRRCONTROL_BOTTOM = {RIGHTMOSTFOURTH_SX+7, RIGHTMOSTFOURTH_EX-7, LOWERMOST_BOTTOM_LINE_SY-10, LOWERMOST_BOTTOM_LINE_EY-10, YELLOW};

const RECT* CONTROLS_TOP[8]    = {&ULLCONTROL_TOP,    &ULCONTROL_TOP,    &URCONTROL_TOP,    &URRCONTROL_TOP,    &LLLCONTROL_TOP,    &LLCONTROL_TOP,    &LRCONTROL_TOP,    &LRRCONTROL_TOP};
const RECT* CONTROLS_MIDDLE[8] = {&ULLCONTROL_MIDDLE, &ULCONTROL_MIDDLE, &URCONTROL_MIDDLE, &URRCONTROL_MIDDLE, &LLLCONTROL_MIDDLE, &LLCONTROL_MIDDLE, &LRCONTROL_MIDDLE, &LRRCONTROL_MIDDLE};
const RECT* CONTROLS_BOTTOM[8] = {&ULLCONTROL_BOTTOM, &ULCONTROL_BOTTOM, &URCONTROL_BOTTOM, &URRCONTROL_BOTTOM, &LLLCONTROL_BOTTOM, &LLCONTROL_BOTTOM, &LRCONTROL_BOTTOM, &LRRCONTROL_BOTTOM};

const RECT ULLCONTROL_IMAGE = {LEFTMOSTFOURTH_SX,  LEFTMOSTFOURTH_EX,  UPPER_BOTTOM_LINE_SY-10, MIDDLE_TOP_LINE_EY-10,    YELLOW};
const RECT LLLCONTROL_IMAGE = {LEFTMOSTFOURTH_SX,  LEFTMOSTFOURTH_EX,  LOWER_BOTTOM_LINE_SY-10, LOWERMOST_TOP_LINE_EY-10, YELLOW};
const RECT ULCONTROL_IMAGE  = {LEFTFOURTH_SX,      LEFTFOURTH_EX,      UPPER_BOTTOM_LINE_SY-10, MIDDLE_TOP_LINE_EY-10,    YELLOW};
const RECT LLCONTROL_IMAGE  = {LEFTFOURTH_SX,      LEFTFOURTH_EX,      LOWER_BOTTOM_LINE_SY-10, LOWERMOST_TOP_LINE_EY-10, YELLOW};
const RECT URCONTROL_IMAGE  = {RIGHTFOURTH_SX,     RIGHTFOURTH_EX,     UPPER_BOTTOM_LINE_SY-10, MIDDLE_TOP_LINE_EY-10,    YELLOW};
const RECT LRCONTROL_IMAGE  = {RIGHTFOURTH_SX,     RIGHTFOURTH_EX,     LOWER_BOTTOM_LINE_SY-10, LOWERMOST_TOP_LINE_EY-10, YELLOW};
const RECT URRCONTROL_IMAGE = {RIGHTMOSTFOURTH_SX, RIGHTMOSTFOURTH_EX, UPPER_BOTTOM_LINE_SY-10, MIDDLE_TOP_LINE_EY-10,    YELLOW};
const RECT LRRCONTROL_IMAGE = {RIGHTMOSTFOURTH_SX, RIGHTMOSTFOURTH_EX, LOWER_BOTTOM_LINE_SY-10, LOWERMOST_TOP_LINE_EY-10, YELLOW};

const RECT* CONTROLS_IMAGE[8] = {&ULLCONTROL_IMAGE, &ULCONTROL_IMAGE, &URCONTROL_IMAGE, &URRCONTROL_IMAGE, &LLLCONTROL_IMAGE, &LLCONTROL_IMAGE, &LRCONTROL_IMAGE, &LRRCONTROL_IMAGE};

const RECT MESSAGEBOX         = {MESSAGEBOX_SX,         MESSAGEBOX_EX,         MESSAGEBOX_SY,         MESSAGEBOX_EY,         MESSAGEBOX_COLOR};
const RECT MESSAGEBOX_LBUTTON = {MESSAGEBOX_LBUTTON_SX, MESSAGEBOX_LBUTTON_EX, MESSAGEBOX_BUTTONS_SY, MESSAGEBOX_BUTTONS_EY, MESSAGEBOX_COLOR};
const RECT MESSAGEBOX_CBUTTON = {MESSAGEBOX_CBUTTON_SX, MESSAGEBOX_CBUTTON_EX, MESSAGEBOX_BUTTONS_SY, MESSAGEBOX_BUTTONS_EY, MESSAGEBOX_COLOR};
const RECT MESSAGEBOX_RBUTTON = {MESSAGEBOX_RBUTTON_SX, MESSAGEBOX_RBUTTON_EX, MESSAGEBOX_BUTTONS_SY, MESSAGEBOX_BUTTONS_EY, MESSAGEBOX_COLOR};

const RECT KEY_1 = {KEY_ROW_2_SX, KEY_ROW_2_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    WHITE};
const RECT KEY_2 = {KEY_ROW_3_SX, KEY_ROW_3_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    WHITE};
const RECT KEY_3 = {KEY_ROW_4_SX, KEY_ROW_4_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    WHITE};
const RECT KEY_M = {KEY_ROW_5_SX, KEY_ROW_5_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    WHITE};
const RECT KEY_B = {KEY_ROW_6_SX, KEY_ROW_6_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    WHITE};
const RECT KEY_C = {KEY_ROW_7_SX, KEY_ROW_7_EX, MIDDLE_LINE_SY,    MIDDLE_LINE_EY,    WHITE};
const RECT KEY_4 = {KEY_ROW_2_SX, KEY_ROW_2_EX, LOWER_LINE_SY,     LOWER_LINE_EY,     WHITE};
const RECT KEY_5 = {KEY_ROW_3_SX, KEY_ROW_3_EX, LOWER_LINE_SY,     LOWER_LINE_EY,     WHITE};
const RECT KEY_6 = {KEY_ROW_4_SX, KEY_ROW_4_EX, LOWER_LINE_SY,     LOWER_LINE_EY,     WHITE};
const RECT KEY_D = {KEY_ROW_5_SX, KEY_ROW_5_EX, LOWER_LINE_SY,     LOWER_LINE_EY,     WHITE};
const RECT KEY_7 = {KEY_ROW_2_SX, KEY_ROW_2_EX, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, WHITE};
const RECT KEY_8 = {KEY_ROW_3_SX, KEY_ROW_3_EX, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, WHITE};
const RECT KEY_9 = {KEY_ROW_4_SX, KEY_ROW_4_EX, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, WHITE};
const RECT KEY_0 = {KEY_ROW_5_SX, KEY_ROW_5_EX, LOWERMOST_LINE_SY, LOWERMOST_LINE_EY, WHITE};

const RECT VALUE = {0, RESOLUTION_X-1, UPPER_LINE_SY, UPPER_LINE_EY, RED};

const char* PARAM_NAMES[] = {"Неизвестно", "Температура", "Влажность", "Давление", "Кислород", "Диокс. углер.", "Окс. углер.", "Водород", "Метан", "Оксид азота", "Скорость потока", "Напряжение", "Темп. управления", "Аккумулятор", "Расход", "Управление O2", "Кол-во частиц (>0.3 мкм)", "Кол-во частиц (>0.5 мкм)", "Кол-во частиц (>5.0 мкм)", "Объем жидкости", "Аммиак", "Сероводород", "Уровень сигнала", "Плотность теплового потока", "ТНС", "Термосопротивление", "Дельта", "Диоксид азота", "Диоксид серы", "Широта", "Долгота", "Тип питания", "", "Состояние", "Измерительный потенциал", "Водородный показатель", "Пользовательский параметр", "Уровень заряда"};
const char* PARAM_TYPES[] = {"?", "T", "H", "P", "Ov2", "COv2", "CO", "Hv2", "CHv4", "NO", "V", "U", "Т упр.", "P", "F", "Ov2", "D>0.3", "D>0.5", "D>5.0", "W", "NHv3", "Hv2S", "S", "F", "ТНС", "R", "D", "NOv2", "SOv2", "N", "W", "Питание", "", "Состояние", "Eп", "pH", "", "B"};
const char* UNIT_TYPES[]  = {"?", "%", "°Cтр", "ppm", "г/м^3", "мг/м^3", "°C", "мм.рт.ст.", "об.%", "атм", "м/с", "В", "кгс/см^2", "%", "м^3/ч", "ед.", "ед.", "ед.", "кПа", "*", "мл", "кг/ч", "Вт/м^2", "°Cвт", "°Cст", "°Cшт", "м^3/с", "°C/Вт", "гПа", "Па", "°", "", "мВ", "бар", "МПа"};

const char* RELAY_CONTROL_TYPES[]   = {"Ручное", "Логическое", "Гистерезис"};
const char* CURRENT_CONTROL_TYPES[] = {"Ручное", "Логическое", "Лин. выход"};
const char* CURRENT_TYPES[] = {"", "", "0..5 мА", "0..20 мА", "4..20 мА"};
const char* LOWER_CURRENTS[] = {"", "", "0 мА", "0 мА", "4 мА"};
const char* UPPER_CURRENTS[] = {"", "", "5 мА", "20 мА", "20 мА"};
const char* END_PROGRAMM_ACTIONS[4][2] = {"Выключить", "управление", "Регулировать", "последнее значение", "Перезапустить", "программу", "Регулировать", "значение по умолчанию"};

const char* DEFPARAM_TYPES[2] = {"Константа", "Параметр"};

const char* THRESHOLD_TYPES[2] = {"Нижний", "Верхний"};
const char* THRESHOLD_WEIGHTS[2] = {"Внимание", "Тревога"};

const char* PRESSURE_TYPES[2] = {"Абсолютное", "Избыточное"};
const char* PRESSURE_INPUTS[3] = {"0..5 мА", "0..20 мА", "4..20 мА"};

const char* RS_SPEEDS[8] = {"1200", "2400", "4800", "9600", "19200", "38400", "57600", "115200"};

void (*draw)  (void);
void (*update)(void);
void (*touch) (void);

Int8U  CurrentMeasuresPage;
Int8U  CurrentDisplay = 255;
Int8U  CurrentParam;
Int8U  CurrentThreshold;
Int8U  CurrentControlsPage;
Int8U  CurrentControl;
Int16U CurrentProgrammStep;

bool BackToAllChannels;

enum CONTROL_SCREEN ControlScreen = csDetail;

Int32U TempTime;

#pragma data_alignment = 4
static U8         buf[512];

// ################################################# TFT ###################################################
/* процедыры упраления TFT ------------------------------------------------------------ */
/* загрузка графической паямяти ТФТ из SD карты  */

// запись комманды
#pragma optimize=none
static inline void  write_tft_command(U16 command)
{ 
  // write command
//  CS_TFT_LOW;  
  RS_TFT_LOW;
  GPIOE->ODR = command;
  WR_TFT_LOW;
  WR_TFT_HIGH;
  RS_TFT_HIGH;
//  CS_TFT_HIGH;   
}

// запись данных    
#pragma optimize=none
static inline void write_tft_data(U16 data)
{  
  // write data
//  CS_TFT_LOW;
  GPIOE->ODR = data;
  WR_TFT_LOW;
  WR_TFT_HIGH;
//  CS_TFT_HIGH;    
}

// чтение данных    
#pragma optimize=none
static inline U16  read_tft_data(void)
{      
  // read data
  GPIOE->MODER = 0;
  
//  CS_TFT_LOW;
  RD_TFT_LOW;  
  __no_operation(); 
  U16   data = GPIOE->IDR;   
  RD_TFT_HIGH; 
//  CS_TFT_HIGH;
  
  GPIOE->MODER = 0x55555555;
      
  return data;
}
/* загрузка графической паямяти ТФТ из SD карты  */
/* подготовка графической памяти к записи или чтению -----------  */
static inline void start_write_GRAM_TFT(void)
{ 
  write_tft_command(0x2c); 
}

//static inline void TFT_Load(pU16 sourceMemory, U32 NumWrites)
static inline void TFT_Load(pU16 sourceMemory, U32 NumWrites)
{
  for(U32 i = 0; i < NumWrites;  i++) write_tft_data( sourceMemory[i]);
}

/* завершение записи в графическую память -----------  */
static inline void stop_write_GRAM_TFT(void)
{ 
  
}

void load_SD_TFT(U32 PixNum, U32 SDaddress)
{ 
  div_t       n;
  U32         i;

  start_write_GRAM_TFT();
  open_SDCard(SDaddress);
  
  n = div(PixNum, 256);

  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard( (pU8)buf, 1);
    TFT_Load((pU16)buf, 256);
  }
  
  if(n.rem)
  {    
    read_opened_SDCard( (pU8)buf, 1);
    TFT_Load((pU16)buf, n.rem);
  }
  
  close_SDCard();
  stop_write_GRAM_TFT();
}

/* скриншортпобери */
void ScreenShoot(U32 SDaddress)
{
  div_t       n;
  U32         i;
  U16         sX = 0, eX = RESOLUTION_X - 1, sY = 0, eY = RESOLUTION_Y - 1;
  
  n = div(RESOLUTION_Y * RESOLUTION_X, 256);  // 1 pix - 2 bytes
  
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  write_tft_command(0x2e);

  for(i = 0; i < n.quot; i++, SDaddress += 512)
  { 
    for(U32 j = 0; j < 256;  j++)  ((pU16)buf)[j] = read_tft_data();    
    errors_flags.sd_fail |= write_SDCard( (pU8)buf, SDaddress, 512);
  } 
}

/* загрузка графической паямяти ТФТ из буффера ------ */
static inline void write_GRAM_TFT(U32 PixNum, pU16 buffer)
{   
  write_tft_command(0x2c);  
  for(U32 i = 0; i < PixNum;  i++) write_tft_data(buffer[i]);
}

/* загрузка графической паямяти ТФТ константой  ------ */
static inline void fill_GRAM_TFT(U32 PixNum, U16 content)
{  
  write_tft_command(0x2c);  
  for(U32 i = 0; i < PixNum;  i++) write_tft_data(content);  
}

// Установка прямоугольной области для записи 
void TFT_SetArea(pInt16U sX, pInt16U eX, pInt16U sY, pInt16U eY)
{
  if (*eX < *sX) *eX = *sX;
  if (*eY < *sY) *eY = *sY;
  
  write_tft_command(0x2A);  //SetColumn
  write_tft_data((*sX >> 8) & 0xFF);  //sX high byte 
  write_tft_data((*sX >> 0) & 0xFF);  //sX low byte      
  write_tft_data((*eX >> 8) & 0xFF);  //sX high byte
  write_tft_data((*eX >> 0) & 0xFF);  //sX low byte 
  
  write_tft_command(0x2B);  //SetPage
  write_tft_data((*sY >> 8) & 0xFF);
  write_tft_data((*sY >> 0) & 0xFF);  
  write_tft_data((*eY >> 8) & 0xFF);
  write_tft_data((*eY >> 0) & 0xFF);  
}

// Запись серии пикселей в прямоугольную область
void TFT_WritePixelsAt(Int16U sX, Int16U eX, Int16U sY, Int16U eY, pInt16U pPixels)
{
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  write_GRAM_TFT((eX - sX + 1)*(eY - sY + 1), pPixels);
}

// Заполнение всего экрана цветом
void TFT_FillScreen(Int16U Color)
{
  Int16U sX, eX, sY, eY;
  sX = 0;
  eX = RESOLUTION_X - 1;
  sY = 0;
  eY = RESOLUTION_Y - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY);
  fill_GRAM_TFT(RESOLUTION_X*RESOLUTION_Y, Color);
}

// Заполнение прямоугольной области цветом
void TFT_FillRect(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U Color)
{
  TFT_SetArea(&sX, &eX, &sY, &eY);
  fill_GRAM_TFT((eX - sX + 1)*(eY - sY + 1), Color);
}

void TFT_FillRect_(RECT rect, Int16U color)
{
  TFT_FillRect(rect.sX, rect.eX, rect.sY, rect.eY, color);
}

void TFT_FillRect_Offset(RECT rect, Int16U color, Int8S x_offset, Int8S y_offset)
{
  TFT_FillRect(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, color);
}

void TFT_FillRect_Shift(RECT rect, Int16U color, Int8S x_shift, Int8S y_shift)
{
  TFT_FillRect(rect.sX + x_shift, rect.eX + x_shift, rect.sY + y_shift, rect.eY + y_shift, color);
}

// Рисует прямоугольник цветом по умолчанию
void TFT_DrawRect(RECT r)
{
  TFT_FillRect(r.sX, r.eX, r.sY, r.eY, r.color);
}

// Рисует прямоугольник заданным цветом
void TFT_DrawRectWithColor(RECT r, Int16U color)
{
  TFT_FillRect(r.sX, r.eX, r.sY, r.eY, color);
}

// Затемняет прямоугольник цветом
void TFT_GrayoutRect(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U color)
{
  for (int y = sY; y <= eY; y += 2)
  {
    TFT_FillRect(sX, eX, y, y, color);
  }
}

void TFT_GrayoutRect_(RECT rect, Int16U color)
{
  TFT_GrayoutRect(rect.sX, rect.eX, rect.sY, rect.eY, color);
}

void TFT_UnderlineRect_Offset(RECT rect, Int16U color, Int8U line, Int8S x_offset, Int8S y_offset)
{
  TFT_FillRect(rect.sX + x_offset, rect.eX - x_offset, rect.eY - line - y_offset + 1, rect.eY - y_offset, color);
}

// Рисует прямоугольник со скруглёнными углами
void TFT_DrawRoundedRect(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U head_color, Int16U body_color, Int16U back_color)
{
  if ((eX - sX < 70) || (eY - sY < 70)) return;
  
  TFT_FillRect(sX, eX, sY, eY, body_color);
  TFT_FillRect(sX, eX, sY, sY+34-1, head_color);
  
  GUI_DrawImageSwapTwoColors(ULCORNER_34x34, sX, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  GUI_DrawImageSwapTwoColors(URCORNER_34x34, eX-34+1, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  GUI_DrawImageSwapTwoColors(DLCORNER_34x34, sX, eY-34+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
  GUI_DrawImageSwapTwoColors(DRCORNER_34x34, eX-34+1, eY-34+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
}

void TFT_DrawRoundedRectEx(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U head_color, Int16U body_color, Int16U back_color, Int8U rects_mask)
{
  if ((eX - sX < 70) || (eY - sY < 70)) return;
  
  TFT_FillRect(sX, eX, sY, eY, body_color);
  TFT_FillRect(sX, eX, sY, sY+34-1, head_color);
  
  if (rects_mask & 1) GUI_DrawImageSwapTwoColors(ULCORNER_34x34, sX, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  if (rects_mask & 2) GUI_DrawImageSwapTwoColors(URCORNER_34x34, eX-34+1, sY, TEMPLATE_COLOR, head_color, WHITE, back_color);
  if (rects_mask & 4) GUI_DrawImageSwapTwoColors(DRCORNER_34x34, eX-34+1, eY-34+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
  if (rects_mask & 8) GUI_DrawImageSwapTwoColors(DLCORNER_34x34, sX, eY-34+1, TEMPLATE_COLOR, body_color, WHITE, back_color);
}

// Рисует прямоугольник со скруглёнными углами
void TFT_DrawRoundedRect_(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color)
{
  TFT_DrawRoundedRect(rect.sX, rect.eX, rect.sY, rect.eY, head_color, body_color, back_color);
}

void TFT_DrawRoundedRectEx_(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8U rects_mask)
{
  TFT_DrawRoundedRectEx(rect.sX, rect.eX, rect.sY, rect.eY, head_color, body_color, back_color, rects_mask);
}

void TFT_DrawRoundedRect_TwoColored(RECT rect, Int16U top_color, Int16U bottom_color, Int16U back_color)
{
  TFT_DrawRoundedRect(rect.sX, rect.eX, rect.sY, rect.eY, top_color, bottom_color, back_color);
  Int16U top_eY = (rect.eY - rect.sY)/2;
  TFT_FillRect(rect.sX, rect.eX, rect.sY+34, top_eY, top_color);
}

void TFT_DrawRoundedRect_Offset(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8S x_offset, Int8S y_offset)
{
  TFT_DrawRoundedRect(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, head_color, body_color, back_color);
}

void TFT_DrawRoundedRect_OffsetWithImageAndCaption(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8S x_offset, Int8S y_offset, U32 image_index, char* caption)
{
  TFT_DrawRoundedRect_Offset(rect, head_color, body_color, back_color, x_offset, y_offset);
  if (image_index != 255)
  {
    GUI_DrawImageSwapColor(image_index, rect.sX + 25 + x_offset, rect.sY + y_offset, TEMPLATE_COLOR, head_color);
    TFT_WriteString(caption, BLACK, head_color, rect.sX + 25 + x_offset + 34 + 3, rect.sY + y_offset, &Tahoma34);
  }
  else
  {
    int width = TFT_StringWidth(caption, &Tahoma34);
    TFT_WriteString(caption, BLACK, head_color, abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset, rect.sY + y_offset, &Tahoma34);
  }
}

void TFT_DrawRoundedRectEx_Offset(RECT rect, Int16U head_color, Int16U body_color, Int16U back_color, Int8S x_offset, Int8S y_offset, Int8U rects_mask)
{
  TFT_DrawRoundedRectEx(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, head_color, body_color, back_color, rects_mask);
}

void TFT_DrawBorder(Int16U sX, Int16U eX, Int16U sY, Int16U eY, Int16U width, Int16U color)
{
  if (!width) return;
  
  width--;
  TFT_FillRect(sX, eX, sY, sY + width, color);
  TFT_FillRect(eX - width, eX, sY, eY, color);
  TFT_FillRect(sX, eX, eY - width, eY, color);
  TFT_FillRect(sX, sX + width, sY, eY, color);
}

void TFT_DrawBorder_(RECT rect, Int16U width, Int16U color)
{
  TFT_DrawBorder(rect.sX, rect.eX, rect.sY, rect.eY, width, color);
}

void TFT_DrawBorder_WithOffset(RECT rect, Int16U width, Int16U color, Int8S x_offset, Int8S y_offset)
{
  TFT_DrawBorder(rect.sX + x_offset, rect.eX - x_offset, rect.sY + y_offset, rect.eY - y_offset, width, color);
}

// Вывод символа на экран
void TFT_WriteChar(const tImage* ch, Int16U FontColor, Int16U BackColor, Int16U sX, Int16U sY)
{
  const Int8U *data;
  data = (*ch).data;
  
  Int16U eX, eY;
  eX = sX + (*ch).width - 1;
  eY = sY + (*ch).height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  
  start_write_GRAM_TFT();
  for (int i = 0; i < (*ch).height; i++)
    for (int j = 0; j < (*ch).width; j++)
    {
      U16 data_bytes_count = ((*ch).width-1)/8 + 1;
      U16 data_byte_number = i*data_bytes_count + j/8;
      U8 offset = 7 - (j%8);
      switch ((data[data_byte_number] >> offset) & 1)
      {
        case 0: TFT_Load(&BackColor, 1); break;
        case 1: TFT_Load(&FontColor, 1); break;
      }
    }
  stop_write_GRAM_TFT();
}

const tImage* TFT_GetCharacterImage(char code, const tFont* Font)
{
  for (int i = 0; i < Font->length; i++)
  {
    if (code == Font->chars[i].code)
    {
      return Font->chars[i].image;
    }
  }
  
  return NULL;
}

// Вывод строки на экран
RECT TFT_WriteString(char* st, Int16U FontColor, Int16U BackColor, Int16U sX, Int16U sY, const tFont* Font)
{
  RECT actual_text_rect = {sX, sX + TFT_StringWidth(st, Font) - 1, sY, sY + TFT_StringHeight(st, Font) - 1, BackColor};

  const tImage* ch = NULL;
  const tFont* font_;
  Int16U sY_;
  while (*st)
  {
    font_ = Font;
    sY_ = sY;
    if ((*st == '^') && (font_ != &Tahoma22))
    {
      if (font_ == &Tahoma34) font_ = &Tahoma22;
      if (font_ == &Tahoma87) font_ = &Tahoma34;
      st++;
    }
    
    if ((*st == 'v') && (font_ != &Tahoma22))
    {
      int height = TFT_StringHeight(st, font_);
      if (font_ == &Tahoma34) font_ = &Tahoma22;
      if (font_ == &Tahoma87) font_ = &Tahoma34;
      sY_ = sY + height - TFT_StringHeight(st, font_);
      st++;
    }
    
    /*for (int i = 0; i < (*font_).length; i++)
      if (*st == (*font_).chars[i].code)
      {
        ch = (*font_).chars[i].image;
      }*/
    ch = TFT_GetCharacterImage(*st, font_);
    if (!ch) goto end;

    // Замазывать под верхним индексом    
    if (font_ != Font)
    {
      const tImage* originalFontChar = TFT_GetCharacterImage(*st, Font);
      TFT_FillRect(sX, sX+originalFontChar->width, sY, sY+originalFontChar->height, BackColor);
    }
    
    TFT_WriteChar(ch, FontColor, BackColor, sX, sY_);
    sX += (*ch).width;
    
end:
    st++;
  }
  
  return actual_text_rect;
}

RECT TFT_WriteStringInRectCenter(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U width, height, sX, sY;
  width = TFT_StringWidth(st, Font);
  height = TFT_StringHeight(st, Font);
  sX = abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height/2) + y_offset;
  
  return TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

RECT TFT_WriteStringInRectCenterInTwoLines(char* line1, char* line2, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  if (strlen(line2) == 0)
  {
    return TFT_WriteStringInRectCenter(line1, FontColor, BackColor, rect, x_offset, y_offset, Font);
  }
  
  Int16U width, height, sX, sY;
  
  width = TFT_StringWidth(line1, Font);
  height = TFT_StringHeight(line1, Font);
  sX = abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height) + y_offset;
  RECT actual_text1_rect = TFT_WriteString(line1, FontColor, BackColor, sX, sY, Font);
  
  width = TFT_StringWidth(line2, Font);
  height = TFT_StringHeight(line2, Font);
  sX = abs((rect.sX + rect.eX + 1)/2 - width/2) + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2) + y_offset;
  RECT actual_text2_rect = TFT_WriteString(line2, FontColor, BackColor, sX, sY, Font);
  
  RECT actual_text_rect = {actual_text1_rect.sX < actual_text2_rect.sX ? actual_text1_rect.sX : actual_text2_rect.sX, actual_text1_rect.eX > actual_text2_rect.eX ? actual_text1_rect.eX : actual_text2_rect.eX, actual_text1_rect.sY, actual_text2_rect.eY, BackColor};
  return actual_text_rect;
}

RECT TFT_WriteStringInRectLeft(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U height, sX, sY;
  height = TFT_StringHeight(st, Font);
  sX = rect.sX + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height/2) + y_offset;
  
  return TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

RECT TFT_WriteStringInRectLeftInTwoLines(char* line1, char* line2, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  if (strlen(line2) == 0)
  {
    return TFT_WriteStringInRectLeft(line1, FontColor, BackColor, rect, x_offset, y_offset, Font);
  }
  
  Int16U height, sX, sY;
  
  height = TFT_StringHeight(line1, Font);
  sX = rect.sX + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2 - height) + y_offset;
  RECT actual_text1_rect = TFT_WriteString(line1, FontColor, BackColor, sX, sY, Font);
  
  height = TFT_StringHeight(line2, Font);
  sX = rect.sX + x_offset;
  sY = abs((rect.sY + rect.eY + 1)/2) + y_offset;
  RECT actual_text2_rect = TFT_WriteString(line2, FontColor, BackColor, sX, sY, Font);
  
  RECT actual_text_rect = {actual_text1_rect.sX, actual_text1_rect.eX > actual_text2_rect.eX ? actual_text1_rect.eX : actual_text2_rect.eX, actual_text1_rect.sY, actual_text2_rect.eY, BackColor};
  return actual_text_rect;
}

RECT TFT_WriteStringInRectRight(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U width, height, sX, sY;
  width = TFT_StringWidth(st, Font);
  height = TFT_StringHeight(st, Font);
  sX = rect.eX - width - x_offset - 1;
  sY = abs((rect.sY + rect.eY + 1)/2 - height/2) + y_offset;
  
  return TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

RECT TFT_WriteStringInRectRightHighCorner(char* st, Int16U FontColor, Int16U BackColor, RECT rect, Int8S x_offset, Int8S y_offset, const tFont* Font)
{
  Int16U width, sX, sY;
  width = TFT_StringWidth(st, Font);
  // height = TFT_StringHeight(st, Font);
  sX = rect.eX - width - x_offset - 1;
  sY = rect.sY + y_offset;
  
  return TFT_WriteString(st, FontColor, BackColor, sX, sY, Font);
}

void TFT_SmartWriteStringInRectCenter(char* string, Int16U fontColor, Int16U backColor, RECT* rect, const tFont* font)
{
  Int16U stringWidth  = TFT_StringWidth (string, font);
  Int16U stringHeight = TFT_StringHeight(string, font);
  Int16U string_sX = abs((rect->sX + rect->eX + 1)/2 - stringWidth/2);
  Int16U string_sY = abs((rect->sY + rect->eY + 1)/2 - stringHeight/2);
  RECT stringRect = {string_sX, string_sX + stringWidth - 1, string_sY, string_sY + stringHeight - 1, backColor};
  
  RECT left_rect  = {rect->sX,          stringRect.sX - 1, rect->sY, rect->eY, backColor};
  RECT right_rect = {stringRect.eX + 1, rect->eX,          rect->sY, rect->eY, backColor};
  
  TFT_DrawRect(left_rect);
  TFT_WriteString(string, fontColor, backColor, stringRect.sX, stringRect.sY, font);
  TFT_DrawRect(right_rect);
}

void TFT_SmartWriteStringInRectCenter_Offset(char* string, Int16U fontColor, Int16U backColor, RECT* rect, Int8S x_offset, Int8S y_offset, const tFont* font)
{
  RECT offsetRect = {rect->sX + x_offset, rect->eX + x_offset, rect->sY + y_offset, rect->eY + y_offset, rect->color};
  
  TFT_SmartWriteStringInRectCenter(string, fontColor, backColor, &offsetRect, font);
}

void GUI_SmartWriteBigMeasureInRectCenter(char* value, Int16U valueColor, char* units, Int16U unitsColor, RECT* rect, Int16U backColor)
{
  Int16U valueWidth  = TFT_StringWidth (value, &Tahoma87);
  Int16U valueHeight = TFT_StringHeight(value, &Tahoma87);
  Int16U value_sX = abs((rect->sX + rect->eX + 1)/2 - valueWidth/2);
  Int16U value_sY = abs((rect->sY + rect->eY + 1)/2 - valueHeight/2);
  RECT valueRect = {value_sX, value_sX + valueWidth - 1, value_sY, value_sY + valueHeight - 1, backColor};

  Int16U unitsWidth  = TFT_StringWidth (units, &Tahoma34);
  Int16U unitsHeight = TFT_StringHeight(units, &Tahoma34);
  Int16U units_sX = valueRect.eX+11;
  Int16U units_sY = valueRect.sY;
  if (DeviceName[0]=='М')
  {
    units_sY += 34;
  }
  RECT unitsRect = {units_sX, units_sX + unitsWidth - 1, units_sY, units_sY + unitsHeight - 1, backColor};

  RECT left_rect       = {rect->sX,         valueRect.sX - 1, rect->sY,         rect->eY,     backColor};
  RECT center_rect     = {valueRect.eX + 1, unitsRect.sX - 1, rect->sY,         rect->eY,     backColor};
  RECT underunits_rect = {unitsRect.sX,     unitsRect.eX,     unitsRect.eY + 1, valueRect.eY, backColor};
  RECT right_rect      = {unitsRect.eX + 1, rect->eX,         rect->sY,         rect->eY,     backColor};
  
  TFT_DrawRect(left_rect);
  TFT_WriteString(value, valueColor, backColor, valueRect.sX, valueRect.sY, &Tahoma87);
  TFT_DrawRect(center_rect);
  TFT_DrawRect(underunits_rect);
  TFT_WriteString(units, unitsColor, backColor, unitsRect.sX, unitsRect.sY, &Tahoma34);
  TFT_DrawRect(right_rect);
}

// для терминального вывода
void TFT_WriteStringT(pU8 st)
{
  U8      fY;
  
  fY=45;
  if ((TFT_String.Y + fY) > RESOLUTION_Y) TFT_String.Y = 0;
  TFT_WriteString(st, TFT_String.fColor, TFT_String.bColor, 0, TFT_String.Y, TFT_String.fontType);
  TFT_String.Y += fY;
}

// Вычисляет ширину строки
int TFT_StringWidth(char* st, const tFont* Font)
{
  int width = 0;
  
  const tFont* font_ = Font;
  while (*st)
  {
    if ((*st == 'v') && (font_ != &Tahoma22))
    {
      if (font_ == &Tahoma34) font_ = &Tahoma22;
      if (font_ == &Tahoma87) font_ = &Tahoma34;
      st++;
      continue;
    }
    
    if ((*st == '^') && (font_ != &Tahoma22))
    {
      if (font_ == &Tahoma34) font_ = &Tahoma22;
      if (font_ == &Tahoma87) font_ = &Tahoma34;
      st++;
      continue;
    }
    
    for (int i = 0; i < (*font_).length; i++)
      if (*st == (*font_).chars[i].code)
      {
        width += (*(*font_).chars[i].image).width;
        break;
      }
    
    st++;
    font_ = Font;
  }
  
  return width;
}

int TFT_StringHeight(char* st, const tFont* Font)
{
  return (*(*Font).chars[0].image).height;
}

// Ждёт, пока пользователь нажмёт на экран и возвращает координаты
void TFT_WaitForCoords(Int16U* X, Int16U* Y)
{
  Int32U Coords = 0;
  OS_GetMail(&TouchPad_MB, &Coords);
  *X = Coords & 0xFFFF;
  *Y = Coords >> 16;
}

// Проверяет, трогал ли пользователь экран, и возвращает координаты
bool TFT_Touched(Int16U* X, Int16U* Y)
{
  Int32U Coords = 0;
  *X = 65535;
  *Y = 65535;
  if (OS_GetMailCond(&TouchPad_MB, &Coords)) return false;
  
  //OS_ClearMB(&TouchPad_MB);
  *X = Coords & 0xFFFF;
  *Y = Coords >> 16;  
  return true;
}

// Проверяет, нажали пользователь кнопку
Int8U TFT_Pressed()
{
  Int8U button;
  if (OS_GetMailCond(&Key_MB, &button)) return NOT_PRESSED;
  else                                  return button;
}

// Проверяет попадание координат в прямоугольную область
bool TFT_CoordsInRect(Int16U X, Int16U Y, RECT r)
{
  if ((X > r.sX) && (X < r.eX) && (Y > r.sY) && (Y < r.eY))
  {
    OS_ClearMB(&TouchPad_MB);
    return true;
  }
  else
  {
    return false;
  }
}

#pragma optimize=none
// Рисует картинку по адресу
void TFT_DrawImage(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY); 

  load_SD_TFT(width*height, (U32)data_addr);
}

// Рисует картинку по адресу и заменяет пиксели color_to_swap на color
void TFT_DrawImageSwapColor(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height, Int16U color_to_swap, Int16U color)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY);

  Int16U p;
  div_t  n;
  U32    i, j;  
  
  start_write_GRAM_TFT();
  open_SDCard((U32)data_addr);
  n = div(width*height, 256);
  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < 512; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color_to_swap) p = color;
      TFT_Load(&p, 1);
    }
  }
  if(n.rem)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < n.rem*2; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color_to_swap) p = color;
      TFT_Load(&p, 1);
    }
  }
  close_SDCard();
  stop_write_GRAM_TFT();
}

// Рисует картинку по адресу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2
void TFT_DrawImageSwapTwoColors(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY);
  
  Int16U p;
//  U8     buf[512];
  div_t  n;
  U32    i, j;  
  
  start_write_GRAM_TFT();
  open_SDCard((U32)data_addr);
  n = div(width*height, 256);
  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < 512; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;
      TFT_Load(&p, 1);
    }
  }
  if(n.rem)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < n.rem*2; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;      
      TFT_Load(&p, 1);
    }
  }
  close_SDCard();
  stop_write_GRAM_TFT();
}

// Рисует картинку по адресу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2 и color3_to_swap на color3
void TFT_DrawImageSwapThreeColors(Int32U* data_addr, Int16U sX, Int16U sY, Int16U width, Int16U height, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2, Int16U color3_to_swap, Int16U color3)
{
  Int16U eX, eY;
  eX = sX + width - 1;
  eY = sY + height - 1;
  TFT_SetArea(&sX, &eX, &sY, &eY); 
  
  Int16U p;
//  U8     buf[512];
  div_t  n;
  U32    i, j;  
  
  start_write_GRAM_TFT();
  open_SDCard((U32)data_addr);
  n = div(width*height, 256);
  for(i = 0; i < n.quot; i++)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < 512; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;
      if (p == color3_to_swap) p = color3;
      TFT_Load(&p, 1);
    }
  }
  if(n.rem)
  {    
    read_opened_SDCard((pU8)buf, 1);
    
    for (j = 0; j < n.rem*2; j+=2)
    {
      p = *((Int16U*)&buf[j]);
      if (p == color1_to_swap) p = color1;
      if (p == color2_to_swap) p = color2;
      if (p == color3_to_swap) p = color3;
      TFT_Load(&p, 1);
    }
  }
  close_SDCard();
  stop_write_GRAM_TFT();
}

// Рисует новое окно с сообщением и кнопками
void TFT_DrawMessageBox(char* caption, char* line1, char* line2, char* line3, Int8U type, Int16U background_color)
{
  TFT_GrayoutRect_(SCREEN, background_color);
  TFT_DrawRoundedRectEx_(MESSAGEBOX, MESSAGEBOX_HEAD_COLOR, MESSAGEBOX_COLOR, background_color, 0);
  
  TFT_WriteString(caption, BLACK, MESSAGEBOX_HEAD_COLOR, MESSAGEBOX_CAPTION_SX, MESSAGEBOX_CAPTION_SY, &Tahoma34);
  TFT_WriteString(line1, BLACK, MESSAGEBOX_COLOR, MESSAGEBOX_LINES_SX, MESSAGEBOX_LINE1_SY, &Tahoma34);
  TFT_WriteString(line2, BLACK, MESSAGEBOX_COLOR, MESSAGEBOX_LINES_SX, MESSAGEBOX_LINE2_SY, &Tahoma34);
  TFT_WriteString(line3, BLACK, MESSAGEBOX_COLOR, MESSAGEBOX_LINES_SX, MESSAGEBOX_LINE3_SY, &Tahoma34);   
  
  switch (type)
  {
  case MESSAGEBOX_OK:
    GUI_DrawImageInRectCenterSwapColor(OK_60x60, MESSAGEBOX_CBUTTON, TEMPLATE_COLOR, MESSAGEBOX_COLOR);
    break;
    
  case MESSAGEBOX_YESNO:
    GUI_DrawImageInRectCenterSwapColor(OK_60x60, MESSAGEBOX_LBUTTON, TEMPLATE_COLOR, MESSAGEBOX_COLOR);
    GUI_DrawImageInRectCenterSwapColor(CANCEL_60x60, MESSAGEBOX_RBUTTON, TEMPLATE_COLOR, MESSAGEBOX_COLOR);
    break;
  }
}

void TFT_DrawKeyboard(char* topic, char* title, bool is_unsigned, bool is_float, bool is_ip)
{
  GUI_DrawHeaderWide(OK_60x60, true, topic, title);

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  TFT_DrawRoundedRect_Offset(KEY_1, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("1", BLACK, ODD_GREEN, KEY_1, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_2, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("2", BLACK, ODD_GREEN, KEY_2, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_3, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("3", BLACK, ODD_GREEN, KEY_3, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_4, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("4", BLACK, ODD_GREEN, KEY_4, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_5, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("5", BLACK, ODD_GREEN, KEY_5, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_6, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("6", BLACK, ODD_GREEN, KEY_6, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_7, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("7", BLACK, ODD_GREEN, KEY_7, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_8, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("8", BLACK, ODD_GREEN, KEY_8, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_9, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("9", BLACK, ODD_GREEN, KEY_9, 0, 0, &Tahoma87);
  TFT_DrawRoundedRect_Offset(KEY_0, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("0", BLACK, ODD_GREEN, KEY_0, 0, 0, &Tahoma87);
  if (is_float || is_ip)
  {
    TFT_DrawRoundedRect_Offset(KEY_D, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
    TFT_WriteStringInRectCenter(".", BLACK, ODD_GREEN, KEY_D, 0, 0, &Tahoma87);
  }
  if (!is_unsigned && !is_ip)
  {
    TFT_DrawRoundedRect_Offset(KEY_M, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
    //TFT_WriteStringInRectCenter("±", BLACK, ODD_GREEN, KEY_M, 0, 0, &Tahoma87);
    TFT_WriteStringInRectCenter("-", BLACK, ODD_GREEN, KEY_M, 0, 0, &Tahoma87);
  }
  TFT_DrawRoundedRect_Offset(KEY_B, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  GUI_DrawImageInRectCenterSwapColor(DELETE_30x30, KEY_B, TEMPLATE_COLOR, ODD_GREEN);
  TFT_DrawRoundedRect_Offset(KEY_C, ODD_GREEN, ODD_GREEN, BACKGROUND_COLOR, 1, 1);
  TFT_WriteStringInRectCenter("C", RED, ODD_GREEN, KEY_C, -5, 0, &Tahoma87);
}

// Рисует картинку по индексу
void GUI_DrawImage(U32 image_index, Int16U sX, Int16U sY)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImage(data_addr, sX, sY, width, height);
}

// Рисует картинку по индексу и заменяет пиксели color_to_swap на color
void GUI_DrawImageSwapColor(U32 image_index, Int16U sX, Int16U sY, Int16U color_to_swap, Int16U color)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapColor(data_addr, sX, sY, width, height, color_to_swap, color);
}

// Рисует картинку по индексу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2
void GUI_DrawImageSwapTwoColors(U32 image_index, Int16U sX, Int16U sY, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapTwoColors(data_addr, sX, sY, width, height, color1_to_swap, color1, color2_to_swap, color2);
}

// Рисует картинку по индексу и заменяет пиксели color1_to_swap на color1 и color2_to_swap на color2 и color3_to_swap на color3
void GUI_DrawImageSwapThreeColors(U32 image_index, Int16U sX, Int16U sY, Int16U color1_to_swap, Int16U color1, Int16U color2_to_swap, Int16U color2, Int16U color3_to_swap, Int16U color3)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapThreeColors(data_addr, sX, sY, width, height, color1_to_swap, color1, color2_to_swap, color2, color3_to_swap, color3);
}

// Рисует картинку в прямоугольнике
void GUI_DrawImageInRect(U32 image_index, RECT rect)
{
  GUI_DrawImage(image_index, rect.sX, rect.sY);
}

// Рисует картинку по центру прямоугольника и замещает цвет
void GUI_DrawImageInRectCenterSwapColor(U32 image_index, RECT rect, Int16U color_to_swap, Int16U color)
{
  Int16U width, height;
  Int32U *data_addr;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  width = *((Int16U*)&buf[descriptor_addr%512+4]);
  height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((width > RESOLUTION_X) || (height > RESOLUTION_Y)) return;

  TFT_DrawImageSwapColor(data_addr, rect.sX + (rect.eX - rect.sX)/2 - width/2, rect.sY + (rect.eY - rect.sY)/2 - height/2, width, height, color_to_swap, color);
}

void GUI_DrawImageInRectCenterSwapColor_Shift(U32 image_index, RECT rect, Int16U color_to_swap, Int16U color, Int8S x_shift, Int8S y_shift)
{
  rect.sX += x_shift;
  rect.eX += x_shift;
  rect.sY += y_shift;
  rect.eY += y_shift;
  GUI_DrawImageInRectCenterSwapColor(image_index, rect, color_to_swap, color);
}

void GUI_DrawTextAndImageInRectCenter(char* st, Int16U FontColor, Int16U BackColor, const tFont* font, U32 image_index, RECT rect, Int16U color_to_swap, Int16U color)
{
  Int16U image_width, image_height, text_width, text_height;
  Int32U *data_addr;
  Int16U sX, sY;
  Int32U descriptor_addr;

  if (image_index > MAX_IMAGES - 1) return;

  descriptor_addr = IMAGE_INFO_ADDR + image_index*IMAGE_INFO_SIZE;
  open_SDCard(descriptor_addr - descriptor_addr%512);
  read_opened_SDCard(buf, 1);
  close_SDCard();
  
  data_addr = (Int32U*)(IMAGE_INFO_HEADER_SIZE + *((Int32U*)&buf[descriptor_addr%512+0]));
  image_width = *((Int16U*)&buf[descriptor_addr%512+4]);
  image_height = *((Int16U*)&buf[descriptor_addr%512+8]);

  if ((image_width > RESOLUTION_X) || (image_height > RESOLUTION_Y)) return;
  
  text_width  = TFT_StringWidth(st, font);
  text_height = TFT_StringHeight(st, font);
  sX = rect.sX + (rect.eX - rect.sX)/2 - (text_width+image_width)/2;
  sY = rect.sY + (rect.eY - rect.sY)/2 - text_height/2;
  TFT_WriteString(st, FontColor, BackColor, sX, sY, font);
  
  sX = rect.sX + (rect.eX - rect.sX)/2 - (text_width+image_width)/2;
  sX = sX + text_width;
  sY = rect.sY + (rect.eY - rect.sY)/2 - image_height/2;
  TFT_DrawImageSwapColor(data_addr, sX, sY, image_width, image_height, color_to_swap, color);
}

// Выводит сообщение в новом окне с одной или двумя кнопками с таймаутом в секундах (0 - без такового)
bool GUI_MessageBox(char* caption, char* line1, char* line2, char* line3, Int8U timeout, Int8U type, Int16U background_color)
{
  TFT_DrawMessageBox(caption, line1, line2, line3, type, background_color);
  OS_ClearMB(&TouchPad_MB);
  
  Int16U X, Y;
  Int8U button;
  int elapsed = 0;
  while ((elapsed <= timeout*1000) || (timeout == 0))
  {
    if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED))
    {
      OS_Delay(50);
      elapsed += 50;
      continue;
    }
    
    switch (type)
    {
    case MESSAGEBOX_OK:
      if (TFT_CoordsInRect(X, Y, MESSAGEBOX_CBUTTON))
      {
        set_sound(S_SOUND_20);
        return true;
      }
      break;
      
    case MESSAGEBOX_YESNO:
      if (TFT_CoordsInRect(X, Y, MESSAGEBOX_LBUTTON))
      {
        set_sound(S_SOUND_20);
        return true;
      }
      if (TFT_CoordsInRect(X, Y, MESSAGEBOX_RBUTTON))
      {
        set_sound(S_SOUND_20);
        return false;
      }
      if (button == BACK_BUTTON)
      {
        set_sound(S_SOUND_20);
        return false;
      }
      break;
    }
  }
  
  return false;
}

// Удаляет i-ый символ из стоки
void strdel(char *st, int i)
{
  for (int j = i; j < strlen(st) - 1 ; j++) st[j] = st[j+1];
  st[strlen(st)-1] = 0;
}

void strdel_(char *st, char c)
{
  for (int i = 0; i < strlen(st) - 1 ; i++)
    if (st[i] == c)
      strdel(st, i);
}

// Вставляет символ c на i-ую позицию в строке
void strinsert(char *st, char c, int i)
{
  int new_lenght = strlen(st) + 1;
  for (int j = strlen(st); j > i; j--) st[j] = st[j-1];
  st[i] = c;
  st[new_lenght] = 0;
}

int charcount(char *st, char c)
{
  int count = 0;
  
  for (int i = 0; i < strlen(st); i++)
    if (st[i] == c)
      count++;
  
  return count;
}

bool GUI_KeyboardChar(char* value, char* topic, char* title, bool is_unsigned, bool is_float, bool is_ip)
{
  TFT_DrawKeyboard(topic, title, is_unsigned, is_float, is_ip);
  OS_ClearMB(&TouchPad_MB);
  
  char display[20];
  Int16U X, Y;
  Int8U button;
  while (1)
  {
    if (!is_ip)
    {
      if (value[0] == '0')
        if ((value[1] != '.') && (value[1] != 0))
          strdel(value, 0);
      if (value[0] == '-')
        if (value[1] == '0')
          if ((value[2] != '.') && (value[2] != 0))
            strdel(value, 1);
      if (strlen(value) > 10)
        value[10] = 0;
    }
    if (is_ip)
    {
      if (value[0] == '0')
        if ((value[1] != '.') && (value[1] != 0))
          strdel(value, 0);
      if (strlen(value) > 16)
        value[16] = 0;
    }
    
    sprintf(display, "%s", value);
    TFT_WriteStringInRectCenter(display, BLACK, BACKGROUND_COLOR, VALUE, 0, 0, &Tahoma87);
    
    button = TFT_Pressed();
    if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED))
    {
      GUI_UpdateHeaderWide();
      if( OS_WaitSingleEventTimed(1, 50) ) 
      {
        OS_SignalEvent( 1, &OS_TFT);
        return false;
      }
      continue;
    }
    
    if (TFT_CoordsInRect(X, Y, KEY_1)) {sprintf(value, "%s%c", value, '1'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_2)) {sprintf(value, "%s%c", value, '2'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_3)) {sprintf(value, "%s%c", value, '3'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_4)) {sprintf(value, "%s%c", value, '4'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_5)) {sprintf(value, "%s%c", value, '5'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_6)) {sprintf(value, "%s%c", value, '6'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_7)) {sprintf(value, "%s%c", value, '7'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_8)) {sprintf(value, "%s%c", value, '8'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_9)) {sprintf(value, "%s%c", value, '9'); set_sound(S_SOUND_20);}
    if (TFT_CoordsInRect(X, Y, KEY_0)) {sprintf(value, "%s%c", value, '0'); set_sound(S_SOUND_20);}
    
    if (is_float)
      if (TFT_CoordsInRect(X, Y, KEY_D))
      {
        if (memchr(value, '.', strlen(value)) == NULL)
        {
          sprintf(value, "%s%c", value, '.');
          set_sound(S_SOUND_20);
        }
      }
    
    if (is_ip)
      if (TFT_CoordsInRect(X, Y, KEY_D))
        if (charcount(value, '.') < 3)
        {
          sprintf(value, "%s%c", value, '.');
          set_sound(S_SOUND_20);
        }
    
    if (!is_unsigned)
      if (TFT_CoordsInRect(X, Y, KEY_M))
      {
        if (value[0] != '-')
        {
          strinsert(value, '-', 0);
        }
        else
        {
          strdel(value, 0);
          TFT_FillRect_(VALUE, BACKGROUND_COLOR);
        }
        set_sound(S_SOUND_20);
      }
    
    if (TFT_CoordsInRect(X, Y, KEY_B))
    {
      if (value[0] == '-')
      {
        if (strlen(value) > 2)
          value[strlen(value)-1] = 0;
        else
          sprintf(value, "-0");
      }
      else
      {
        if (strlen(value) > 1)
          value[strlen(value)-1] = 0;
        else
          sprintf(value, "0");
      }
      TFT_FillRect_(VALUE, BACKGROUND_COLOR);
      set_sound(S_SOUND_20);
    }
    
    if (TFT_CoordsInRect(X, Y, KEY_C))
    {
      sprintf(value, "0");
      TFT_FillRect_(VALUE, BACKGROUND_COLOR);
      set_sound(S_SOUND_20);
    }
    
    if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
    {
      set_sound(S_SOUND_20);
      return true;
    }
    if (button == BACK_BUTTON)
    {
      set_sound(S_SOUND_20);
      return false;
    }
  }
}

bool GUI_KeyboardInt(int* value, char* topic, char* title, bool is_unsigned, int min, int max)
{
  char _int[20];
  sprintf(_int, "%d", *value);
  if (!GUI_KeyboardChar(_int, topic, title, is_unsigned, false, false))
    return false;
  
  sscanf(_int, "%d", value);
  if ((min != 0) || (max != 0))
  {
    if (*value < min) *value = min;
    if (*value > max) *value = max;
  }
  return true;
}

bool GUI_KeyboardFloat(float* value, char* topic, char* title, bool is_unsigned, float min, float max, int decimal)
{
  char _float[20];
  sprintf(_float, "%.*f", decimal, *value);
  if (!GUI_KeyboardChar(_float, topic, title, is_unsigned, decimal != 0, false))
    return false;
  
  sscanf(_float, "%f", value);
  if ((min != 0) || (max != 0))
  {
    if (*value < min) *value = min;
    if (*value > max) *value = max;
  }
  return true;
}

bool GUI_KeyboardIP(Int32U* value, char* topic, char* title)
{
  char ip[32];
  ParseIPAddress(*value, ip);
  if (!GUI_KeyboardChar(ip, topic, title, true, false, true))
    return false;
  
  if (charcount(ip, '.')  !=  3)
    return false;
  
  PackIPAddress(value, ip);
  return true;
}

void GUI_ShowNotification()
{
}

// Устанавливает функции графического пользовательского интерфейса
void GUI_SetGUI(void (*draw_function)(void), void (*update_function)(void), void (*touch_function)(void))
{
  draw   = draw_function;
  update = update_function;
  touch  = touch_function;
  
  if (draw) draw();
}

// Позволяет откалибровать тач-панель
void GUI_CalibTouch()
{  
  F32       new_TFT_Calib[2][2];
  U16       X, Y;
  U16       x[4], y[4];
  U16       xL, xR, yU, yD;
  
  OS_Use(&SemaRAM);
  system_flags.touch_calib = 1;
  OS_Unuse(&SemaRAM);
  
  TFT_FillScreen(WHITE);  
  TFT_WriteStringInRectCenterInTwoLines("Нажимайте в центр", "появляющихся квадратов", BLACK, WHITE, LOWER, 0, 0, &Tahoma34);

  // U, L  
  OS_ClearMB(&TouchPad_MB);  
  TFT_DrawRect(CALIB_ULCORNER);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      set_sound(S_SOUND_20);
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[0] = X;
  y[0] = Y;
  set_sound(S_SOUND_20);
  
  // U, R
  TFT_DrawRectWithColor(CALIB_ULCORNER, WHITE);
  TFT_DrawRect(CALIB_URCORNER);
  OS_Delay(1000);
  
  OS_ClearMB(&TouchPad_MB);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      set_sound(S_SOUND_20);
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[1] = X;
  y[1] = Y;
  set_sound(S_SOUND_20);

  // D, R
  TFT_DrawRectWithColor(CALIB_URCORNER, WHITE);
  TFT_DrawRect(CALIB_DRCORNER);
  OS_Delay(1000);
  
  OS_ClearMB(&TouchPad_MB);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      set_sound(S_SOUND_20);
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[2] = X;
  y[2] = Y;
  set_sound(S_SOUND_20);
  
  // D, L
  TFT_DrawRectWithColor(CALIB_DRCORNER, WHITE);  
  TFT_DrawRect(CALIB_DLCORNER);
  OS_Delay(1000);
  
  OS_ClearMB(&TouchPad_MB);
  while (!TFT_Touched(&X, &Y))
  {
    if (TFT_Pressed() == BACK_BUTTON)
    {
      set_sound(S_SOUND_20);
      system_flags.touch_calib = 0;
      draw();
      return;
    }
    OS_Delay(50);
  }
  x[3] = X;
  y[3] = Y;
  set_sound(S_SOUND_20);
  
  TFT_DrawRectWithColor(CALIB_DLCORNER, WHITE);
  
  xL = (x[0] + x[3]) / 2; xR = (x[1] + x[2]) / 2;
  yU = (y[0] + y[1]) / 2; yD = (y[2] + y[3]) / 2;  

  new_TFT_Calib[0][1] = (F32)(calibPointsX[1] - calibPointsX[0]) / (xR - xL);                // B0   
  new_TFT_Calib[0][0] = (F32)calibPointsX[0] - new_TFT_Calib[0][1] * xL ;                   // A0   x = A0 + B0 * X 
  new_TFT_Calib[1][1] = (F32)(calibPointsY[1] - calibPointsY[0]) / (yD - yU);                // B1   
  new_TFT_Calib[1][0] = (F32)calibPointsY[0] - new_TFT_Calib[1][1] * yU ;                   // A1   y = A1 + B1 * Y 
      
  OS_Use(&SemaRAM);
  
  TFT_Calib[0][0] = new_TFT_Calib[0][0];
  TFT_Calib[0][1] = new_TFT_Calib[0][1];
  TFT_Calib[1][0] = new_TFT_Calib[1][0];
  TFT_Calib[1][1] = new_TFT_Calib[1][1];
  system_flags.touch_calib = 0;
  
  OS_Unuse(&SemaRAM);  
  
  TFT_DrawRect(CALIB_CENTER);
  OS_Delay(1000);
  OS_ClearMB(&TouchPad_MB);
  TFT_WaitForCoords(&X, &Y);
  set_sound(S_SOUND_20);
  
  if (TFT_CoordsInRect(X, Y, CALIB_CENTER))
  {
    TFT_FillRect(X-5, X+5, Y-5, Y+5, YELLOW);
    TFT_WriteStringInRectCenter("Экран откалиброван", DARKGREEN, WHITE, LOWERMOST, 0, 0, &Tahoma34);
    
    OS_Use(&SemaRAM);
      SAVE_CONFIG(TFT_Calib);
    OS_Unuse(&SemaRAM);
  }
  else
  {
    TFT_FillRect(X-5, X+5, Y-5, Y+5, RED);
    TFT_WriteStringInRectCenter("Ошибка калибровки", RED, WHITE, LOWERMOST, 0, 0, &Tahoma34);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(TFT_Calib);
    OS_Unuse(&SemaRAM);
  }
  
  OS_Delay(2000);
  OS_ClearMB(&TouchPad_MB);    
  
  if (draw) draw();
}

// Показывает приветственный экран с логотипом
void GUI_LogoScreen()
{
  TFT_FillScreen(WHITE);
  GUI_DrawImageInRectCenterSwapColor(EKSIS_LOGO_200x80, SCREEN, TEMPLATE_COLOR, WHITE);
  OS_Delay(4000);
  TFT_FillScreen(WHITE);
}

// Рисует заголовок
void GUI_DrawHeader(Int8U main_button, bool main_active, Int8U left_button, bool left_active, Int8U right_button, bool right_active, char* topic, char* title)
{
  GUI_DrawHeaderMainButton(main_button, main_active);  
  GUI_DrawHeaderLRButtons(left_button, left_active, right_button, right_active);
  
  TFT_FillRect_(TOPIC, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC, 5, 0, &Tahoma34);
  
  GUI_DrawStatusIcons();
  
  TFT_FillRect_(TIME, ODD_GRAY);
  GUI_DrawTime();
 
  TFT_FillRect_(TITLE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE, 0, 0, &Tahoma34);
  
  GUI_UpdateHeader();
}

void GUI_DrawHeaderWide(Int8U main_button, bool main_active, char* topic, char* title)
{
  GUI_DrawHeaderMainButton(main_button, main_active);
  
  TFT_FillRect_(TOPIC_WIDE, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC_WIDE, 5, 0, &Tahoma34);
  
  GUI_DrawStatusIcons();
  
  TFT_FillRect_(TIME, ODD_GRAY);
  GUI_DrawTime();
 
  TFT_FillRect_(TITLE_WIDE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE_WIDE, 0, 0, &Tahoma34);
  
  GUI_UpdateHeaderWide();
}

void GUI_DrawHeaderMainButton(Int8U main_button, bool main_active)
{
  TFT_FillRect_Offset(HEAD_MAINBUTTON, HEAD_MAINBUTTON.color, 0, 0);
  if (main_button != 255)
    GUI_DrawImageInRectCenterSwapColor(main_button, HEAD_MAINBUTTON, TEMPLATE_COLOR, HEAD_MAINBUTTON.color);
  if (!main_active)
    TFT_GrayoutRect_(HEAD_MAINBUTTON, BACKGROUND_COLOR);
}

void GUI_DrawHeaderLButton(Int8U left_button, bool left_active)
{
  TFT_FillRect_Offset(HEAD_LBUTTON, HEAD_LBUTTON.color, 0, 0);
  if (left_button != 255)
    GUI_DrawImageInRectCenterSwapColor(left_button, HEAD_LBUTTON, TEMPLATE_COLOR, HEAD_LBUTTON.color);
  if (!left_active)
    TFT_GrayoutRect_(HEAD_LBUTTON, BACKGROUND_COLOR);
}

void GUI_DrawHeaderRButton(Int8U right_button, bool right_active)
{
  TFT_FillRect_Offset(HEAD_RBUTTON, HEAD_RBUTTON.color, 0, 0);
  if (right_button != 255)
    GUI_DrawImageInRectCenterSwapColor(right_button, HEAD_RBUTTON, TEMPLATE_COLOR, HEAD_RBUTTON.color);
  if (!right_active)
    TFT_GrayoutRect_(HEAD_RBUTTON, BACKGROUND_COLOR);
}

void GUI_DrawHeaderLRButtons(Int8U left_button, bool left_active, Int8U right_button, bool right_active)
{
  GUI_DrawHeaderLButton(left_button, left_active);
  GUI_DrawHeaderRButton(right_button, right_active);
}

// Обновляет заголовок
void GUI_UpdateHeader()
{
  GUI_DrawStatusIcons();
  GUI_DrawTime();
}

void GUI_UpdateHeaderWide()
{
  GUI_DrawStatusIcons();
  GUI_DrawTime();
}

void GUI_UpdateHeaderText(char* topic, char* title)
{
  TFT_FillRect_(TOPIC, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC, 5, 0, &Tahoma34);
  TFT_FillRect_(TITLE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE, 0, 0, &Tahoma34);
  
  GUI_UpdateHeader();
}

void GUI_UpdateHeaderWideText(char* topic, char* title)
{
  TFT_FillRect_(TOPIC_WIDE, ODD_GRAY);
  TFT_WriteStringInRectLeft(topic, BLACK, ODD_GRAY, TOPIC_WIDE, 5, 0, &Tahoma34);
  TFT_FillRect_(TITLE_WIDE, EVEN_GRAY);
  TFT_WriteStringInRectCenter(title, BLACK, EVEN_GRAY, TITLE_WIDE, 0, 0, &Tahoma34);
  
  GUI_UpdateHeaderWide();
}

// Рисует время
void GUI_DrawTime()
{
  int    m, d, h, mi, s, y;
  ParseDate( Time, &s, &mi, &h, &d, &m, &y);
  char text[6];
  sprintf(text, "%.2d:%.2d", h, mi);
  TFT_WriteStringInRectCenter(text, BLACK, ODD_GRAY, TIME, 0, 0, &Tahoma34);
}

// Рисует значки рядом с часами
void GUI_DrawStatusIcons()
{
  int sX, sY;
  sY = TIME.sY + 8;
  
  sX = TIME.sX - 24;
  if (USB_IsConfigured()) TFT_WriteString("\x00A4", DEEPBLUE, ODD_GRAY, sX, sY, &Tahoma34);
  else                    TFT_WriteString("\x00A4", ODD_GRAY, ODD_GRAY, sX, sY, &Tahoma34);

  sX -= 34;
  if (IP_IFaceIsReady(0)) TFT_WriteString("\x00AB", DEEPBLUE, ODD_GRAY, sX, sY, &Tahoma34);
  else                    TFT_WriteString("\x00AB", ODD_GRAY, ODD_GRAY, sX, sY, &Tahoma34);
}

// Рисует экран измерений
void GUI_DrawMeasuresScreen()
{
  Int8U channels_count = GetDisplayChannelsCount();
  if (CurrentDisplay == 255)
  {
    if (channels_count > 1)
    {
      GUI_DrawMeasuresChannels4();
    }
    else if (channels_count > 0)
    {
      CurrentDisplay = 0;
      GUI_DrawMeasuresChannels1();
    }
  }
  else
  {
    if (channels_count > 1)
    {
      GUI_DrawMeasuresChannel4();
    }
    else if (channels_count > 0)
    {
      CurrentDisplay = 0;
      GUI_DrawMeasuresChannels1();
    }
  }
}

// Обновляет экран измерений
void GUI_UpdateMeasuresScreen()
{
  Int8U channels_count = GetDisplayChannelsCount();
  if (CurrentDisplay == 255)
  {
    if (channels_count > 1)
    {
      GUI_UpdateMeasuresChannels4();
    }
    else if (channels_count > 0)
    {
      CurrentDisplay = 0;
      GUI_UpdateMeasuresChannels1();
    }
  }
  else
  {
    if (channels_count > 1)
    {
      GUI_UpdateMeasuresChannel4();
    }
    else if (channels_count > 0)
    {
      CurrentDisplay = 0;
      GUI_UpdateMeasuresChannels1();
    }
  }
}

// Проверяет нажатия на экране измерений
void GUI_TouchMeasuresScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    if ((CurrentDisplay != 255) && (GetDisplayChannelsCount() != 1))
    {
      set_sound(S_SOUND_20);
      CurrentDisplay = 255;
      GUI_DrawMeasuresChannels4();
      return;
    }
  }

  Int8U channels_count = GetDisplayChannelsCount();
  if (CurrentDisplay == 255)
  {
    if (channels_count > 1)
    {
      GUI_TouchMeasuresChannels4(X, Y);
    }
    else if (channels_count > 0)
    {
      CurrentDisplay = 0;
      GUI_TouchMeasuresChannels1(X, Y);
    }
  }
  else
  {
    if (channels_count > 1)
    {
      GUI_TouchMeasuresChannel4(X, Y);
    }
    else if (channels_count > 0)
    {
      CurrentDisplay = 0;
      GUI_TouchMeasuresChannels1(X, Y);
    }
  }
}

// Рисует тело главного экрана
void GUI_DrawMeasuresChannels4()
{
  char display[32];
  Int8U count = GetDisplayChannelsCount();
  if (count > 4)
  {
    sprintf(display, "Каналы %d - %d", CurrentMeasuresPage*4+1,  CurrentMeasuresPage*4+4);
    GUI_DrawHeader(SETTINGS_60x60, true, BACKWARD_60x60, (CurrentMeasuresPage > 0), FORWARD_60x60, ((CurrentMeasuresPage+1)*4 < count), "Измерение", display);
  }
  else
  {
    GUI_DrawHeaderWide(SETTINGS_60x60, true, "Измерение", "Все каналы");
  }
  
  for (int i = CurrentMeasuresPage*4; i < CurrentMeasuresPage*4+4; i++)
  {
    TFT_FillRect_(*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4], (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).color);
    sprintf(display, "%d", i+1);
    GUI_DrawImageInRectCenterSwapColor(MAGNIFIER_60x60, *BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4], TEMPLATE_COLOR, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).color);
    TFT_WriteString(display, BLACK, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).color, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).sX, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).sY, &Tahoma22);

    TFT_FillRect_(*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4], (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color);
  }
  
  GUI_UpdateMeasuresChannels4();
}

// Обновляет главный экран - показания
void GUI_UpdateMeasuresChannels4()
{
  GUI_UpdateHeader();
  
  Int16U color;
  char value[32], units[32];
  int first, second;
//  RECT actual_text_rect;
  for (int i = CurrentMeasuresPage*4; i < CurrentMeasuresPage*4+4; i++)
  {
    GetChosenParams(i, &first, &second);
    if ((first != -1) && (second != -1))
    {
      GetMeasureStringNoUnits(i, first, value, &color);                     
      //TFT_FillRect_(*LPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color);
      //actual_text_rect = TFT_WriteStringInRectCenter(value, color, (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color, *LPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], 0, 0, &Tahoma87);
      
      GetParamUnits(i, first, units);
      //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY, &Tahoma34);
      
      if (DeviceName[0]=='М')
      {
        GetParamType(i, first, units);
        //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY+34, &Tahoma34);
      }
      
      GUI_SmartWriteBigMeasureInRectCenter(value, color, units, BLACK, (RECT*)LPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]->color);

      
      GetMeasureStringNoUnits(i, second, value, &color);      
      //TFT_FillRect_(*RPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color);
      //actual_text_rect = TFT_WriteStringInRectCenter(value, color, (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color, *RPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], 0, 0, &Tahoma87);
      
      GetParamUnits(i, second, units);
      //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY, &Tahoma34);
      
      if (DeviceName[0]=='М')
      {
        GetParamType(i, second, units);
        //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY+34, &Tahoma34);
      }
      
      GUI_SmartWriteBigMeasureInRectCenter(value, color, units, BLACK, (RECT*)RPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]->color);
    }
    else if (first != -1)
    {
      GetMeasureStringNoUnits(i, first, value, &color);
      //TFT_FillRect_(*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4], (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color);
      //actual_text_rect = TFT_WriteStringInRectCenter(value, color, (*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]).color, *PARAMS_WIDE_UD[i-CurrentMeasuresPage*4], 0, 0, &Tahoma87);
      
      GetParamUnits(i, first, units);
      //TFT_WriteString(untis, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY, &Tahoma34);
      
      if (DeviceName[0]=='М')
      {
        GetParamType(i, first, units);
        //TFT_WriteString(untis, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY+34, &Tahoma34);
      }
      
      GUI_SmartWriteBigMeasureInRectCenter(value, color, units, BLACK, (RECT*)PARAMS_WIDE_UD[i-CurrentMeasuresPage*4], PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]->color);
    }
  }
}

void GUI_TouchMeasuresChannels4(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  Int8U count = GetDisplayChannelsCount();
  if (count > 4)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON) && ((CurrentMeasuresPage+1)*4 < count))
    {
      set_sound(S_SOUND_20);
      CurrentMeasuresPage++;
      GUI_DrawMeasuresChannels4();
      return;
    }

    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON) && (CurrentMeasuresPage > 0))
    {
      set_sound(S_SOUND_20);
      CurrentMeasuresPage--;
      GUI_DrawMeasuresChannels4();
      return;
    }
  }
  
  int first, second;
  for (int i = CurrentMeasuresPage*4; i < CurrentMeasuresPage*4+4; i++)
  {
    if (TFT_CoordsInRect(X, Y, *BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]))
    {
      set_sound(S_SOUND_20);
      CurrentDisplay = i;
      GUI_DrawMeasuresChannel4();
      return;
    }
    
    GetChosenParams(i, &first, &second);
    if ((first != -1) && (second != -1))
    {
      if (TFT_CoordsInRect(X, Y, *LPARAMS_WIDE_UD[i-CurrentMeasuresPage*4]))
      {
        set_sound(S_SOUND_20);
        CurrentDisplay = i;
        CurrentParam = first;
        BackToAllChannels = true;
        GUI_SetGUI(GUI_DrawParamRootScreen4, GUI_UpdateParamRootScreen4, GUI_TouchParamRootScreen4);
        return;
      }
      if (TFT_CoordsInRect(X, Y, *RPARAMS_WIDE_UD[i-CurrentMeasuresPage*4]))
      {
        set_sound(S_SOUND_20);
        CurrentDisplay = i;
        CurrentParam = second;
        BackToAllChannels = true;
        GUI_SetGUI(GUI_DrawParamRootScreen4, GUI_UpdateParamRootScreen4, GUI_TouchParamRootScreen4);
        return;
      }
    }
    else if (first != -1)
    {
      if (TFT_CoordsInRect(X, Y, *PARAMS_WIDE_UD[i-CurrentMeasuresPage*4]))
      {
        set_sound(S_SOUND_20);
        CurrentDisplay = i;
        CurrentParam = first;
        BackToAllChannels = true;
        GUI_SetGUI(GUI_DrawParamRootScreen4, GUI_UpdateParamRootScreen4, GUI_TouchParamRootScreen4);
        return;
      }
    }
  }
}

void GUI_DrawMeasuresChannels1()
{
  GUI_DrawHeaderWide(NO_IMAGE, true, "Измерение", "Канал 1");
  
  char display[32];
  Int8U count = GetDisplayChannelsCount();
  
  TFT_DrawRect(BODY);
  
  TFT_FillRect_(MENU0_LEFT, EVEN_YELLOW);
  TFT_FillRect_(MENU1_LEFT, EVEN_YELLOW);
  TFT_FillRect_(MENU2_LEFT, EVEN_YELLOW);
  TFT_FillRect_(MENU3_LEFT, EVEN_YELLOW);

  GUI_DrawImageInRectCenterSwapColor(INFO_MENU_60x60,       MENU0_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
  GUI_DrawImageInRectCenterSwapColor(CONNECTION_MENU_60x60, MENU1_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
  if (!(ConfigWord & PUMP_CONTROL_DEVICE))
  {
    GUI_DrawImageInRectCenterSwapColor(STATISTIC_MENU_60x60,  MENU2_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
    GUI_DrawImageInRectCenterSwapColor(OTHER_MENU_60x60,      MENU3_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
  }
  
  TFT_FillRect_(UPARAM, ODD_GREEN);
  TFT_FillRect_(MPARAM, ODD_GREEN);
  TFT_FillRect_(LPARAM, ODD_GREEN);
  TFT_FillRect_(LMPARAM, ODD_GREEN);
  
  Int8U params_count = GetDisplayChannelParamsCount(0);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    GetParamName(0, j, display);
        
    int k = DisplayConfig[0].ParamConfig[j] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *CAPTIONS_LR[k];
    TFT_WriteStringInRectCenter(display, BLACK, ODD_GREEN, placement, 0, 0, &Tahoma34);
  }
  
  if (ConfigWord & PUMP_CONTROL_DEVICE)
    GUI_DrawPumpControlPanel();
  
  GUI_UpdateMeasuresChannels1();
}

void GUI_UpdateMeasuresChannels1()
{
  GUI_UpdateHeaderWide();
  
  Int16U color;
  char display[32];
  
  Int8U params_count = GetDisplayChannelParamsCount(0);
  if (params_count > 6) params_count = 6;
  
  Int16U back_color = (*BORDER_BUTTONS_UD[0]).color;
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[0].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *VALUES_LR[k];
    //TFT_FillRect_(placement, back_color);
    GetMeasureString(0, i, display, &color);
    //TFT_WriteStringInRectCenter(display, color, back_color, placement, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter(display, color, back_color, &placement, &Tahoma34);
  }
  
  if (ConfigWord & PUMP_CONTROL_DEVICE)
    GUI_UpdatePumpControlPanel();
}

void GUI_TouchMeasuresChannels1(Int16U X, Int16U Y)
{
  Int8U channels_count = GetDisplayChannelsCount();
  if (channels_count > 4) channels_count = 4;
  
  if (TFT_CoordsInRect(X, Y, MENU0_LEFT))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsInfoScreen, GUI_UpdateSettingsInfoScreen, GUI_TouchSettingsInfoScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU1_LEFT))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU2_LEFT) && (!(ConfigWord & PUMP_CONTROL_DEVICE)))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsStatisticScreen, GUI_UpdateSettingsStatisticScreen, GUI_TouchSettingsStatisticScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU3_LEFT) && (!(ConfigWord & PUMP_CONTROL_DEVICE)))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  Int8U params_count = GetDisplayChannelParamsCount(0);
  if (params_count > 6) params_count = 6;
      
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placemnt = *PARAMS_LR[k];
    if (TFT_CoordsInRect(X, Y, placemnt))
    {
      set_sound(S_SOUND_20);
      CurrentParam = i;
      BackToAllChannels = false;
      GUI_SetGUI(GUI_DrawParamRootScreen4, GUI_UpdateParamRootScreen4, GUI_TouchParamRootScreen4);
      return;
    }
  }
  
  if (ConfigWord & PUMP_CONTROL_DEVICE)
    GUI_TouchPumpControlPanel(X, Y);
}

void GUI_DrawMeasuresChannel4()
{
  char display[32];
  Int8U count = GetDisplayChannelsCount();
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_DrawHeader(SETTINGS_CHANNEL_60x60, true, BACKWARD_60x60, (CurrentDisplay != 0), FORWARD_60x60, (CurrentDisplay < count - 1), "Измерение", display);
  
  int first, second;
  Int16U font_color, color = (*BORDER_BUTTONS_UD[CurrentDisplay-CurrentMeasuresPage*4]).color;
  for (int i = CurrentMeasuresPage*4; i < CurrentMeasuresPage*4+4; i++)
  {
    if (CurrentDisplay == i)
    {
      TFT_FillRect_(*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4], color);
      sprintf(display, "%d", i+1);
      GUI_DrawImageInRectCenterSwapColor(MAGNIFIER_60x60, *BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4], TEMPLATE_COLOR, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).color);
      TFT_WriteString(display, BLACK, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).color, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).sX, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).sY, &Tahoma22);
    }
    
    if (CurrentDisplay != i)
    {
      TFT_FillRect_(*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4], BACKGROUND_COLOR);
      sprintf(display, "%d", i+1);
      GUI_DrawImageInRectCenterSwapColor(MAGNIFIER_60x60, *BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4], TEMPLATE_COLOR, BACKGROUND_COLOR);
      TFT_WriteString(display, BLACK, BACKGROUND_COLOR, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).sX, (*BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]).sY, &Tahoma22);
    }
  }
  for (int i = 0; i < 8; i++)
  {
    TFT_FillRect_(*PARAMS_UD[i], color);
  }
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    GetParamName(CurrentDisplay, j, display);
    GetChosenParams(CurrentDisplay, &first, &second);
        
    font_color = (j == first) || (j == second) ? BROWN : BLACK;
    int k = DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *CAPTIONS_LR[k];
    TFT_WriteStringInRectCenter(display, font_color, color, placement, 0, 0, &Tahoma34);
  }
  
  GUI_UpdateMeasuresChannel4();
}

// Обновляет главный экран - показания
void GUI_UpdateMeasuresChannel4()
{
  GUI_UpdateHeader();
  
  Int16U color;
  char display[32];
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
  
  Int16U back_color = (*BORDER_BUTTONS_UD[CurrentDisplay-CurrentMeasuresPage*4]).color;
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *VALUES_LR[k];
    //TFT_FillRect_(placement, back_color);
    GetMeasureString(CurrentDisplay, i, display, &color);
    //TFT_WriteStringInRectCenter(display, color, back_color, placement, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter(display, color, back_color, &placement, &Tahoma34);
  }
}

void GUI_TouchMeasuresChannel4(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U channels_count = GetDisplayChannelsCount();
  
  if (CurrentDisplay > 0)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentDisplay--;
      CurrentMeasuresPage = CurrentDisplay / 4;
      GUI_DrawMeasuresChannel4();
      return;
    }
  }
  
  if (CurrentDisplay < channels_count - 1)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentDisplay++;
      CurrentMeasuresPage = CurrentDisplay / 4;
      GUI_DrawMeasuresChannel4();
      return;
    }
  }
  
  for (int i = CurrentMeasuresPage*4; i < CurrentMeasuresPage*4+4; i++)
  {
    if (TFT_CoordsInRect(X, Y, *BORDER_BUTTONS_UD[i-CurrentMeasuresPage*4]))
    {
      set_sound(S_SOUND_20);
      if (CurrentDisplay == i) 
      {
        CurrentDisplay = 255;
        GUI_DrawMeasuresChannels4();
      }
      else
      {
        CurrentDisplay = i;
        GUI_DrawMeasuresChannel4();
      }
      return;
    }
  }

  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int i = 0; i < params_count; i++)
  {
    int k = DisplayConfig[CurrentDisplay].ParamConfig[i] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placemnt = *PARAMS_LR[k];
    if (TFT_CoordsInRect(X, Y, placemnt))
    {
      set_sound(S_SOUND_20);
      CurrentParam = i;
      BackToAllChannels = false;
      GUI_SetGUI(GUI_DrawParamRootScreen4, GUI_UpdateParamRootScreen4, GUI_TouchParamRootScreen4);
      return;
    }
  }
}

void GUI_DrawPumpControlPanel()
{
  char display[32];
  TFT_FillRect_(LMPARAM, EVEN_GREEN);
  TFT_WriteStringInRectCenter("Период, сек", BLACK, EVEN_GREEN, LMLCAPTION, 0, 0, &Tahoma34);
  sprintf(display, "%d", PumpTime);
  TFT_WriteStringInRectCenter(display, DEEPBLUE, EVEN_GREEN, LMLVALUE, 0, 0, &Tahoma34);
  
  TFT_WriteStringInRectCenter("Измерение", BLACK, EVEN_GREEN, LMRCAPTION, 0, 0, &Tahoma34);
}

void GUI_UpdatePumpControlPanel()
{
  char display[32];
  //TFT_FillRect_(LMRVALUE, EVEN_GREEN);
  if (CHECK_PUMP)
  {
    if (ConfigWord & MEASURE_MODE_AUTO)
    {
      //TFT_WriteStringInRectCenter("запущено", PURPLE, EVEN_GREEN, LMRVALUE, 0, 0, &Tahoma34);
      TFT_SmartWriteStringInRectCenter("запущено", PURPLE, EVEN_GREEN, (RECT*)&LMRVALUE, &Tahoma34);
      GUI_DrawImageInRectCenterSwapColor(PAUSE_60x60, MENU2_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
      TFT_GrayoutRect_(MENU3_LEFT, EVEN_YELLOW);
    }
    else
    {
      sprintf(display, "%d", PumpTime - DownCount);
      //TFT_WriteStringInRectCenter(display, PURPLE, EVEN_GREEN, LMRVALUE, 0, 0, &Tahoma34);
      TFT_SmartWriteStringInRectCenter(display, PURPLE, EVEN_GREEN, (RECT*)&LMRVALUE, &Tahoma34);
      TFT_GrayoutRect_(MENU2_LEFT, EVEN_YELLOW);
      GUI_DrawImageInRectCenterSwapColor(PROBE_60x60, MENU3_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
    }
  }
  else
  {
    //TFT_WriteStringInRectCenter("остановлено", PURPLE, EVEN_GREEN, LMRVALUE, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("остановлено", PURPLE, EVEN_GREEN, (RECT*)&LMRVALUE, &Tahoma34);
    GUI_DrawImageInRectCenterSwapColor(PLAY_60x60,  MENU2_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
    GUI_DrawImageInRectCenterSwapColor(PROBE_60x60, MENU3_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
  }
}

void GUI_TouchPumpControlPanel(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, LMLPARAM))
  {
    set_sound(S_SOUND_20);
      
    OS_STOPTIMER_IF_NOT(&PumpTimer);
    PUMP_OFF;
      
    int temp = PumpTime;
    if (GUI_KeyboardInt(&temp, "Настройки", "Прокачка, сек", true, 1, 3000)) 
    {
      PumpTime = temp;
      OS_Use(&SemaRAM);
      SAVE_CONFIG(PumpTime);
      OS_Unuse(&SemaRAM);
    }

    draw();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU2_LEFT))
  {
    if (CHECK_PUMP)
    {
      if (ConfigWord & MEASURE_MODE_AUTO)
      {
        set_sound(S_SOUND_20);
        OS_STOPTIMER_IF_NOT(&PumpTimer);
        PUMP_OFF;
      }
    }
    else
    {
      set_sound(S_SOUND_20);
      
      ConfigWord |= MEASURE_MODE_AUTO;
      InvConfigWord = ~ConfigWord;
      OS_Use(&SemaRAM);
      SAVE_CONFIG(ConfigWord);
      SAVE_CONFIG(InvConfigWord);
      OS_Unuse(&SemaRAM);
      
      StatTimer = 0;
      PUMP_ON;
    }
    GUI_UpdatePumpControlPanel();
  }
  
  if (TFT_CoordsInRect(X, Y, MENU3_LEFT))
  {
    if (CHECK_PUMP)
    {
      if (!(ConfigWord & MEASURE_MODE_AUTO))
      {
        set_sound(S_SOUND_20);
        OS_SetTimerPeriod(&PumpTimer, 1);
        OS_RetriggerTimer(&PumpTimer);
        DownCount = 0;
      }
    }
    else
    {
      set_sound(S_SOUND_300);
      
      ConfigWord &= ~MEASURE_MODE_AUTO;
      InvConfigWord = ~ConfigWord;
      OS_Use(&SemaRAM);
      SAVE_CONFIG(ConfigWord);
      SAVE_CONFIG(InvConfigWord);
      OS_Unuse(&SemaRAM);
    
      PUMP_ON;
      OS_SetTimerPeriod(&PumpTimer, PumpTime*1000);
      OS_RetriggerTimer(&PumpTimer);
      DownCount = PumpTime;
    }
    GUI_UpdatePumpControlPanel();
  }
}

void GUI_DrawChannelSettingsRootScreen()
{
  char display[32];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  GUI_DrawHeaderWide(BACK_60x60, true, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Параметры на главном экране", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  if (HumidityCalculationPossible(CurrentDisplay))
  {
    TFT_WriteStringInRectCenter("Параметры пересчёта влажности", DARKGREEN, BACKGROUND_COLOR, MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }

  if (PressureCalculationPossible(CurrentDisplay))
  {
    //TFT_WriteStringInRectCenter("Параметры датчика давления", DARKGREEN, BACKGROUND_COLOR, MIDDLE, 0, 0, &Tahoma34);
    TFT_WriteStringInRectCenter("Параметры датчика давления", DARKGREEN, BACKGROUND_COLOR, LOWER, 0, 0, &Tahoma34);

    //TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  }
  
  if (FlowCalculationPossible(CurrentDisplay))
  {
    TFT_WriteStringInRectCenter("Параметры пересчёта расхода", DARKGREEN, BACKGROUND_COLOR, MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }
  
  GUI_UpdateChannelSettingsRootScreen();
}

void GUI_UpdateChannelSettingsRootScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_TouchChannelSettingsRootScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawChannelSettingsDisplayScreen, GUI_UpdateChannelSettingsDisplayScreen, GUI_TouchChannelSettingsDisplayScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MIDDLE))
  {
    if (HumidityCalculationPossible(CurrentDisplay))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawChannelSettingsCalculateHumidityScreen, GUI_UpdateChannelSettingsCalculateHumidityScreen, GUI_TouchChannelSettingsCalculateHumidityScreen);
      return;
    }
  }
  
  if (TFT_CoordsInRect(X, Y, LOWER))
  {
    if (PressureCalculationPossible(CurrentDisplay))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawChannelSettingsCalculatePressureScreen, GUI_UpdateChannelSettingsCalculatePressureScreen, GUI_TouchChannelSettingsCalculatePressureScreen);
      return;
    }
  }
  
  if (TFT_CoordsInRect(X, Y, MIDDLE))
  {
    if (FlowCalculationPossible(CurrentDisplay))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawChannelSettingsCalculateFlowScreen, GUI_UpdateChannelSettingsCalculateFlowScreen, GUI_TouchChannelSettingsCalculateFlowScreen);
      return;
    }
  }
}

void GUI_DrawChannelSettingsDisplayScreen()
{
  char display[32];
  sprintf(display, "Канал %d: отображение", CurrentDisplay+1);
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", display);
  
  TFT_DrawRect(BODY);
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    GetParamNameAndUnits(CurrentDisplay, j, display);
    
    TFT_WriteStringInRectLeft(display, BLACK, BACKGROUND_COLOR, *LEFTHALFS_SMALL[j], 5, 0, &Tahoma34);
    if (j != 7) TFT_UnderlineRect_Offset(*LINES_SMALL[j], BLACK, 1, 40, 0);
  }
  
  GUI_UpdateChannelSettingsDisplayScreen();
  GUI_ManualUpdateChannelSettingsDisplayScreen();
}

void GUI_UpdateChannelSettingsDisplayScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateChannelSettingsDisplayScreen()
{
  Int8U chosen_count = GetDisplayChannelChosenParamsCount(CurrentDisplay);
  GUI_DrawHeaderMainButton(OK_60x60, true);
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
      
  for (int j = 0; j < params_count; j++)
  {
    TFT_FillRect_(*RIGHTS_SMALL[j], BACKGROUND_COLOR);
    if (DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_ON_MAINSCREEN)
      TFT_WriteStringInRectCenter("Да", DARKGREEN, BACKGROUND_COLOR, *RIGHTS_SMALL[j], 0, 0, &Tahoma34);
    else
      TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, *RIGHTS_SMALL[j], 0, 0, &Tahoma34);
    if (j != 7) TFT_UnderlineRect_Offset(*LINES_SMALL[j], BLACK, 1, 40, 0);
  }
}

void GUI_TouchChannelSettingsDisplayScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  Int8U chosen_count = GetDisplayChannelChosenParamsCount(CurrentDisplay);
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (params_count > 6) params_count = 6;
  
  for (int j = 0; j < params_count; j++)
  {
    if (TFT_CoordsInRect(X, Y, *LINES_SMALL[j]))
    {
      if (DisplayConfig[CurrentDisplay].ParamConfig[j] & PARAM_ON_MAINSCREEN)
      {
        set_sound(S_SOUND_20);
        DisplayConfig[CurrentDisplay].ParamConfig[j] &= ~PARAM_ON_MAINSCREEN;
        GUI_ManualUpdateChannelSettingsDisplayScreen();
      }
      else if (chosen_count < 2)
      {
        set_sound(S_SOUND_20);
        DisplayConfig[CurrentDisplay].ParamConfig[j] |= PARAM_ON_MAINSCREEN;
        GUI_ManualUpdateChannelSettingsDisplayScreen();
      }
      return;
    }
  }
}

void GUI_DrawChannelSettingsCalculateHumidityScreen()
{
  char display[32];
  sprintf(display, "Канал %d: пересчёт", CurrentDisplay+1);
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Давление в точке измерения", BLACK, BACKGROUND_COLOR, UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Давление в точке пересчёта", BLACK, BACKGROUND_COLOR, LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  GUI_UpdateChannelSettingsCalculateHumidityScreen();
  GUI_ManualUpdateChannelSettingsCalculateHumidityScreen();
}

void GUI_UpdateChannelSettingsCalculateHumidityScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateChannelSettingsCalculateHumidityScreen()
{
  char display[32];
  Int8U index = GetDewPointParamIndex(CurrentDisplay);
  Int8U measure_attribute = DisplayConfig[CurrentDisplay].DisplayParam[index];
  Int8U calc_config_index = measure_attribute - CALC_BASE;
  int index0 = CalcConfig[calc_config_index].InputConstantParamNum[0]%12;
  int index1 = CalcConfig[calc_config_index].InputConstantParamNum[1]%12;

  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);  
  TFT_FillRect_(MIDDLE, BACKGROUND_COLOR);
  if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE1_SOURCE)
  {
    TFT_WriteStringInRectCenter("Датчик", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
    TFT_WriteStringInRectLeft("Преобразователь", BLACK, BACKGROUND_COLOR, MIDDLE, 5, 0, &Tahoma34);
    GetParamStringByMeasureAttribute((Int8U)DisplayConfig[CurrentDisplay].Constant[index0], display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Константа", PressureTransducerExists() ? DARKGREEN : BROWN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
    TFT_WriteStringInRectLeft("Значение, атм.", BLACK, BACKGROUND_COLOR, MIDDLE, 5, 0, &Tahoma34);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[index0].DecPoint, DisplayConfig[CurrentDisplay].Constant[index0]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  TFT_FillRect_(LOWERMOST, BACKGROUND_COLOR);
  if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE2_SOURCE)
  {
    TFT_WriteStringInRectCenter("Датчик", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
    TFT_WriteStringInRectLeft("Преобразователь", BLACK, BACKGROUND_COLOR, LOWERMOST, 5, 0, &Tahoma34);
    GetParamStringByMeasureAttribute((Int8U)DisplayConfig[CurrentDisplay].Constant[index1], display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Константа", PressureTransducerExists() ? DARKGREEN : BROWN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
    TFT_WriteStringInRectLeft("Значение, атм.", BLACK, BACKGROUND_COLOR, LOWERMOST, 5, 0, &Tahoma34);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[index1].DecPoint, DisplayConfig[CurrentDisplay].Constant[index1]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchChannelSettingsCalculateHumidityScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U index = GetDewPointParamIndex(CurrentDisplay);
  Int8U measure_attribute = DisplayConfig[CurrentDisplay].DisplayParam[index];
  Int8U calc_config_index = measure_attribute - CALC_BASE;
  int index0 = CalcConfig[calc_config_index].InputConstantParamNum[0]%12;
  int index1 = CalcConfig[calc_config_index].InputConstantParamNum[1]%12;
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER) && PressureTransducerExists())
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE1_SOURCE)
    {
      DisplayConfig[CurrentDisplay].Constant[index0] = 1;
      DisplayConfig[CurrentDisplay].ParamConfig[index] &= ~PARAM_PRESSURE1_SOURCE;
      SetPressure1Source(CurrentDisplay, false);
    }
    else
    {
      measure_attribute = 0;
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index0] = measure_attribute;
      SetPressure1Source(CurrentDisplay, true);
    }
    GUI_ManualUpdateChannelSettingsCalculateHumidityScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE1_SOURCE)
    {
      measure_attribute = (Int8U)DisplayConfig[CurrentDisplay].Constant[index0];
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index0] = measure_attribute;
      GUI_ManualUpdateChannelSettingsCalculateHumidityScreen();
      return;
    }
    else
    {
      Int8U decimal = DisplayConfig[CurrentDisplay].ConstConfig[index0].DecPoint;
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[index0], "Настройки", "Значение, атм", true, 0, 1000, decimal);
      GUI_DrawChannelSettingsCalculateHumidityScreen();
      return;
    }
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER) && PressureTransducerExists())
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE2_SOURCE)
    {
      DisplayConfig[CurrentDisplay].Constant[index1] = 1;
      SetPressure2Source(CurrentDisplay, false);
    }
    else
    {
      measure_attribute = 0;
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index1] = measure_attribute;
      SetPressure2Source(CurrentDisplay, true);
    }
    GUI_ManualUpdateChannelSettingsCalculateHumidityScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_PRESSURE2_SOURCE)
    {
      measure_attribute = (Int8U)DisplayConfig[CurrentDisplay].Constant[index1];
      IncrementPressureParam(&measure_attribute);
      DisplayConfig[CurrentDisplay].Constant[index1] = measure_attribute;
      GUI_ManualUpdateChannelSettingsCalculateHumidityScreen();
      return;
    }
    else
    {
      Int8U decimal = DisplayConfig[CurrentDisplay].ConstConfig[index1].DecPoint;
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[index1], "Настройки", "Значение, атм", true, 0, 1000, decimal);
      GUI_DrawChannelSettingsCalculateHumidityScreen();
      return;
    }
  }
}

void GUI_DrawChannelSettingsCalculatePressureScreen()
{
  char display[32];
  sprintf(display, "Канал %d: давление", CurrentDisplay+1);
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Тип давления", BLACK, BACKGROUND_COLOR, UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Выходной диапазон", BLACK, BACKGROUND_COLOR, MIDDLE, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Нижняя граница, кПа", BLACK, BACKGROUND_COLOR, LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Верхняя граница, кПа", BLACK, BACKGROUND_COLOR, LOWERMOST, 5, 0, &Tahoma34);
  
  GUI_UpdateChannelSettingsCalculatePressureScreen();
  GUI_ManualUpdateChannelSettingsCalculatePressureScreen();
}

void GUI_UpdateChannelSettingsCalculatePressureScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateChannelSettingsCalculatePressureScreen()
{
  char display[32];
  Int8U index;

  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);  
  index = (Int8U)DisplayConfig[CurrentDisplay].Constant[0];
  if (index > 1) index = 0;
  sprintf(display, "%s", PRESSURE_TYPES[index]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);  
  index = (Int8U)DisplayConfig[CurrentDisplay].Constant[1];
  if (index > 2) index = 0;
  sprintf(display, "%s", PRESSURE_INPUTS[index]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);  
  sprintf(display, "%.0f", DisplayConfig[CurrentDisplay].Constant[2]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);  
  sprintf(display, "%.0f", DisplayConfig[CurrentDisplay].Constant[3]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);
}

void GUI_TouchChannelSettingsCalculatePressureScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U index;
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    index = (Int8U)DisplayConfig[CurrentDisplay].Constant[0];
    index++;
    if (index > 1) index = 0;
    DisplayConfig[CurrentDisplay].Constant[0] = index;
    GUI_ManualUpdateChannelSettingsCalculatePressureScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    index = (Int8U)DisplayConfig[CurrentDisplay].Constant[1];
    index++;
    if (index > 2) index = 0;
    DisplayConfig[CurrentDisplay].Constant[1] = index;
    GUI_ManualUpdateChannelSettingsCalculatePressureScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[2], "Настройки", "Нижняя граница, кПа", false, -999999, 999999, 0);
    GUI_DrawChannelSettingsCalculatePressureScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[3], "Настройки", "Верхняя граница, кПа", false, -999999, 999999, 0);
    GUI_DrawChannelSettingsCalculatePressureScreen();
    return;
  }
}

void GUI_DrawChannelSettingsCalculateFlowScreen()
{
  char display[32];
  sprintf(display, "Канал %d: расход", CurrentDisplay+1);
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Тип сечения", BLACK, BACKGROUND_COLOR, UPPER, 5, 0, &Tahoma34);
     
  GUI_UpdateChannelSettingsCalculateFlowScreen();
  GUI_ManualUpdateChannelSettingsCalculateFlowScreen();
}

void GUI_UpdateChannelSettingsCalculateFlowScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateChannelSettingsCalculateFlowScreen()
{
  char display[32];
  Int8U index = GetFlowParamIndex(CurrentDisplay);
  
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_FLOW_CUT_TYPE)
  {
    TFT_WriteStringInRectCenter("прямоугольное", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
    TFT_WriteStringInRectLeft("Ширина, мм", BLACK, BACKGROUND_COLOR, MIDDLE, 5, 0, &Tahoma34);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[0].DecPoint, DisplayConfig[CurrentDisplay].Constant[0]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
     
    TFT_WriteStringInRectLeft("Высота, мм", BLACK, BACKGROUND_COLOR, LOWER, 5, 0, &Tahoma34);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[1].DecPoint, DisplayConfig[CurrentDisplay].Constant[1]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_WriteStringInRectCenter("круглое", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
    TFT_WriteStringInRectLeft("Диаметр, мм", BLACK, BACKGROUND_COLOR, MIDDLE, 5, 0, &Tahoma34);
    sprintf(display, "%.*f", DisplayConfig[CurrentDisplay].ConstConfig[0].DecPoint, DisplayConfig[CurrentDisplay].Constant[0]);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
    TFT_FillRect_(LOWER, BACKGROUND_COLOR);
  }
}

void GUI_TouchChannelSettingsCalculateFlowScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay]);
    OS_Unuse(&SemaRAM);
    GUI_SetGUI(GUI_DrawChannelSettingsRootScreen, GUI_UpdateChannelSettingsRootScreen, GUI_TouchChannelSettingsRootScreen);
    return;
  }
  
  Int8U index = GetFlowParamIndex(CurrentDisplay);
  if (TFT_CoordsInRect(X, Y, RIGHT_THIRD_UPPER))
  {
    set_sound(S_SOUND_20);
    DisplayConfig[CurrentDisplay].ParamConfig[index] ^= PARAM_FLOW_CUT_TYPE;
    GUI_ManualUpdateChannelSettingsCalculateFlowScreen();
    return;
  }
  
  if (DisplayConfig[CurrentDisplay].ParamConfig[index] & PARAM_FLOW_CUT_TYPE)
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[0], "Настройки", "Ширина, мм", false, 0, 999999, 0);
      GUI_DrawChannelSettingsCalculateFlowScreen();
      return;
    }
  
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[1], "Настройки", "Высота, мм", false, 0, 999999, 0);
      GUI_DrawChannelSettingsCalculateFlowScreen();
      return;
    }
  }
  else
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[0], "Настройки", "Диаметр, мм", false, 0, 999999, 0);
      GUI_DrawChannelSettingsCalculateFlowScreen();
      return;
    }
  }
}

void GUI_DrawParamRootScreen4()
{
  char display[30], param_type[30];
  GetParamType(CurrentDisplay, CurrentParam, param_type);
  sprintf(display, "Канал %d: %s", CurrentDisplay+1, param_type/*PARAM_TYPES[MeasureAttribute[CurrentParam].ParamType]*/);
  GUI_DrawHeaderWide(BACK_60x60, true, "Измерение", display);
  
  Int8U channels_count = GetDisplayChannelsCount();
  
  int params_on_mainscreen_mask;
  int params_on_mainscreen_count;
  if (BackToAllChannels)
  {
    for (int i = CurrentMeasuresPage*4; i < CurrentMeasuresPage*4+4; i++)
    {
      if (CurrentDisplay == i)
      {
        GetChosenParamsMask(i, &params_on_mainscreen_mask);
        params_on_mainscreen_count = GetMainScreenParametersCount(i);
        if (params_on_mainscreen_count == 2)
        {
          if (CurrentParam != GetActiveBitIndex(params_on_mainscreen_mask, 0))
          {
            TFT_GrayoutRect_(*LPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], BACKGROUND_COLOR);
          }
          if (CurrentParam != GetActiveBitIndex(params_on_mainscreen_mask, 1))
          {
            TFT_GrayoutRect_(*RPARAMS_WIDE_UD[i-CurrentMeasuresPage*4], BACKGROUND_COLOR);
          }
        }
      }
        
      if (CurrentDisplay != i)
      {
        TFT_GrayoutRect_(*PARAMS_WIDE_UD[i-CurrentMeasuresPage*4], BACKGROUND_COLOR);
      }
    }
  }
  if (!BackToAllChannels)
  {
    int param_rect = GetParamRect(CurrentDisplay, CurrentParam);
    int start_rect, end_rect;
    if (param_rect < 8)
    {
      start_rect = 0;
      end_rect = 8;
    }
    else
    {
      start_rect = 8;
      end_rect = 12;
    }
    for (int i = start_rect; i < end_rect; i++)
    {
      if (CurrentParam != GetRectParam(CurrentDisplay, i))
      {
        TFT_GrayoutRect_(*PARAMS_LR[i], BACKGROUND_COLOR);
      }
    }
  }
  
  TFT_FillRect_(MENU0_LEFT, EVEN_YELLOW);
  TFT_FillRect_(MENU1_LEFT, EVEN_YELLOW);
  TFT_FillRect_(MENU2_LEFT, EVEN_YELLOW);
  TFT_FillRect_(MENU3_LEFT, EVEN_YELLOW);

  GUI_DrawImageInRectCenterSwapColor(SETTINGS_PARAM_60x60, MENU0_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);
  GUI_DrawImageInRectCenterSwapColor(INFO_PARAM_60x60,     MENU1_LEFT, TEMPLATE_COLOR, EVEN_YELLOW);

  GUI_UpdateParamRootScreen4();
}

void GUI_UpdateParamRootScreen4()
{
  GUI_UpdateHeaderWide();
  
  char value[32], units[32];
  int params_on_mainscreen_mask;
  int params_on_mainscreen_count;
  Int16U color, back_color;
  
  Int8U channels_count = GetDisplayChannelsCount();
  
  if (BackToAllChannels)
  {
    const RECT* first_param_rect;
    const RECT* second_param_rect;
//    RECT actual_text_rect;
    
    GetChosenParamsMask(CurrentDisplay, &params_on_mainscreen_mask);
    params_on_mainscreen_count = GetMainScreenParametersCount(CurrentDisplay);
    if (params_on_mainscreen_count == 2)
    {
      first_param_rect = LPARAMS_WIDE_UD[CurrentDisplay-CurrentMeasuresPage*4];
      second_param_rect = RPARAMS_WIDE_UD[CurrentDisplay-CurrentMeasuresPage*4];
      back_color = first_param_rect->color;
      
      if (CurrentParam == GetActiveBitIndex(params_on_mainscreen_mask, 0))
      {
        GetMeasureStringNoUnits(CurrentDisplay, GetActiveBitIndex(params_on_mainscreen_mask, 0), value, &color);
        //TFT_FillRect_(*first_param_rect, back_color);
        //actual_text_rect = TFT_WriteStringInRectCenter(value, color, back_color, *first_param_rect, 0, 0, &Tahoma87);
        
        GetParamUnits(CurrentDisplay, CurrentParam, units);
        //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY, &Tahoma34);
        
        GUI_SmartWriteBigMeasureInRectCenter(value, color, units, BLACK, (RECT*)first_param_rect, back_color);
      }
      if (CurrentParam == GetActiveBitIndex(params_on_mainscreen_mask, 1))
      {
        GetMeasureStringNoUnits(CurrentDisplay, GetActiveBitIndex(params_on_mainscreen_mask, 1), value, &color);
        //TFT_FillRect_(*second_param_rect, back_color);
        //actual_text_rect = TFT_WriteStringInRectCenter(value, color, back_color, *second_param_rect, 0, 0, &Tahoma87);
        
        GetParamUnits(CurrentDisplay, CurrentParam, units);
        //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY, &Tahoma34);
        
        GUI_SmartWriteBigMeasureInRectCenter(value, color, units, BLACK, (RECT*)second_param_rect, back_color);
      }
    }
    if (params_on_mainscreen_count == 1)
    {
      first_param_rect = PARAMS_WIDE_UD[CurrentDisplay-CurrentMeasuresPage*4];
      
      back_color = first_param_rect->color;
      GetMeasureStringNoUnits(CurrentDisplay, GetActiveBitIndex(params_on_mainscreen_mask, 0), value, &color);
      //TFT_FillRect_(*first_param_rect, back_color);
      //actual_text_rect = TFT_WriteStringInRectCenter(value, color, back_color, *first_param_rect, 0, 0, &Tahoma87);
      
      GetParamUnits(CurrentDisplay, CurrentParam, units);
      //TFT_WriteString(units, BLACK, actual_text_rect.color, actual_text_rect.eX+11, actual_text_rect.sY, &Tahoma34);
      
      GUI_SmartWriteBigMeasureInRectCenter(value, color, units, BLACK, (RECT*)first_param_rect, back_color);
    }
  }
  if (!BackToAllChannels)
  {
    GetMeasureString(CurrentDisplay, CurrentParam, value, &color);
    int k = DisplayConfig[CurrentDisplay].ParamConfig[CurrentParam] & PARAM_PLACEMENT_MASK;
    if (k >= 12) k = 11;
    RECT placement = *VALUES_LR[k];
    back_color = (*BORDER_BUTTONS_UD[CurrentDisplay-CurrentMeasuresPage*4]).color;
    //TFT_FillRect_(placement, back_color);
    //TFT_WriteStringInRectCenter(display, color, back_color, placement, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter(value, color, back_color, &placement, &Tahoma34);
  }
}

void GUI_TouchParamRootScreen4()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, MENU0_LEFT))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawParamThreshAndConstScreen, GUI_UpdateParamThreshAndConstScreen, GUI_TouchParamThreshAndConstScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MENU1_LEFT))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawParamStateScreen, GUI_UpdateParamStateScreen, GUI_TouchParamStateScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }

  if (TFT_CoordsInRect(X, Y, BODY))
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
}

void GUI_DrawParamThreshAndConstScreen()
{
  char display[30];
  sprintf(display, "Канал %d", CurrentDisplay+1);
  
  Int8U channels_count = GetDisplayChannelsCount();
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  GUI_DrawHeader(BACK_60x60, true, BACKWARD_60x60, !((CurrentDisplay == 0) && (CurrentParam == 0)), FORWARD_60x60, !((CurrentDisplay == channels_count-1) && (CurrentParam == params_count-1)), "Измерение", display);

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  GetParamNameAndUnits(CurrentDisplay, CurrentParam, display);
  TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 5, PARAMETER_34x34, display);

  Int8U decimal = MeasureAttribute[DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam]].DecPoint;
  
  TFT_WriteStringInRectCenter("Порог 1", BLACK, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma34);
  sprintf(display, "%s", THRESHOLD_TYPES[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2].Up]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, LEFT_MIDDLE_TOP, 0, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, CENTER_MIDDLE_TOP, 0, 0, &Tahoma34);
  sprintf(display, "%s", THRESHOLD_WEIGHTS[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2].Weight]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, RIGHT_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE_TOP, BLACK, 1, 40, 0);

  TFT_WriteStringInRectCenter("Порог 2", BLACK, EVEN_GREEN, MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  sprintf(display, "%s", THRESHOLD_TYPES[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+1].Up]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+1]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma34);
  sprintf(display, "%s", THRESHOLD_WEIGHTS[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+1].Weight]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER_TOP, BLACK, 1, 40, 0);
  
  Int8U const_decimal;
  Int16U color;
  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].ShowStat != DO_NOT_SHOW)
  {
    const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].DecPoint;
    TFT_WriteStringInRectCenter("Константа 1", BLACK, EVEN_GREEN, LEFTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
    DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].Name[8] = 0;
    sprintf(display, "%s", DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].Name);
    TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    sprintf(display, "%.*f", const_decimal, DisplayConfig[CurrentDisplay].Constant[CurrentParam*2]);
    color = (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].ShowStat == SHOW_AN_EDIT) ? DARKGREEN : BROWN;
    TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, LEFTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma34);
  }

  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].ShowStat != DO_NOT_SHOW)
  {
    const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].DecPoint;
    TFT_WriteStringInRectCenter("Константа 2", BLACK, EVEN_GREEN, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
    DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].Name[8] = 0;
    sprintf(display, "%s", DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].Name);
    TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    sprintf(display, "%.*f", const_decimal, DisplayConfig[CurrentDisplay].Constant[CurrentParam*2+1]);
    color = (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].ShowStat == SHOW_AN_EDIT) ? DARKGREEN : BROWN;
    TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma34);
  }
  
  GUI_UpdateParamThreshAndConstScreen();
}

void GUI_UpdateParamThreshAndConstScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchParamThreshAndConstScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  Int8U channels_count = GetDisplayChannelsCount();
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (!((CurrentDisplay == 0) && (CurrentParam == 0)))
    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
    {
      set_sound(S_SOUND_20);
      DecrementDisplayParam(&CurrentDisplay, &CurrentParam);
      CurrentMeasuresPage = CurrentDisplay / 8;
      GUI_DrawParamThreshAndConstScreen();
      return;
    }
  
  if (!((CurrentDisplay == channels_count-1) && (CurrentParam == params_count-1)))
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      IncrementDisplayParam(&CurrentDisplay, &CurrentParam);
      CurrentMeasuresPage = CurrentDisplay / 8;
      GUI_DrawParamThreshAndConstScreen();
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER_BOTTOM) || TFT_CoordsInRect(X, Y, MIDDLE_TOP))
  {
    set_sound(S_SOUND_20);
    CurrentThreshold = 0;
    GUI_SetGUI(GUI_DrawThresholdConfigScreen, GUI_UpdateThresholdConfigScreen, GUI_TouchThresholdConfigScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MIDDLE_BOTTOM) || TFT_CoordsInRect(X, Y, LOWER_TOP))
  {
    set_sound(S_SOUND_20);
    CurrentThreshold = 1;
    GUI_SetGUI(GUI_DrawThresholdConfigScreen, GUI_UpdateThresholdConfigScreen, GUI_TouchThresholdConfigScreen);
    return;
  }
  
  Int8U const_decimal;
  char display[32], param[32];
  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].ShowStat == SHOW_AN_EDIT)
  {
    if (TFT_CoordsInRect(X, Y, LEFTHALF_LOWER_BOTTOM) || TFT_CoordsInRect(X, Y, LEFTHALF_LOWERMOST_TOP) || TFT_CoordsInRect(X, Y, LEFTHALF_LOWERMOST_BOTTOM))
    {
      set_sound(S_SOUND_20);
      GetParamString(CurrentDisplay, CurrentParam, param);
      sprintf(display, "%s: константа 1", param);
      const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2].DecPoint;
      if (GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[CurrentParam*2], "Настройки", display, false, 0, 0, const_decimal))
      {
        OS_Use(&SemaRAM);
        SAVE_CONFIG(DisplayConfig[CurrentDisplay].Constant[CurrentParam*2]);
        OS_Unuse(&SemaRAM);
      }
      GUI_DrawParamThreshAndConstScreen();
    }
  }
  
  if (DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].ShowStat == SHOW_AN_EDIT)
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER_BOTTOM) || TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST_TOP) || TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST_BOTTOM))
    {
      set_sound(S_SOUND_20);
      GetParamString(CurrentDisplay, CurrentParam, param);
      sprintf(display, "%s: константа 2", param);
      const_decimal = DisplayConfig[CurrentDisplay].ConstConfig[CurrentParam*2+1].DecPoint;
      if (GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Constant[CurrentParam*2+1], "Настройки", display, false, 0, 0, const_decimal))
      {
        OS_Use(&SemaRAM);
        SAVE_CONFIG(DisplayConfig[CurrentDisplay].Constant[CurrentParam*2+1]);
        OS_Unuse(&SemaRAM);
      }
      GUI_DrawParamThreshAndConstScreen();
    }
  }
}

void GUI_DrawParamStateScreen()
{
  char display[32];
  sprintf(display, "Канал %d", CurrentDisplay+1);

  Int8U channels_count = GetDisplayChannelsCount();
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  GUI_DrawHeader(BACK_60x60, true, BACKWARD_60x60, !((CurrentDisplay == 0) && (CurrentParam == 0)), FORWARD_60x60, !((CurrentDisplay == channels_count-1) && (CurrentParam == params_count-1)), "Измерение", display);

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  GetParamNameAndUnits(CurrentDisplay, CurrentParam, display);
  TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 5, PARAMETER_34x34, display);

  GUI_UpdateParamStateScreen();
}

void GUI_UpdateParamStateScreen()
{
  GUI_UpdateHeader();
  
  Int8U param_index = DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam];
  
  int row = 1;
  if (ErrorArray[param_index] == NO_ERR)
  {
    //TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    //TFT_WriteStringInRectCenter("Ошибок не обнаружено", BROWN, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("Ошибок не обнаружено", BROWN, EVEN_GREEN, (RECT*)LINES_SMALL[row], &Tahoma34);
    row++;
  }

  if (ErrorArray[param_index] & CONNECT_ERR)
  {
    //TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    //TFT_WriteStringInRectCenter("Ошибка связи с преобразователем", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("Ошибка связи с преобразователем", RED, EVEN_GREEN, (RECT*)LINES_SMALL[row], &Tahoma34);
    row++;
  }
    
  if (ErrorArray[param_index] & LOWLIMIT_ERR)
  {
    //TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    //TFT_WriteStringInRectCenter("Нарушение нижней границы", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("Нарушение нижней границы", RED, EVEN_GREEN, (RECT*)LINES_SMALL[row], &Tahoma34);
    row++;
  }
    
  if (ErrorArray[param_index] & UPLIMIT_ERR)
  {
    //TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    //TFT_WriteStringInRectCenter("Нарушение верхней границы", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("Нарушение верхней границы", RED, EVEN_GREEN, (RECT*)LINES_SMALL[row], &Tahoma34);
    row++;
  }
   
  if (ErrorArray[param_index] & INTERNAL_ERR)
  {
    //TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    //TFT_WriteStringInRectCenter("Внутренняя ошибка преобразователя", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("Внутренняя ошибка преобразователя", RED, EVEN_GREEN, (RECT*)LINES_SMALL[row], &Tahoma34);
    row++;
  }
    
  if (ErrorArray[param_index] & (COMPLEX_ERR | ASSIGNED_ERR))
  {
    //TFT_FillRect_(*LINES_SMALL[row], EVEN_GREEN);
    //TFT_WriteStringInRectCenter("Ошибка пересчёта", RED, EVEN_GREEN, *LINES_SMALL[row], 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("Ошибка пересчёта", RED, EVEN_GREEN, (RECT*)LINES_SMALL[row], &Tahoma34);
    row++;
  }
  
  //TFT_UnderlineRect_Offset(*LINES_SMALL[row-1], BLACK, 1, 40, 0);
  
  for (int i = row; i < 7; i++)
    TFT_FillRect_(*LINES_SMALL[i], EVEN_GREEN);
}

void GUI_TouchParamStateScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  Int8U channels_count = GetDisplayChannelsCount();
  Int8U params_count = GetDisplayChannelParamsCount(CurrentDisplay);
  if (!((CurrentDisplay == 0) && (CurrentParam == 0)))
    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
    {
      set_sound(S_SOUND_20);
      DecrementDisplayParam(&CurrentDisplay, &CurrentParam);
      CurrentMeasuresPage = CurrentDisplay / 8;
      GUI_DrawParamStateScreen();
      return;
    }
  
  if (!((CurrentDisplay == channels_count-1) && (CurrentParam == params_count-1)))
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      IncrementDisplayParam(&CurrentDisplay, &CurrentParam);
      CurrentMeasuresPage = CurrentDisplay / 8;
      GUI_DrawParamStateScreen();
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (BackToAllChannels) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
}

void GUI_DrawThresholdConfigScreen()
{
  char display[30], param[32];
  GetParamString(CurrentDisplay, CurrentParam, param);
  sprintf(display, "%s: порог %d", param, CurrentThreshold+1);
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, false, FORWARD_60x60, false, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Тип", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectLeft("Значение", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  Int8U decimal = MeasureAttribute[DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam]].DecPoint;
  sprintf(display, "%.*f", decimal, DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Важность", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);

  GUI_UpdateThresholdConfigScreen();
  GUI_ManualUpdateThresholdConfigScreen();
}

void GUI_UpdateThresholdConfigScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateThresholdConfigScreen()
{
  char display[32];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", THRESHOLD_TYPES[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Up]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  sprintf(display, "%s", THRESHOLD_WEIGHTS[DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Weight]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchThresholdConfigScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold]);
    SAVE_CONFIG(DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawParamThreshAndConstScreen, GUI_UpdateParamThreshAndConstScreen, GUI_TouchParamThreshAndConstScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold]);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold]);
    LOAD_CONFIG(DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawParamThreshAndConstScreen, GUI_UpdateParamThreshAndConstScreen, GUI_TouchParamThreshAndConstScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Up++;
    GUI_ManualUpdateThresholdConfigScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    char display[32], param[32];
    Int8U decimal = MeasureAttribute[DisplayConfig[CurrentDisplay].DisplayParam[CurrentParam]].DecPoint;
    float min, max;
    GetParamMinMax(CurrentDisplay, CurrentParam, &min, &max);
    GetParamString(CurrentDisplay, CurrentParam, param);
    //sprintf(param, "param");
    sprintf(display, "%s: порог %d", param, CurrentThreshold+1);
    GUI_KeyboardFloat(&DisplayConfig[CurrentDisplay].Treshold[CurrentParam*2+CurrentThreshold], "Настройки", display, false, min, max, decimal);
    GUI_DrawThresholdConfigScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    DisplayConfig[CurrentDisplay].TreshConfig[CurrentParam*2+CurrentThreshold].Weight++;
    GUI_ManualUpdateThresholdConfigScreen();
    return;
  }
}

void GUI_DrawControlsScreen()
{
  if (CurrentControlsPage == 0)
    GUI_DrawHeader(SWITCH_60x60, true, BACKWARD_60x60, false, FORWARD_60x60, true, "Управление", "Каналы 1 - 8");
  if (CurrentControlsPage == 1)
    GUI_DrawHeader(SWITCH_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Управление", "Каналы 9 - 16");
  
  TFT_DrawRect(BODY);
  
  char display[30];
  for (int i = CurrentControlsPage*8; i < CurrentControlsPage*8+8; i++)
  {
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      sprintf(display, "Реле %d", i+1);
      TFT_DrawRoundedRect_OffsetWithImageAndCaption(*CONTROLS[i-CurrentControlsPage*8], ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 1, 1, RELAY_34x34, display);
    }
    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      sprintf(display, "Ток %d", i+1);
      TFT_DrawRoundedRect_OffsetWithImageAndCaption(*CONTROLS[i-CurrentControlsPage*8], ODD_BLUE, EVEN_BLUE, BACKGROUND_COLOR, 1, 1, CURRENT_34x34, display);
    }
  }
  
  if (ControlScreen == csDetail)
    GUI_DrawDetailControls();
  if (ControlScreen == csBrief)
    GUI_DrawBriefControls();

  GUI_UpdateControlsScreen();
}

void GUI_UpdateControlsScreen()
{
  GUI_UpdateHeader();
  
  if (ControlScreen == csDetail)
    GUI_UpdateDetailControls();
  if (ControlScreen == csBrief)
    GUI_UpdateBriefControls();
}

void GUI_TouchControlsScreen()
{
  Int16U X, Y;
  Int8U button =  TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (ControlScreen == csDetail)
    {
      ControlScreen = csBrief;
      GUI_DrawBriefControls();
    }
    else if (ControlScreen == csBrief)
    {
      ControlScreen = csDetail;
      GUI_DrawDetailControls();
    }   
    GUI_UpdateControlsScreen();
    return;
  }
  
  if (CurrentControlsPage == 0)
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentControlsPage = 1;
      GUI_DrawControlsScreen();
      return;
    }

  if (CurrentControlsPage == 1)
    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentControlsPage = 0;
      GUI_DrawControlsScreen();
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  for (int i = CurrentControlsPage*8; i < CurrentControlsPage*8+8; i++)
  {
    if (TFT_CoordsInRect(X, Y, *CONTROLS[i-CurrentControlsPage*8]))
    {
      set_sound(S_SOUND_20);
      CurrentControl = i;
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
}

void GUI_DrawDetailControls()
{
  char param[20], control_type[20], info[20];
  for (int i = CurrentControlsPage*8; i < CurrentControlsPage*8+8; i++)
  {
    GetControlChannelInputParamString(OutConfig[i].Input, param);
    
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      sprintf(control_type, "%s", RELAY_CONTROL_TYPES[OutConfig[i].CntrAttr]);      
      if (OutConfig[i].CntrAttr == OFF_CONTROL)
      {
        TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
        TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, *CONTROLS_TOP[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_GREEN, *CONTROLS_MIDDLE[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_FillRect_Offset(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
      }
      if (OutConfig[i].CntrAttr == LOGIC_CONTROL)
      {
        TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_GREEN, *CONTROLS_TOP[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_GREEN, *CONTROLS_MIDDLE[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_FillRect_Offset(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
      }
      if (OutConfig[i].CntrAttr == HEST_CONTROL)
      {
        TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_GREEN, *CONTROLS_TOP[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_GREEN, *CONTROLS_MIDDLE[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_FillRect_Offset(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
        if (OutConfig[i].ProgUse)
          TFT_WriteStringInRectCenter("Программа", BLACK, EVEN_GREEN, *CONTROLS_BOTTOM[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
      }
    }
    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      sprintf(control_type, "%s", CURRENT_CONTROL_TYPES[OutConfig[i].CntrAttr]);
      if (OutConfig[i].CntrAttr == OFF_CONTROL)
      {
        TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
        TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, *CONTROLS_TOP[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_BLUE, *CONTROLS_MIDDLE[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_FillRect_Offset(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
        sprintf(info, "%s", CURRENT_TYPES[OutConfig[i].ChanelType]);
        TFT_WriteStringInRectCenter(info, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
      }
      if (OutConfig[i].CntrAttr == LOGIC_CONTROL)
      {
        TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_BLUE, *CONTROLS_TOP[i-CurrentControlsPage*8], 0, 0, &Tahoma34);        
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_BLUE, *CONTROLS_MIDDLE[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_FillRect_Offset(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
        sprintf(info, "%s", CURRENT_TYPES[OutConfig[i].ChanelType]);
        TFT_WriteStringInRectCenter(info, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
      }
      if (OutConfig[i].CntrAttr == LINE_CONTROL)
      {
        TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
        TFT_WriteStringInRectCenter(param, BLACK, EVEN_BLUE, *CONTROLS_TOP[i-CurrentControlsPage*8], 0, 0, &Tahoma34);        
        TFT_WriteStringInRectCenter(control_type, BLACK, EVEN_BLUE, *CONTROLS_MIDDLE[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
        TFT_FillRect_Offset(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
        sprintf(info, "%s", CURRENT_TYPES[OutConfig[i].ChanelType]);
        TFT_WriteStringInRectCenter(info, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
      }
    }
  }
}

void GUI_UpdateDetailControls()
{
  // NO OP REQUIRED
}

void GUI_DrawBriefControls()
{
  for (int i = CurrentControlsPage*8; i < CurrentControlsPage*8+8; i++)
  {
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_GREEN, 1, 0);
    }
    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      TFT_FillRect_Offset(*CONTROLS_IMAGE[i-CurrentControlsPage*8], EVEN_BLUE, 1, 0);
    }
  }
}

void GUI_UpdateBriefControls()
{
  char display[20];
  for (int i = CurrentControlsPage*8; i < CurrentControlsPage*8+8; i++)
  {
    if (OutConfig[i].ChanelType == RELAY_TYPE)
    {
      if ((RelayOuts >> i) & 1)
      {
        GUI_DrawImageInRectCenterSwapColor(RELAY_UP_60x60, *CONTROLS_IMAGE[i-CurrentControlsPage*8], TEMPLATE_COLOR, EVEN_GREEN);
        sprintf(display, "Замкнуто");
      }
      else
      {
        GUI_DrawImageInRectCenterSwapColor(RELAY_DOWN_60x60, *CONTROLS_IMAGE[i-CurrentControlsPage*8], TEMPLATE_COLOR, EVEN_GREEN);
        sprintf(display, "Разомкнуто");
      }
      //TFT_FillRect_(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_GREEN);
      //TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, *CONTROLS_BOTTOM[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
      TFT_SmartWriteStringInRectCenter(display, BLACK, EVEN_GREEN, (RECT*)CONTROLS_BOTTOM[i-CurrentControlsPage*8], &Tahoma34);
    }

    if ((OutConfig[i].ChanelType >= ANALOG_TYPE_05) && (OutConfig[i].ChanelType <= ANALOG_TYPE_420))
    {
      GUI_DrawImageInRectCenterSwapColor(CURRENT_ON_60x60, *CONTROLS_IMAGE[i-CurrentControlsPage*8], TEMPLATE_COLOR, EVEN_BLUE);
      //TFT_FillRect_(*CONTROLS_BOTTOM[i-CurrentControlsPage*8], EVEN_BLUE);
      sprintf(display, "%.1f", OutCurrents[i]);
      //TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, *CONTROLS_BOTTOM[i-CurrentControlsPage*8], 0, 0, &Tahoma34);
      TFT_SmartWriteStringInRectCenter(display, BLACK, EVEN_BLUE, (RECT*)CONTROLS_BOTTOM[i-CurrentControlsPage*8], &Tahoma34);
    }
  }
}

void GUI_DrawControlScreen()
{
  char display[20];
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    sprintf(display, "Канал %d (реле)", CurrentControl+1);
    GUI_DrawHeader(SETTINGS_RELAY_60x60, true, BACKWARD_60x60, CurrentControl > 0, FORWARD_60x60, CurrentControl < 15, "Управление", display);
  }
  else
  {
    sprintf(display, "Канал %d (ток)", CurrentControl+1);
    GUI_DrawHeader(SETTINGS_CURRENT_60x60, true, BACKWARD_60x60, CurrentControl > 0, FORWARD_60x60, CurrentControl < 15, "Управление", display);
  }
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    sprintf(display, "Реле %d", CurrentControl+1);
    TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_GREEN, EVEN_GREEN, BACKGROUND_COLOR, 0, 5, RELAY_34x34, display);
  }
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    sprintf(display, "Ток %d", CurrentControl+1);
    TFT_DrawRoundedRect_OffsetWithImageAndCaption(BODY, ODD_BLUE, EVEN_BLUE, BACKGROUND_COLOR, 0, 5, CURRENT_34x34, display);
  }
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_DrawControlRelayManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_DrawControlRelayLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_DrawControlRelayHesterScreen();
  }
  
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_DrawControlCurrentManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_DrawControlCurrentLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_DrawControlCurrentLineoutScreen();
  }
  
  GUI_UpdateControlScreen();
}

void GUI_UpdateControlScreen()
{
  GUI_UpdateHeader();
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_UpdateControlRelayManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_UpdateControlRelayLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_UpdateControlRelayHesterScreen();
  }
  
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_UpdateControlCurrentManualScreen();
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_UpdateControlCurrentLogicScreen();
    if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_UpdateControlCurrentLineoutScreen();
  }
}

void GUI_TouchControlScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawRelayConfigurationCommonScreen, GUI_UpdateRelayConfigurationCommonScreen, GUI_TouchRelayConfigurationCommonScreen);
      return;
    }
    if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawCurrentConfigurationCommonScreen, GUI_UpdateCurrentConfigurationCommonScreen, GUI_TouchCurrentConfigurationCommonScreen);
      return;
    }
  }
  
  if (CurrentControl > 0)
    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentControl--;
      CurrentControlsPage = CurrentControl / 8;
      GUI_DrawControlScreen();
      return;
    }
  
  if (CurrentControl < 15)
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentControl++;
      CurrentControlsPage = CurrentControl / 8;
      GUI_DrawControlScreen();
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (OutConfig[CurrentControl].ChanelType == RELAY_TYPE)
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_TouchControlRelayManualScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_TouchControlRelayLogicScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_TouchControlRelayHesterScreen(X, Y);
    return;
  }
  
  if ((OutConfig[CurrentControl].ChanelType >= ANALOG_TYPE_05) && (OutConfig[CurrentControl].ChanelType <= ANALOG_TYPE_420))
  {
    if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)   GUI_TouchControlCurrentManualScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_TouchControlCurrentLogicScreen(X, Y);
    if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_TouchControlCurrentLineoutScreen(X, Y);
    return;
  }
}

void GUI_DrawControlRelayManualScreen()
{
  TFT_WriteStringInRectCenter("Ручное управление", BROWN, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_MIDDLE_TOP, 0, 0, &Tahoma34);
  
  TFT_DrawRoundedRect_Offset(CENTER_LOWER, ODD_GREEN, ODD_GREEN, EVEN_GREEN, 0, 1);
  TFT_WriteStringInRectCenter("Нажмите для переключения", BLACK, EVEN_GREEN, LOWERMOST_TOP, 0, 0, &Tahoma34);
}

void GUI_UpdateControlRelayManualScreen()
{
  //TFT_FillRect_(RIGHTHALF_MIDDLE_TOP, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
  {
    //TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_MIDDLE_TOP, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_MIDDLE_TOP, &Tahoma34);
    GUI_DrawImageInRectCenterSwapColor(RELAY_UP_60x60, CENTER_LOWER, TEMPLATE_COLOR, ODD_GREEN);
  }
  else
  {
    //TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_MIDDLE_TOP, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_MIDDLE_TOP, &Tahoma34);
    GUI_DrawImageInRectCenterSwapColor(RELAY_DOWN_60x60, CENTER_LOWER, TEMPLATE_COLOR, ODD_GREEN);
  }
}

void GUI_TouchControlRelayManualScreen(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, CENTER_LOWER))
  {
    set_sound(S_SOUND_20);
    Int16U mask = (1 << CurrentControl);
    if (ManualControl & mask)
      ManualControl &= ~mask;
    else
      ManualControl |= mask;
    GUI_UpdateControlRelayManualScreen();
    return;
  }
}

void GUI_DrawControlRelayLogicScreen()
{
  char display[32];
  TFT_WriteStringInRectCenter("Логическое управление", BROWN, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER_BOTTOM, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Срабатывание на:", BLACK, EVEN_GREEN, MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma34);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma34);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
    TFT_WriteStringInRectCenter("Ошибки", BROWN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma34);
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].ControlType)
    TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma34);
  else
    TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
}

void GUI_UpdateControlRelayLogicScreen()
{
  char display[32];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  //TFT_FillRect_(RIGHT_MIDDLE_TOP, EVEN_GREEN);
  //TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHT_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, color, EVEN_GREEN, (RECT*)&RIGHT_MIDDLE_TOP, &Tahoma34);
  
  //TFT_FillRect_(RIGHTHALF_LOWERMOST_TOP, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
    //TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_LOWERMOST_TOP, &Tahoma34);
  else
    //TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_LOWERMOST_TOP, &Tahoma34);
}

void GUI_TouchControlRelayLogicScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawControlRelayHesterScreen()
{
  if (OutConfig[CurrentControl].ProgUse)
    GUI_DrawControlRelayHesterProgrammScreen();
  else
    GUI_DrawControlRelayHesterNoProgrammScreen();
}

void GUI_UpdateControlRelayHesterScreen()
{
  if (OutConfig[CurrentControl].ProgUse)
    GUI_UpdateControlRelayHesterProgrammScreen();
  else
    GUI_UpdateControlRelayHesterNoProgrammScreen();
}

void GUI_TouchControlRelayHesterScreen(Int16U X, Int16U Y)
{
  if (OutConfig[CurrentControl].ProgUse)
    GUI_TouchControlRelayHesterProgrammScreen(X, Y);
  else
    GUI_TouchControlRelayHesterNoProgrammScreen(X, Y);
}

void GUI_DrawControlRelayHesterNoProgrammScreen()
{
  char display[32];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  TFT_WriteStringInRectCenter("Гистерезис (без программы)", BROWN, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER_BOTTOM, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Рег. значение:", BLACK, EVEN_GREEN, LEFTHALF_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Гистерезис:", BLACK, EVEN_GREEN, LEFTHALF_LOWER_TOP, 0, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].Hesteresis);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].ControlType)
    TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma34);
  else
    TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_GREEN, LOWER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
}

void GUI_UpdateControlRelayHesterNoProgrammScreen()
{
  char display[32];
  Int16U color;
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  //TFT_FillRect_(RIGHT_MIDDLE_TOP, EVEN_GREEN);
  //TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHT_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, color, EVEN_GREEN, (RECT*)&RIGHT_MIDDLE_TOP, &Tahoma34);
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    char param[32], value[32];
    GetControlChannelInputParamString((Int8U)OutConfig[CurrentControl].DefParam, param);
    GetControlChannelInputMeasureStringNoUnits((Int8U)OutConfig[CurrentControl].DefParam, value, &color);
    sprintf(display, "%s: %s", param, value);
    //TFT_FillRect_(RIGHT_MIDDLE_BOTTOM, EVEN_GREEN);
    //TFT_WriteStringInRectCenter(display, DEEPBLUE, EVEN_GREEN, RIGHT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter(display, DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHT_MIDDLE_BOTTOM, &Tahoma34);
  }
  else
  {
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
    //TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, RIGHT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter(display, BROWN, EVEN_GREEN, (RECT*)&RIGHT_MIDDLE_BOTTOM, &Tahoma34);
  }
  
  //TFT_FillRect_(RIGHTHALF_LOWERMOST_TOP, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
    //TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_LOWERMOST_TOP, &Tahoma34);
  else
    //TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_LOWERMOST_TOP, &Tahoma34);
}

void GUI_TouchControlRelayHesterNoProgrammScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawControlRelayHesterProgrammScreen()
{
  char display[32];
  TFT_WriteStringInRectCenter("Гистерезис (по программе)", BROWN, EVEN_GREEN, UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER_BOTTOM, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_GREEN, LEFTHALF_MIDDLE_TOP, 0, 0, &Tahoma34);
  
  TFT_WriteStringInRectCenter("Параметр", BLACK, EVEN_GREEN, LEFT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Гистерезис", BLACK, EVEN_GREEN, CENTER_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Шаг", BLACK, EVEN_GREEN, RIGHT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].Hesteresis);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, CENTER_LOWER_TOP, 0, 0, &Tahoma34);
  
  TFT_WriteStringInRectCenter("Состояние:", BLACK, EVEN_GREEN, LEFTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
}

void GUI_UpdateControlRelayHesterProgrammScreen()
{
  char display[32];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  //TFT_FillRect_(RIGHT_MIDDLE_TOP, EVEN_GREEN);
  //TFT_WriteStringInRectCenter(display, color, EVEN_GREEN, RIGHT_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, color, EVEN_GREEN, (RECT*)&RIGHT_MIDDLE_TOP, &Tahoma34);
  
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  int index = ProgramStatus[CurrentControl].CurrentStep;
  if ((ProgramStatus[CurrentControl].ProgFinished) && (OutConfig[CurrentControl].EndProgCond == ENDP_LOADDEF))
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
  else
    sprintf(display, "%.*f", decimal, Program[index].Param);
  //TFT_FillRect_(LEFT_LOWER_TOP, EVEN_GREEN);
  //TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, LEFT_LOWER_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, BROWN, EVEN_GREEN, (RECT*)&LEFT_LOWER_TOP, &Tahoma34);
  
  sprintf(display, "%d/%d/%d", OutConfig[CurrentControl].StartStep+1, index+1, OutConfig[CurrentControl].StopStep+1);
  //TFT_FillRect_(RIGHT_LOWER_TOP, EVEN_GREEN);
  //TFT_WriteStringInRectCenter(display, BROWN, EVEN_GREEN, RIGHT_LOWER_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, BROWN, EVEN_GREEN, (RECT*)&RIGHT_LOWER_TOP, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER_TOP, BLACK, 1, 40, 0);
  
  //TFT_FillRect_(RIGHTHALF_LOWER_BOTTOM, EVEN_GREEN);
  if ((RelayOuts >> CurrentControl) & 1)
    //TFT_WriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("ЗАМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_LOWER_BOTTOM, &Tahoma34);
  else
    //TFT_WriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
    TFT_SmartWriteStringInRectCenter("РАЗОМКНУТО", DEEPBLUE, EVEN_GREEN, (RECT*)&RIGHTHALF_LOWER_BOTTOM, &Tahoma34);
  
  if (ProgramStatus[CurrentControl].ProgStatus == PAUSE_PROGRAM)
    GUI_DrawImageInRectCenterSwapColor(PAUSE_60x60, LEFT_LOWERMOST, TEMPLATE_COLOR, EVEN_GREEN);
  else
    GUI_DrawImageInRectCenterSwapColor(PAUSE_GRAYED_60x60, LEFT_LOWERMOST, TEMPLATE_COLOR, EVEN_GREEN);
  
  if ((ProgramStatus[CurrentControl].ProgStatus == START_PROGRAM) || (ProgramStatus[CurrentControl].ProgStatus == WORK_PROGRAM))
    GUI_DrawImageInRectCenterSwapColor(PLAY_60x60, CENTER_LOWERMOST, TEMPLATE_COLOR, EVEN_GREEN);
  else
    GUI_DrawImageInRectCenterSwapColor(PLAY_GRAYED_60x60, CENTER_LOWERMOST, TEMPLATE_COLOR, EVEN_GREEN);

  if (ProgramStatus[CurrentControl].ProgStatus == STOP_PROGRAM)
    GUI_DrawImageInRectCenterSwapColor(STOP_60x60, RIGHT_LOWERMOST, TEMPLATE_COLOR, EVEN_GREEN);
  else
    GUI_DrawImageInRectCenterSwapColor(STOP_GRAYED_60x60, RIGHT_LOWERMOST, TEMPLATE_COLOR, EVEN_GREEN);
}

void GUI_TouchControlRelayHesterProgrammScreen(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, LEFT_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    ProgramStatus[CurrentControl].ProgStatus = PAUSE_PROGRAM;
    GUI_UpdateControlRelayHesterProgrammScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, CENTER_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    ProgramStatus[CurrentControl].ProgStatus = START_PROGRAM;
    GUI_UpdateControlRelayHesterProgrammScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHT_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    ProgramStatus[CurrentControl].ProgStatus = STOP_PROGRAM;
    GUI_UpdateControlRelayHesterProgrammScreen();
    return;
  }
}

void GUI_DrawControlCurrentManualScreen()
{
  char display[32];
  TFT_WriteStringInRectCenter("Выходной диапазон:", BLACK, EVEN_BLUE, LEFTHALF_UPPER_BOTTOM, 0, 0, &Tahoma34);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Ручное управление", BROWN, EVEN_BLUE, MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE_TOP, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Выход, мА:", BLACK, EVEN_BLUE, LEFTHALF_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  
  TFT_DrawRoundedRect_Offset(CENTER_LOWER, ODD_BLUE, ODD_BLUE, EVEN_BLUE, 0, 1);
  TFT_WriteStringInRectCenter("Нажмите для переключения", BLACK, EVEN_BLUE, LOWERMOST_TOP, 0, 0, &Tahoma34);
}

void GUI_UpdateControlCurrentManualScreen()
{
  char display[30];
  //TFT_FillRect_(RIGHTHALF_MIDDLE_BOTTOM, EVEN_BLUE);
  sprintf(display, "%.1f", OutCurrents[CurrentControl]);
  //TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, BROWN, EVEN_BLUE, (RECT*)&RIGHT_MIDDLE_BOTTOM, &Tahoma34);
  
  if ((ManualControl >> CurrentControl) & 1)
    GUI_DrawImageInRectCenterSwapColor(CURRENT_ON_60x60, CENTER_LOWER, TEMPLATE_COLOR, ODD_BLUE);
  else
    GUI_DrawImageInRectCenterSwapColor(CURRENT_OFF_60x60, CENTER_LOWER, TEMPLATE_COLOR, ODD_BLUE);
}

void GUI_TouchControlCurrentManualScreen(Int16U X, Int16U Y)
{
  if (TFT_CoordsInRect(X, Y, CENTER_LOWER))
  {
    set_sound(S_SOUND_20);
    Int16U mask = (1 << CurrentControl);
    if (ManualControl & mask)
      ManualControl &= ~mask;
    else
      ManualControl |= mask;
    GUI_UpdateControlCurrentManualScreen();
    return;
  }
}

void GUI_DrawControlCurrentLogicScreen()
{
  char display[32];
  TFT_WriteStringInRectCenter("Выходной диапазон:", BLACK, EVEN_BLUE, LEFTHALF_UPPER_BOTTOM, 0, 0, &Tahoma34);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Логическое управление", BROWN, EVEN_BLUE, MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE_TOP, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, LEFTHALF_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Срабатывание на:", BLACK, EVEN_BLUE, LOWER_TOP, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, LEFT_LOWER_BOTTOM, 0, 0, &Tahoma34);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, LEFT_LOWER_BOTTOM, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, CENTER_LOWER_BOTTOM, 0, 0, &Tahoma34);
  }
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, CENTER_LOWER_BOTTOM, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
    TFT_WriteStringInRectCenter("Ошибки", BROWN, EVEN_BLUE, RIGHT_LOWER_BOTTOM, 0, 0, &Tahoma34);
  else
    TFT_WriteStringInRectCenter("---", BLACK, EVEN_BLUE, RIGHT_LOWER_BOTTOM, 0, 0, &Tahoma34);
  if (OutConfig[CurrentControl].ControlType)
    TFT_WriteStringInRectCenter("Выход инвертирован", BROWN, EVEN_BLUE, LOWERMOST_TOP, 0, 0, &Tahoma34);
  else
    TFT_WriteStringInRectCenter("Выход не инвертирован", BROWN, EVEN_BLUE, LOWERMOST_TOP, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWERMOST_TOP, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Выход, мА:", BLACK, EVEN_BLUE, LEFTHALF_LOWERMOST_BOTTOM, 0, 0, &Tahoma34);
}

void GUI_UpdateControlCurrentLogicScreen()
{
  char display[32];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  //TFT_FillRect_(RIGHT_MIDDLE_BOTTOM, EVEN_BLUE);
  //TFT_WriteStringInRectCenter(display, color, EVEN_BLUE, RIGHT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, color, EVEN_BLUE, (RECT*)&RIGHT_MIDDLE_BOTTOM, &Tahoma34);
  
  //TFT_FillRect_Offset(RIGHTHALF_LOWERMOST_BOTTOM, EVEN_BLUE, 13, 10);
  sprintf(display, "%.1f", OutCurrents[CurrentControl]);
  //TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWERMOST_BOTTOM, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter_Offset(display, BROWN, EVEN_BLUE, (RECT*)&RIGHT_LOWERMOST_BOTTOM, 13, 10, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWERMOST_TOP, BLACK, 1, 40, 0);
}

void GUI_TouchControlCurrentLogicScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawControlCurrentLineoutScreen()
{
  char display[32];
  TFT_WriteStringInRectCenter("Выходной диапазон:", BLACK, EVEN_BLUE, LEFTHALF_UPPER_BOTTOM, 0, 0, &Tahoma34);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_UPPER_BOTTOM, 0, 0, &Tahoma34);
  TFT_WriteStringInRectCenter("Линейный выход", BROWN, EVEN_BLUE, MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE_TOP, BLACK, 1, 40, 0);
  
  GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, LEFTHALF_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  sprintf(display, "Значение для %s:", LOWER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, LEFTHALF_LOWER_TOP, 0, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][0]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWER_TOP, 0, 0, &Tahoma34);
  sprintf(display, "Значение для %s:", UPPER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, BLACK, EVEN_BLUE, LEFTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][1]);
  TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWER_BOTTOM, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Выход, мА:", BLACK, EVEN_BLUE, LEFTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
}

void GUI_UpdateControlCurrentLineoutScreen()
{
  char display[32];
  Int16U color;
  GetControlChannelInputMeasureString(OutConfig[CurrentControl].Input, display, &color);
  //TFT_FillRect_(RIGHT_MIDDLE_BOTTOM, EVEN_BLUE);
  //TFT_WriteStringInRectCenter(display, color, EVEN_BLUE, RIGHT_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, color, EVEN_BLUE, (RECT*)&RIGHT_MIDDLE_BOTTOM, &Tahoma34);
  
  //TFT_FillRect_Offset(RIGHTHALF_LOWERMOST_TOP, EVEN_BLUE, 0, 0);
  sprintf(display, "%.1f", OutCurrents[CurrentControl]);
  //TFT_WriteStringInRectCenter(display, BROWN, EVEN_BLUE, RIGHT_LOWERMOST_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, BROWN, EVEN_BLUE, (RECT*)&RIGHT_LOWERMOST_TOP, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER_BOTTOM, BLACK, 1, 40, 0);
}

void GUI_TouchControlCurrentLineoutScreen(Int16U X, Int16U Y)
{
  // NO OP REQUIRED
}

void GUI_DrawRelayConfigurationCommonScreen()
{
  char display[20];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  bool ok_active = OutConfig[CurrentControl].CntrAttr == OFF_CONTROL;
  bool forward_active = OutConfig[CurrentControl].CntrAttr != OFF_CONTROL;
  GUI_DrawHeader(OK_60x60, ok_active, BACKWARD_60x60, false, FORWARD_60x60, forward_active, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Тип управления", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  GUI_UpdateRelayConfigurationCommonScreen();
  GUI_ManualUpdateRelayConfigurationCommonScreen();
}

void GUI_UpdateRelayConfigurationCommonScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateRelayConfigurationCommonScreen()
{
  char display[20];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", RELAY_CONTROL_TYPES[OutConfig[CurrentControl].CntrAttr]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    GUI_DrawHeaderMainButton(OK_60x60, true);
    TFT_GrayoutRect_(HEAD_RBUTTON, BACKGROUND_COLOR);
    TFT_FillRect_(MIDDLE, BACKGROUND_COLOR);
    TFT_FillRect_(LOWER, BACKGROUND_COLOR);
  }
    
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    TFT_GrayoutRect_(HEAD_MAINBUTTON, BACKGROUND_COLOR);
    GUI_DrawHeaderRButton(FORWARD_60x60, true);
    TFT_WriteStringInRectLeft("Управляемый параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
    TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
    GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }
}

void GUI_TouchRelayConfigurationCommonScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
    {
      set_sound(S_SOUND_20);

      OS_Use(&SemaRAM);
      SAVE_CONFIG(OutConfig[CurrentControl]);
      OS_Unuse(&SemaRAM);
    
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
  
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_SetGUI(GUI_DrawRelayConfigurationLogicScreen, GUI_UpdateRelayConfigurationLogicScreen, GUI_TouchRelayConfigurationLogicScreen);
      if (OutConfig[CurrentControl].CntrAttr == HEST_CONTROL)  GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].CntrAttr++;
    if (OutConfig[CurrentControl].CntrAttr > HEST_CONTROL) OutConfig[CurrentControl].CntrAttr = OFF_CONTROL;
    GUI_ManualUpdateRelayConfigurationCommonScreen();
    return;
  }
  
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
    {
      set_sound(S_SOUND_20);
      IncrementControlChannelInputParam(&OutConfig[CurrentControl].Input);
      GUI_ManualUpdateRelayConfigurationCommonScreen();
      return;
    }
  }
}

void GUI_DrawRelayConfigurationLogicScreen()
{
  char display[32];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Порог 1", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Порог 2", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Срабатывание на ошибку", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Инвертировать выход", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWERMOST, 5, 0, &Tahoma34);
  
  GUI_UpdateRelayConfigurationLogicScreen();
  GUI_ManualUpdateRelayConfigurationLogicScreen();
}

void GUI_UpdateRelayConfigurationLogicScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateRelayConfigurationLogicScreen()
{
  char display[32];  
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
  {
    TFT_WriteStringInRectCenter("Да", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ControlType ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);
}

void GUI_TouchRelayConfigurationLogicScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationCommonScreen, GUI_UpdateRelayConfigurationCommonScreen, GUI_TouchRelayConfigurationCommonScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR1;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR1;
    GUI_ManualUpdateRelayConfigurationLogicScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR2;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR2;
    GUI_ManualUpdateRelayConfigurationLogicScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_ERR;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_ERR;
    GUI_ManualUpdateRelayConfigurationLogicScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ControlType = !OutConfig[CurrentControl].ControlType;
    GUI_ManualUpdateRelayConfigurationLogicScreen();
    return;
  }
}

void GUI_DrawRelayConfigurationHesterScreen()
{
  char display[32];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(OK_60x60, !OutConfig[CurrentControl].ProgUse, BACKWARD_60x60, true, FORWARD_60x60, OutConfig[CurrentControl].ProgUse, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Регулируемое значение", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Величина гистерезиса", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Инвертировать выход", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Использовать программу", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWERMOST, 5, 0, &Tahoma34);
 
  GUI_UpdateRelayConfigurationHesterScreen();
  GUI_ManualUpdateRelayConfigurationHesterScreen();
}

void GUI_UpdateRelayConfigurationHesterScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateRelayConfigurationHesterScreen()
{
  char display[32];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  if (OutConfig[CurrentControl].ProgUse)
  {
    TFT_GrayoutRect_(HEAD_MAINBUTTON, BACKGROUND_COLOR);
    GUI_DrawHeaderRButton(FORWARD_60x60, true);
  }
  if (!OutConfig[CurrentControl].ProgUse)
  {
    GUI_DrawHeaderMainButton(OK_60x60, true);
    TFT_GrayoutRect_(HEAD_RBUTTON, BACKGROUND_COLOR);
  }
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
    GetControlChannelInputParamString((Int8U)OutConfig[CurrentControl].DefParam, display);
    TFT_WriteStringInRectCenter(display, DEEPBLUE, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
    TFT_WriteStringInRectCenter(display, DEEPBLUE, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  }

  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].Hesteresis);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ControlType ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ProgUse ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);
}

void GUI_TouchRelayConfigurationHesterScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (!OutConfig[CurrentControl].ProgUse)
    if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
    {
      set_sound(S_SOUND_20);

      OS_Use(&SemaRAM);
      SAVE_CONFIG(OutConfig[CurrentControl]);
      OS_Unuse(&SemaRAM);
    
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationCommonScreen, GUI_UpdateRelayConfigurationCommonScreen, GUI_TouchRelayConfigurationCommonScreen);
    return;
  }

  if (OutConfig[CurrentControl].ProgUse)
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawRelayConfigurationProgrammScreen, GUI_UpdateRelayConfigurationProgrammScreen, GUI_TouchRelayConfigurationProgrammScreen);
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  float min, max;
  GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterParamScreen, GUI_UpdateRelayConfigurationHesterParamScreen, GUI_TouchRelayConfigurationHesterParamScreen);
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    GUI_KeyboardFloat(&OutConfig[CurrentControl].Hesteresis, "Настройки", "Гистерезис", false, 0, 0, decimal);
    GUI_DrawRelayConfigurationHesterScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ControlType = !OutConfig[CurrentControl].ControlType;
    GUI_ManualUpdateRelayConfigurationHesterScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ProgUse = !OutConfig[CurrentControl].ProgUse;
    GUI_ManualUpdateRelayConfigurationHesterScreen();
    return;
  }
}

void GUI_DrawRelayConfigurationHesterParamScreen()
{
  char display[32];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(BACK_60x60, true, BACKWARD_60x60, false, FORWARD_60x60, false, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Тип значения", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    TFT_WriteStringInRectLeft("Параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_WriteStringInRectLeft("Значение", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }

  GUI_UpdateRelayConfigurationHesterParamScreen();
  GUI_ManualUpdateRelayConfigurationHesterParamScreen();
}

void GUI_UpdateRelayConfigurationHesterParamScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateRelayConfigurationHesterParamScreen()
{
  char display[32];
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", DEFPARAM_TYPES[OutConfig[CurrentControl].DefParamIsIndex]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].DefParamIsIndex)
  {
    TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
    GetControlChannelInputParamString((Int8U)OutConfig[CurrentControl].DefParam, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }
  else
  {
    TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
    sprintf(display, "%.*f", decimal, OutConfig[CurrentControl].DefParam);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  }
}

void GUI_TouchRelayConfigurationHesterParamScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
    return;
  }
  
  float min, max;
  GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].DefParamIsIndex = !OutConfig[CurrentControl].DefParamIsIndex;
    GUI_ManualUpdateRelayConfigurationHesterParamScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    if (OutConfig[CurrentControl].DefParamIsIndex)
    {
      set_sound(S_SOUND_20);
      Int8U unit_type = GetControlChannelUnitType(OutConfig[CurrentControl].Input);
      Int8U index = (Int8U)OutConfig[CurrentControl].DefParam;
      IncrementControlChannelHesterParam(&index, unit_type);
      OutConfig[CurrentControl].DefParam = index;
      GUI_ManualUpdateRelayConfigurationHesterParamScreen();
      return;
    }
    else
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardFloat(&OutConfig[CurrentControl].DefParam, "Настройки", "Значение", false, min, max, decimal);
      GUI_DrawRelayConfigurationHesterParamScreen();
      return;
    }
  }
}

void GUI_DrawRelayConfigurationProgrammScreen()
{
  char display[32];
  sprintf(display, "Канал %d (реле)", CurrentControl+1);
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Начальный шаг", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  sprintf(display, "%d", OutConfig[CurrentControl].StartStep+1);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Конечный шаг", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  sprintf(display, "%d", OutConfig[CurrentControl].StopStep+1);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("После окончания программы", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectCenter("Настроить шаги программы", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma34);
  
  GUI_UpdateRelayConfigurationProgrammScreen();
  GUI_ManualUpdateRelayConfigurationProgrammScreen();
}

void GUI_UpdateRelayConfigurationProgrammScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateRelayConfigurationProgrammScreen()
{
  char line1[32];
  char line2[32];
  TFT_FillRect_(RIGHTHALF_LOWER, BACKGROUND_COLOR);
  sprintf(line1, "%s", END_PROGRAMM_ACTIONS[OutConfig[CurrentControl].EndProgCond][0]);
  sprintf(line2, "%s", END_PROGRAMM_ACTIONS[OutConfig[CurrentControl].EndProgCond][1]);
  TFT_WriteStringInRectCenterInTwoLines(line1, line2, DARKGREEN, BACKGROUND_COLOR, RIGHTHALF_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchRelayConfigurationProgrammScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationHesterScreen, GUI_UpdateRelayConfigurationHesterScreen, GUI_TouchRelayConfigurationHesterScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  int step;
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    step = OutConfig[CurrentControl].StartStep + 1;
    if (GUI_KeyboardInt(&step, "Настройки", "Начальный шаг", true, 1, 512)) OutConfig[CurrentControl].StartStep = step - 1;
    GUI_DrawRelayConfigurationProgrammScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    step = OutConfig[CurrentControl].StopStep + 1;
    if (GUI_KeyboardInt(&step, "Настройки", "Конечный шаг", true, 1, 512)) OutConfig[CurrentControl].StopStep = step - 1;
    GUI_DrawRelayConfigurationProgrammScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].EndProgCond++;
    GUI_ManualUpdateRelayConfigurationProgrammScreen();
    return;
  }
  
  if (OutConfig[CurrentControl].ProgUse)
  {
    if (TFT_CoordsInRect(X, Y, LOWERMOST))
    {
      set_sound(S_SOUND_20);
      CurrentProgrammStep = OutConfig[CurrentControl].StartStep;
      GUI_SetGUI(GUI_DrawProgrammStepScreen, GUI_UpdateProgrammStepScreen, GUI_TouchProgrammStepScreen);
      return;
    }
  }
}

void GUI_DrawProgrammStepScreen()
{
  char display[32];
  sprintf(display, "Программа (шаг %d)", CurrentProgrammStep+1);
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, CurrentProgrammStep > 0, FORWARD_60x60, CurrentProgrammStep < 511, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Значение параметра", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Время выхода, с", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Время удержания, с", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  GUI_UpdateProgrammStepScreen();
  GUI_ManualUpdateProgrammStepScreen();
}

void GUI_UpdateProgrammStepScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateProgrammStepScreen()
{
  char display[32];
  sprintf(display, "Программа (шаг %d)", CurrentProgrammStep+1);
  GUI_UpdateHeaderText("Настройки", display);
  GUI_DrawHeaderLRButtons(BACKWARD_60x60, CurrentProgrammStep > 0, FORWARD_60x60, CurrentProgrammStep < 511);
  
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%.*f", decimal, Program[CurrentProgrammStep].Param);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  sprintf(display, "%d", Program[CurrentProgrammStep].SetlTime);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  sprintf(display, "%d", Program[CurrentProgrammStep].HoldTime);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
}

void GUI_TouchProgrammStepScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawRelayConfigurationProgrammScreen, GUI_UpdateRelayConfigurationProgrammScreen, GUI_TouchRelayConfigurationProgrammScreen);
    return;
  }
  
  if (CurrentProgrammStep > 0)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentProgrammStep--;
      GUI_ManualUpdateProgrammStepScreen();
      return;
    }
  }
  
  if (CurrentProgrammStep < 511)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      CurrentProgrammStep++;
      GUI_ManualUpdateProgrammStepScreen();
      return;
    }
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    seachSectorsToWrite   ( CONFIG_ROM_ADR(Program), 512*sizeof(Program_t));
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    float min, max;
    Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
    GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
    GUI_KeyboardFloat(&Program[CurrentProgrammStep].Param, "Настройки", "Значение параметра", false, min, max, decimal);
    GUI_DrawProgrammStepScreen();
    return;
  }
  
  int time;
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    time = Program[CurrentProgrammStep].SetlTime;
    if (GUI_KeyboardInt(&time, "Настройки", "Время выхода, с", true, 0, 65535)) Program[CurrentProgrammStep].SetlTime = time;
    GUI_DrawProgrammStepScreen();
    return;
  }

  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    time = Program[CurrentProgrammStep].HoldTime;
    if (GUI_KeyboardInt(&time, "Настройки", "Время удержания, с", true, 0, 65535)) Program[CurrentProgrammStep].HoldTime = time;
    GUI_DrawProgrammStepScreen();
    return;
  }
}

void GUI_DrawCurrentConfigurationCommonScreen()
{
  char display[20];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  bool ok_active = OutConfig[CurrentControl].CntrAttr == OFF_CONTROL;
  bool forward_active = OutConfig[CurrentControl].CntrAttr != OFF_CONTROL;
  GUI_DrawHeader(OK_60x60, ok_active, BACKWARD_60x60, false, FORWARD_60x60, forward_active, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Выходной диапазон", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Тип управления", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

  GUI_UpdateCurrentConfigurationCommonScreen();
  GUI_ManualUpdateCurrentConfigurationCommonScreen();
}

void GUI_UpdateCurrentConfigurationCommonScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateCurrentConfigurationCommonScreen()
{
  char display[20];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", CURRENT_TYPES[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  sprintf(display, "%s", CURRENT_CONTROL_TYPES[OutConfig[CurrentControl].CntrAttr]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    GUI_DrawHeaderMainButton(OK_60x60, true);
    TFT_GrayoutRect_(HEAD_RBUTTON, BACKGROUND_COLOR);
    TFT_FillRect_(LOWER, BACKGROUND_COLOR);
  }
    
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    TFT_GrayoutRect_(HEAD_MAINBUTTON, BACKGROUND_COLOR);
    GUI_DrawHeaderRButton(FORWARD_60x60, true);
    TFT_WriteStringInRectLeft("Управляемый параметр", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
    TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
    GetControlChannelInputParamString(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  }
}

void GUI_TouchCurrentConfigurationCommonScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (OutConfig[CurrentControl].CntrAttr == OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
    {
      set_sound(S_SOUND_20);

      OS_Use(&SemaRAM);
      SAVE_CONFIG(OutConfig[CurrentControl]);
      OS_Unuse(&SemaRAM);
    
      GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
      return;
    }
  }
  
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
    if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
    {
      set_sound(S_SOUND_20);
      if (OutConfig[CurrentControl].CntrAttr == LOGIC_CONTROL) GUI_SetGUI(GUI_DrawCurrentConfigurationLogicScreen, GUI_UpdateCurrentConfigurationLogicScreen, GUI_TouchCurrentConfigurationLogicScreen);
      if (OutConfig[CurrentControl].CntrAttr == LINE_CONTROL)  GUI_SetGUI(GUI_DrawCurrentConfigurationLineoutScreen, GUI_UpdateCurrentConfigurationLineoutScreen, GUI_TouchCurrentConfigurationLineoutScreen);
      return;
    }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ChanelType++;
    if (OutConfig[CurrentControl].ChanelType > ANALOG_TYPE_420) OutConfig[CurrentControl].ChanelType = ANALOG_TYPE_05;
    GUI_ManualUpdateCurrentConfigurationCommonScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].CntrAttr++;
    if (OutConfig[CurrentControl].CntrAttr > LINE_CONTROL) OutConfig[CurrentControl].CntrAttr = OFF_CONTROL;
    GUI_ManualUpdateCurrentConfigurationCommonScreen();
    return;
  }
  
  if (OutConfig[CurrentControl].CntrAttr != OFF_CONTROL)
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
    {
      set_sound(S_SOUND_20);
      IncrementControlChannelInputParam(&OutConfig[CurrentControl].Input);
      GUI_ManualUpdateCurrentConfigurationCommonScreen();
      return;
    }
  }
}

void GUI_DrawCurrentConfigurationLogicScreen()
{
  char display[32];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  TFT_WriteStringInRectLeft("Порог 1", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Порог 2", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
  TFT_WriteStringInRectLeft("Срабатывание на ошибку", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Инвертировать выход", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWERMOST, 5, 0, &Tahoma34);
  
  GUI_UpdateCurrentConfigurationLogicScreen();
  GUI_ManualUpdateCurrentConfigurationLogicScreen();
}

void GUI_UpdateCurrentConfigurationLogicScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateCurrentConfigurationLogicScreen()
{
  char display[32];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
  {
    GetControlChannelInputThreshold1String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
  {
    GetControlChannelInputThreshold2String(OutConfig[CurrentControl].Input, display);
    TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
    
  TFT_FillRect_(RIGHT_THIRD_LOWER, BACKGROUND_COLOR);
  if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
  {
    TFT_WriteStringInRectCenter("Да", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  }
  else
  {
    TFT_WriteStringInRectCenter("Нет", DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  }
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_FillRect_(RIGHT_THIRD_LOWERMOST, BACKGROUND_COLOR);
  sprintf(display, "%s", OutConfig[CurrentControl].ControlType ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);
}

void GUI_TouchCurrentConfigurationLogicScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawCurrentConfigurationCommonScreen, GUI_UpdateCurrentConfigurationCommonScreen, GUI_TouchCurrentConfigurationCommonScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR1)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR1;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR1;
    GUI_ManualUpdateCurrentConfigurationLogicScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_TR2)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_TR2;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_TR2;
    GUI_ManualUpdateCurrentConfigurationLogicScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    if (OutConfig[CurrentControl].LogicUse & LOGIC_ERR)
      OutConfig[CurrentControl].LogicUse &= ~LOGIC_ERR;
    else
      OutConfig[CurrentControl].LogicUse |= LOGIC_ERR;
    GUI_ManualUpdateCurrentConfigurationLogicScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
  {
    set_sound(S_SOUND_20);
    OutConfig[CurrentControl].ControlType = !OutConfig[CurrentControl].ControlType;
    GUI_ManualUpdateCurrentConfigurationLogicScreen();
    return;
  }
}

void GUI_DrawCurrentConfigurationLineoutScreen()
{
  char display[32];
  sprintf(display, "Канал %d (ток)", CurrentControl+1);
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Настройки", display);
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
  sprintf(display, "Значение для %s", LOWER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectLeft(display, BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][0]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
    
  sprintf(display, "Значение для %s", UPPER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
  TFT_WriteStringInRectLeft(display, BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  sprintf(display, "%.*f", decimal, AnalogConfig[CurrentControl][1]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  GUI_UpdateCurrentConfigurationLineoutScreen();
  GUI_ManualUpdateCurrentConfigurationLineoutScreen();
}

void GUI_UpdateCurrentConfigurationLineoutScreen()
{
  GUI_UpdateHeader();
}

void GUI_ManualUpdateCurrentConfigurationLineoutScreen()
{
  // NO OP REQUIRED
}

void GUI_TouchCurrentConfigurationLineoutScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);

    OS_Use(&SemaRAM);
    SAVE_CONFIG(OutConfig[CurrentControl]);
    SAVE_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawCurrentConfigurationCommonScreen, GUI_UpdateCurrentConfigurationCommonScreen, GUI_TouchCurrentConfigurationCommonScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlsScreen, GUI_UpdateControlsScreen, GUI_TouchControlsScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(OutConfig[CurrentControl]);
    LOAD_CONFIG(AnalogConfig[CurrentControl]);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawControlScreen, GUI_UpdateControlScreen, GUI_TouchControlScreen);
    return;
  }

  char display[32];
  float min, max;
  GetControlChannelInputParamMinMax(OutConfig[CurrentControl].Input, &min, &max);
  Int8U decimal = GetControlChannelDecimal(OutConfig[CurrentControl].Input);
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    sprintf(display, "Значение для %s", LOWER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
    GUI_KeyboardFloat(&AnalogConfig[CurrentControl][0], "Настройки", display, false, min, max, decimal);
    GUI_DrawCurrentConfigurationLineoutScreen();
    return;
  }
    
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    sprintf(display, "Значение для %s", UPPER_CURRENTS[OutConfig[CurrentControl].ChanelType]);
    GUI_KeyboardFloat(&AnalogConfig[CurrentControl][1], "Настройки", display, false, min, max, decimal);
    GUI_DrawCurrentConfigurationLineoutScreen();
    return;
  }
}

void GUI_DrawSettingsRootScreen()
{
  GUI_DrawHeaderWide(BACK_60x60, true, "Настройки", "Меню настроек");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Информация о приборе", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Настройки связи", DARKGREEN, BACKGROUND_COLOR, MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Настройки статистики", DARKGREEN, BACKGROUND_COLOR, LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Другие настройки", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma34);
  
  GUI_UpdateSettingsRootScreen();
}

void GUI_UpdateSettingsRootScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_TouchSettingsRootScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button != NOT_PRESSED)
  {
    set_sound(S_SOUND_20);
    if (button == SWITCH_BUTTON) CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsInfoScreen, GUI_UpdateSettingsInfoScreen, GUI_TouchSettingsInfoScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MIDDLE))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsStatisticScreen, GUI_UpdateSettingsStatisticScreen, GUI_TouchSettingsStatisticScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWERMOST))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
}

void GUI_DrawSettingsInfoScreen()
{
  GUI_DrawHeaderWide(BACK_60x60, true, "Настройки", "Информация о приборе");

  TFT_FillRect_(BODY, BACKGROUND_COLOR);
  
  char display[36];
  sprintf(display, "%s", DeviceName);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Номер прибора", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  SerialNumber[8] = 0;
  sprintf(display, "%s", SerialNumber);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Версия ПО", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  
  if (strstr ((char const *)DeviceName, "ИВТМ")==(char const *)DeviceName)
    sprintf(display, "1.00");
  else if (strstr ((char const *)DeviceName, "ИВГ")==(char const *)DeviceName)
    sprintf(display, "1.00");
  else if (strstr ((char const *)DeviceName, "ПКГ")==(char const *)DeviceName) 
    sprintf(display, "1.15");
  else if (strstr ((char const *)DeviceName, "ПКУ")==(char const *)DeviceName) 
    sprintf(display, "1.15");
  else if (strstr ((char const *)DeviceName, "ТТМ")==(char const *)DeviceName) 
    sprintf(display, "1.15");
  else if (strstr ((char const *)DeviceName, "МАГ")==(char const *)DeviceName) 
    sprintf(display, "1.00");
  else
    sprintf(display, "1.00");

  //sprintf(display, "1.00");
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Время наработки, ч", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWERMOST, 5, 0, &Tahoma34);
  sprintf(display, "%d", TimeUpCounter / 3600);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_LOWERMOST, 0, 0, &Tahoma34);

  GUI_UpdateSettingsInfoScreen();
}

void GUI_UpdateSettingsInfoScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_TouchSettingsInfoScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
}

void GUI_DrawSettingsConnectionScreen()
{
  char display[36];
  GUI_DrawHeaderWide(BACK_60x60, true, "Настройки", "Настройки связи");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("RS-232 и RS-485", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  sprintf(display, "%s/%d", RS_SPEEDS[ConfigWord & UART_MASK], NetAddress);
  TFT_WriteStringInRectLeft("RS Скорость/Адрес", BLACK, BACKGROUND_COLOR, LEFTHALF_LOWER_BOTTOM, 5, 0, &Tahoma34);
  TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHTHALF_LOWER_BOTTOM, 0, 0, &Tahoma34);
  
  if (ConfigWord & TCP_PRESENT)
  {
    TFT_WriteStringInRectCenter("TCP/IP и UDP/IP", DARKGREEN, BACKGROUND_COLOR, MIDDLE, 0, 0, &Tahoma34);
    TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

    TFT_WriteStringInRectLeft("Сетевое имя", BLACK, BACKGROUND_COLOR, LEFTHALF_LOWERMOST_TOP, 5, 0, &Tahoma34);
    TFT_WriteStringInRectCenter(HostName, BROWN, BACKGROUND_COLOR, RIGHTHALF_LOWERMOST_TOP, 0, 0, &Tahoma34);
    
    Int8U   MAC[6];
    Int32U  ip_;
    
    if (TCPIPConfig.UseDHCP)  ip_    = IP_GetIPAddr(0);
    else                      ip_    = TCPIPConfig.IP;
        
    ParseIPAddress(ip_, display);        
    IP_GetHWAddr(0, MAC, 6);
    
    sprintf(display, "%s / %.2x:%.2x:%.2x:%.2x:%.2x:%.2x", display, MAC[0], MAC[1], MAC[2], MAC[3], MAC[4], MAC[5]);
    TFT_WriteStringInRectLeft("IP/MAC-адреса", BLACK, BACKGROUND_COLOR, LEFTHALF_LOWERMOST_BOTTOM, 5, 0, &Tahoma34);
    TFT_WriteStringInRectRight(display, BROWN, BACKGROUND_COLOR, RIGHTHALF_LOWERMOST_BOTTOM, 5, 0, &Tahoma34);
  }

  GUI_UpdateSettingsConnectionScreen();
}

void GUI_UpdateSettingsConnectionScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_TouchSettingsConnectionScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsRSScreen, GUI_UpdateSettingsRSScreen, GUI_TouchSettingsRSScreen);
    return;
  }
  
  if (ConfigWord & TCP_PRESENT)
    if (TFT_CoordsInRect(X, Y, MIDDLE))
    {
      set_sound(S_SOUND_20);
      GUI_SetGUI(GUI_DrawSettingsTCPScreen, GUI_UpdateSettingsTCPScreen, GUI_TouchSettingsTCPScreen);
      return;
    }
}

void GUI_DrawSettingsRSScreen()
{
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", "RS-232 и RS-485");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[32];
  TFT_WriteStringInRectLeft("Скорость связи", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);

  TFT_WriteStringInRectLeft("Сетевой адрес", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  sprintf(display, "%d", NetAddress);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);

  GUI_UpdateSettingsRSScreen();
  GUI_ManualUpdateSettingsRSScreen();
}

void GUI_UpdateSettingsRSScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateSettingsRSScreen()
{
  char display[32];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", RS_SPEEDS[ConfigWord & UART_MASK]);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsRSScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    SAVE_CONFIG(ConfigWord);
    SAVE_CONFIG(InvConfigWord);
    SAVE_CONFIG(NetAddress);
    OS_Unuse(&SemaRAM);
    
    USART2->BRR =  select_speed(ConfigWord & UART_MASK, APB1); // обновить скорость RS
    
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    LOAD_CONFIG(NetAddress);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    LOAD_CONFIG(NetAddress);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    Int8U speed = ConfigWord & UART_MASK;
    speed++;
    if (speed > 7) speed = 0;
    ConfigWord = ConfigWord & ~(Int32U)UART_MASK;
    ConfigWord |= speed;
    InvConfigWord = ~ConfigWord;
    GUI_ManualUpdateSettingsRSScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    int net_addr = NetAddress;
    if (GUI_KeyboardInt(&net_addr, "Настройки", "Сетевой адрес", true, 1, 255))
      NetAddress = net_addr;
    GUI_DrawSettingsRSScreen();
    return;
  }
}

void GUI_DrawSettingsTCPScreen()
{
  GUI_DrawHeaderWide(BACK_60x60, true, "Настройки", "TCP/IP и UDP/IP");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Использовать DHCP", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_WriteStringInRectLeft("IP-адрес", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_WriteStringInRectLeft("Маска подсети", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  TFT_WriteStringInRectLeft("Шлюз", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWERMOST, 5, 0, &Tahoma34);
  
  GUI_UpdateSettingsTCPScreen();
}

void GUI_UpdateSettingsTCPScreen()
{
  GUI_UpdateHeaderWide();
  
  char display[32];
  sprintf(display, "%s", TCPIPConfig.UseDHCP ? "Да" : "Нет");
  //TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  //TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHTHALF_UPPER, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, (RECT*)&RIGHTHALF_UPPER, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  Int16U color;
  color = TCPIPConfig.UseDHCP ? BROWN : DARKGREEN;

  char ip[32], mask[32], gate[32];
  if (TCPIPConfig.UseDHCP)
  {
    Int32U ip_, mask_, gate_;
    ip_   = IP_GetIPAddr(0);
    mask_ = IP_GetAddrMask(0);
    gate_ = IP_GetGWAddr(0);
    
    ParseIPAddress(ip_, ip);
    ParseIPAddress(mask_, mask);
    ParseIPAddress(gate_, gate);
  }
  else
  {
    ParseIPAddress(TCPIPConfig.IP, ip);
    ParseIPAddress(TCPIPConfig.Mask, mask);
    ParseIPAddress(TCPIPConfig.Gate, gate);
  }
  
  //TFT_FillRect_(RIGHTHALF_MIDDLE, BACKGROUND_COLOR);
  //TFT_WriteStringInRectCenter(ip, color, BACKGROUND_COLOR, RIGHTHALF_MIDDLE, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(ip, color, BACKGROUND_COLOR, (RECT*)&RIGHTHALF_MIDDLE, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  //TFT_FillRect_(RIGHTHALF_LOWER, BACKGROUND_COLOR);
  //TFT_WriteStringInRectCenter(mask, color, BACKGROUND_COLOR, RIGHTHALF_LOWER, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(mask, color, BACKGROUND_COLOR, (RECT*)&RIGHTHALF_LOWER, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  //TFT_FillRect_(RIGHTHALF_LOWERMOST, BACKGROUND_COLOR);
  //TFT_WriteStringInRectCenter(gate, color, BACKGROUND_COLOR, RIGHTHALF_LOWERMOST, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(gate, color, BACKGROUND_COLOR, (RECT*)&RIGHTHALF_LOWERMOST, &Tahoma34);
}

void GUI_TouchSettingsTCPScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsConnectionScreen, GUI_UpdateSettingsConnectionScreen, GUI_TouchSettingsConnectionScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    TCPIPConfig.UseDHCP = !TCPIPConfig.UseDHCP;
    OS_Use(&SemaRAM);
    SAVE_CONFIG(TCPIPConfig);
    OS_Unuse(&SemaRAM);
    Initialize_TCPIP_Config(0);
    
    GUI_UpdateSettingsTCPScreen();
    return;
  }
  
  if (!TCPIPConfig.UseDHCP)
  {
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardIP(&TCPIPConfig.IP, "Настройки", "IP-адрес");
      OS_Use(&SemaRAM);
      SAVE_CONFIG(TCPIPConfig);
      OS_Unuse(&SemaRAM);
      Initialize_TCPIP_Config(0);
    
      GUI_DrawSettingsTCPScreen();
      return;
    }
    
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardIP(&TCPIPConfig.Mask, "Настройки", "Маска подсети");
      OS_Use(&SemaRAM);
      SAVE_CONFIG(TCPIPConfig);
      OS_Unuse(&SemaRAM);
      Initialize_TCPIP_Config(0);
    
      GUI_DrawSettingsTCPScreen();
      return;
    }
    
    if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWERMOST))
    {
      set_sound(S_SOUND_20);
      GUI_KeyboardIP(&TCPIPConfig.Gate, "Настройки", "Шлюз");
      OS_Use(&SemaRAM);
      SAVE_CONFIG(TCPIPConfig);
      OS_Unuse(&SemaRAM);
      Initialize_TCPIP_Config(0);
      
      GUI_DrawSettingsTCPScreen();
      return;
    }
  }
}

void GUI_DrawSettingsStatisticScreen()
{
  GUI_DrawHeaderWide(BACK_60x60, true, "Настройки", "Статистика");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[32];
  TFT_WriteStringInRectLeft("Период записи, с", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  sprintf(display, "%d", StatisticPeriod);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("Записей", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  
  TFT_WriteStringInRectCenter("Сбросить статистику", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma34);
  
  GUI_UpdateSettingsStatisticScreen();
}

void GUI_UpdateSettingsStatisticScreen()
{
  GUI_UpdateHeaderWide();
  
  char display[32];
  //TFT_FillRect_(RIGHT_THIRD_MIDDLE_TOP, BACKGROUND_COLOR);
  sprintf(display, "%d", (WriteStatAddr-SD_STATISTIC_OFFSET)/0x600);
  //TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE_TOP, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, (RECT*)&RIGHT_THIRD_MIDDLE_TOP, &Tahoma34);
  
  //TFT_FillRect_(RIGHT_THIRD_MIDDLE_BOTTOM, BACKGROUND_COLOR);
  float fullness = ((float)WriteStatAddr-(float)SD_STATISTIC_OFFSET)/(1024.*1024.*1024.);
  sprintf(display, "%.0f %%", fullness);
  //TFT_WriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE_BOTTOM, 0, 0, &Tahoma34);
  TFT_SmartWriteStringInRectCenter(display, BROWN, BACKGROUND_COLOR, (RECT*)&RIGHT_THIRD_MIDDLE_BOTTOM, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsStatisticScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    if (GUI_KeyboardInt(&StatisticPeriod, "Настройки", "Период статистики", true, 30, 6000))
    {
      OS_Use(&SemaRAM);
      SAVE_CONFIG(StatisticPeriod);
      OS_Unuse(&SemaRAM);
    };
    GUI_DrawSettingsStatisticScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWERMOST))
  {
    set_sound(S_SOUND_20);
    if (GUI_MessageBox("Подтверждение", "Очистить память статистики?", "Это действие не может быть", "отменено.", 60, MESSAGEBOX_YESNO, BACKGROUND_COLOR))
    {
      ConfigWord &= ~STATISCTIC_OVERFLOW;
      InvConfigWord = ~ConfigWord;
      WriteStatAddr = SD_STATISTIC_OFFSET;
      OS_Use(&SemaRAM);
        SAVE_CONFIG(ConfigWord);
        SAVE_CONFIG(InvConfigWord);
      OS_Unuse(&SemaRAM);
    }
    GUI_DrawSettingsStatisticScreen();
    return;
  }
}

void GUI_DrawSettingsOtherScreen1()
{
  GUI_DrawHeader(BACK_60x60, true, BACKWARD_60x60, false, FORWARD_60x60, true, "Настройки", "Другие настройки");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Дата/время", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Звуки", DARKGREEN, BACKGROUND_COLOR, MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Калибровка экрана", DARKGREEN, BACKGROUND_COLOR, LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  TFT_WriteStringInRectCenter("Восстановить заводские установки", DARKGREEN, BACKGROUND_COLOR, LOWERMOST, 0, 0, &Tahoma34);
  
  GUI_UpdateSettingsOtherScreen1();
}

void GUI_UpdateSettingsOtherScreen1()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsOtherScreen1()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
  {
    set_sound(S_SOUND_20);
    TempTime = Time;
    GUI_SetGUI(GUI_DrawSettingsOtherScreen2, GUI_UpdateSettingsOtherScreen2, GUI_TouchSettingsOtherScreen2);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    TempTime = Time;
    GUI_SetGUI(GUI_DrawSettingsDateScreen, GUI_UpdateSettingsDateScreen, GUI_TouchSettingsDateScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, MIDDLE))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsSoundsScreen, GUI_UpdateSettingsSoundsScreen, GUI_TouchSettingsSoundsScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWER))
  {
    set_sound(S_SOUND_20);
    GUI_CalibTouch();
    GUI_DrawSettingsOtherScreen1();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, LOWERMOST))
  {
    set_sound(S_SOUND_20);
    if (GUI_MessageBox("Подтверждение", "Востановить заводские", "установки?", "", 60, MESSAGEBOX_YESNO, BACKGROUND_COLOR))
    {
      OS_Use( &SemaRAM);
      system_flags.readdefaultmem = 1;
      OS_Unuse( &SemaRAM);
    }
    GUI_DrawSettingsOtherScreen1();
    return;
  }
}

void GUI_DrawSettingsOtherScreen2()
{
  GUI_DrawHeader(BACK_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Настройки", "Другие настройки");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectCenter("Веб-интерфейс", DARKGREEN, BACKGROUND_COLOR, UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);
  
  GUI_UpdateSettingsOtherScreen2();
}

void GUI_UpdateSettingsOtherScreen2()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsOtherScreen2()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    if (GetDisplayChannelsCount() == 1)
      GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    else
      GUI_SetGUI(GUI_DrawSettingsRootScreen, GUI_UpdateSettingsRootScreen, GUI_TouchSettingsRootScreen);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    TempTime = Time;
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, UPPER))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsWebServerScreen, GUI_UpdateSettingsWebServerScreen, GUI_TouchSettingsWebServerScreen);
    return;
  }
}

void GUI_DrawSettingsDateScreen()
{
  GUI_DrawHeader(OK_60x60, false, BACKWARD_60x60, false, FORWARD_60x60, true, "Настройки", "Дата");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[16];
  int   m, d, h, mi, s, y;
  ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);

  TFT_WriteStringInRectLeft("Год", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  sprintf(display, "%d", y);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Месяц", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  sprintf(display, "%d", m);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  TFT_WriteStringInRectLeft("День", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  sprintf(display, "%d", d);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);
  
  GUI_UpdateSettingsDateScreen();
}

void GUI_UpdateSettingsDateScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsDateScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_RBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsTimeScreen, GUI_UpdateSettingsTimeScreen, GUI_TouchSettingsTimeScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  int    m, d, h, mi, s, y;
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt( &y, "Настройки", "Год", true, 2014, 2100))
      TempTime = EncodeDate(s, mi, h, d, m, y);
    GUI_DrawSettingsDateScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt( &m, "Настройки", "Месяц", true, 1, 12))
      TempTime = EncodeDate(s, mi, h, d, m, y);
    GUI_DrawSettingsDateScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt( &d, "Настройки", "День", true, 1, 31))
      TempTime = EncodeDate(s, mi, h, d, m, y);
    GUI_DrawSettingsDateScreen();
    return;
  }
}

void GUI_DrawSettingsTimeScreen()
{
  GUI_DrawHeader(OK_60x60, true, BACKWARD_60x60, true, FORWARD_60x60, false, "Настройки", "Время");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  char display[16];
  int   m, d, h, mi, s, y;
  ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);

  TFT_WriteStringInRectLeft("Часы", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  sprintf(display, "%d", h);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_WriteStringInRectLeft("Минуты", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  sprintf(display, "%d", mi);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
  
  GUI_UpdateSettingsTimeScreen();
}

void GUI_UpdateSettingsTimeScreen()
{
  GUI_UpdateHeader();
}

void GUI_TouchSettingsTimeScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
   
    OS_Use(&SemaRAM);      
      Time = TempTime;
      RTC_SetCounter (Time);
      errors_flags.timeinvalid = 0;
      set_bkp_reg( ERR_BASE, get_bkp_reg(ERR_BASE) & ~(1L<<1));;
    OS_Unuse(&SemaRAM);          
    
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, HEAD_LBUTTON))
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsDateScreen, GUI_UpdateSettingsDateScreen, GUI_TouchSettingsDateScreen);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  int   m, d, h, mi, s = 0, y;
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt( &h, "Настройки", "Часы", true, 0, 23))
      TempTime = EncodeDate( s, mi, h, d, m, y);
    GUI_DrawSettingsTimeScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    ParseDate( TempTime, &s, &mi, &h, &d, &m, &y);
    if (GUI_KeyboardInt( &mi, "Настройки", "Минуты", true, 0, 59))
      TempTime = EncodeDate( s, mi, h, d, m, y);
    GUI_DrawSettingsTimeScreen();
    return;
  }
}

void GUI_DrawSettingsSoundsScreen()
{
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", "Звуки");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Ошибки", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_WriteStringInRectLeft("Пороги", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  
  GUI_UpdateSettingsSoundsScreen();
  GUI_ManualUpdateSettingsSoundsScreen();
}

void GUI_UpdateSettingsSoundsScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateSettingsSoundsScreen()
{
  char display[32];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", ConfigWord & ERROR_BEEP ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  sprintf(display, "%s", ConfigWord & TRSH_BEEP ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsSoundsScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
   
    OS_Use(&SemaRAM);
    SAVE_CONFIG(ConfigWord);
    SAVE_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(ConfigWord);
    LOAD_CONFIG(InvConfigWord);
    OS_Unuse(&SemaRAM);
  
    GUI_SetGUI(GUI_DrawSettingsOtherScreen1, GUI_UpdateSettingsOtherScreen1, GUI_TouchSettingsOtherScreen1);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    if (ConfigWord & ERROR_BEEP)
      ConfigWord &= ~ERROR_BEEP;
    else
      ConfigWord |= ERROR_BEEP;
    InvConfigWord = ~ConfigWord;
    GUI_ManualUpdateSettingsSoundsScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    if (ConfigWord & TRSH_BEEP)
      ConfigWord &= ~TRSH_BEEP;
    else
      ConfigWord |= TRSH_BEEP;
    InvConfigWord = ~ConfigWord;
    GUI_ManualUpdateSettingsSoundsScreen();
    return;
  }
}

void GUI_DrawSettingsWebServerScreen()
{
  char display[32];
  GUI_DrawHeaderWide(OK_60x60, true, "Настройки", "Веб-интерфейс");
  
  TFT_FillRect_(BODY, BACKGROUND_COLOR);

  TFT_WriteStringInRectLeft("Активен", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_UPPER, 5, 0, &Tahoma34);
  TFT_WriteStringInRectLeftInTwoLines("Запретить сброс", "статистики", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_MIDDLE, 5, 0, &Tahoma34);
  TFT_WriteStringInRectLeft("Автообновление, сек", BLACK, BACKGROUND_COLOR, LEFT_TWOTHIRDS_LOWER, 5, 0, &Tahoma34);
  sprintf(display, "%d", WebServerConfig.AutoRefreshPeriod);
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_LOWER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(LOWER, BLACK, 1, 40, 0);  
  
  GUI_UpdateSettingsWebServerScreen();
  GUI_ManualUpdateSettingsWebServerScreen();
}

void GUI_UpdateSettingsWebServerScreen()
{
  GUI_UpdateHeaderWide();
}

void GUI_ManualUpdateSettingsWebServerScreen()
{
  char display[32];
  TFT_FillRect_(RIGHT_THIRD_UPPER, BACKGROUND_COLOR);
  sprintf(display, "%s", WebServerConfig.Disabled ? "Нет" : "Да");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_UPPER, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(UPPER, BLACK, 1, 40, 0);

  TFT_FillRect_(RIGHT_THIRD_MIDDLE, BACKGROUND_COLOR);
  sprintf(display, "%s", WebServerConfig.HideStatisticReset ? "Да" : "Нет");
  TFT_WriteStringInRectCenter(display, DARKGREEN, BACKGROUND_COLOR, RIGHT_THIRD_MIDDLE, 0, 0, &Tahoma34);
  TFT_UnderlineRect_Offset(MIDDLE, BLACK, 1, 40, 0);
}

void GUI_TouchSettingsWebServerScreen()
{
  Int16U X, Y;
  Int8U button = TFT_Pressed();
  if (!TFT_Touched(&X, &Y) && (button == NOT_PRESSED)) return;
  
  if (TFT_CoordsInRect(X, Y, HEAD_MAINBUTTON))
  {
    set_sound(S_SOUND_20);
   
    OS_Use(&SemaRAM);
    SAVE_CONFIG(WebServerConfig);
    OS_Unuse(&SemaRAM);
    
    GUI_SetGUI(GUI_DrawSettingsOtherScreen2, GUI_UpdateSettingsOtherScreen2, GUI_TouchSettingsOtherScreen2);
    return;
  }
  
  if (button == SWITCH_BUTTON)
  {
    set_sound(S_SOUND_20);
    OS_Use(&SemaRAM);
    LOAD_CONFIG(WebServerConfig);
    OS_Unuse(&SemaRAM);
    
    CurrentDisplay = 255;
    GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
    return;
  }
  
  if (button == BACK_BUTTON)
  {
    set_sound(S_SOUND_20);
    
    OS_Use(&SemaRAM);
    LOAD_CONFIG(WebServerConfig);
    OS_Unuse(&SemaRAM);
  
    GUI_SetGUI(GUI_DrawSettingsOtherScreen2, GUI_UpdateSettingsOtherScreen2, GUI_TouchSettingsOtherScreen2);
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_UPPER))
  {
    set_sound(S_SOUND_20);
    WebServerConfig.Disabled = !WebServerConfig.Disabled;
    GUI_ManualUpdateSettingsWebServerScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_MIDDLE))
  {
    set_sound(S_SOUND_20);
    WebServerConfig.HideStatisticReset = !WebServerConfig.HideStatisticReset;
    GUI_ManualUpdateSettingsWebServerScreen();
    return;
  }
  
  if (TFT_CoordsInRect(X, Y, RIGHTHALF_LOWER))
  {
    set_sound(S_SOUND_20);
    int temp = WebServerConfig.AutoRefreshPeriod;
    if (GUI_KeyboardInt(&temp, "Веб-интерфейс", "Автообновление, сек", true, 0, 65535))
    if((temp < 30) && temp) temp = 30;
    WebServerConfig.AutoRefreshPeriod = temp;
    GUI_DrawSettingsWebServerScreen();
    return;
  }
}

U8 TFT_init(void)
{   
  /* сброс */    
  RES_TFT_LOW;
  OS_Delay (5);
    
  RES_TFT_HIGH;
  OS_Delay (50); 
  
  CS_TFT_LOW;
      
  // Set PLL frequency = 120 MHz
  write_tft_command(0xe2);                    //  Set PLL: VCO (> 250MHz) = OSC x (N + 1) = 10 x (35 + 1)
  OS_Delay (1);
  write_tft_data(MULTIPLIER_N);               //  Multiplier N, VCO = 360MHz
  OS_Delay (1);
  write_tft_data(DIVIDER_M);                  //  Divider M, PLL = 120MHz (Standard) = 360 / (2 + 1)
  OS_Delay (1);
  write_tft_data(0x54);                       //  dummy write, no meaning. PLL = VCO / (M + 1)
  OS_Delay (1);
  
  write_tft_command(0xe0);                    //  Command: Set SSD1961 PLL
  OS_Delay (1);
  write_tft_data(0x01);                       //  Turn on PLL   
  OS_Delay (100);                             //  Delay for PLL stable  
  
  // check PLL lock
  write_tft_command( 0xe4);
  OS_Delay (1);
  U16  pll_status = read_tft_data();
  OS_Delay (1);
  if( pll_status != 0x04 ) return 1;
  
  write_tft_command(0xe0);                    //  Command: Set SSD1961 PLL
  OS_Delay (1);
  write_tft_data(0x03);                       //  Switch the clock source to PLL
  OS_Delay (1);

  write_tft_command(0x01);                    //  Command: Soft reset SSD1963
  OS_Delay (50);                              //  Delay for RESET

  // SET PIXEL CLOCK   
  write_tft_command(0xe6);                      // Set LSHIFT frequency pclk = pll freq * (setting + 1) / 0x100000 
  write_tft_data((LCDC_FPR&0x000F0000)>>16);  	//  Remark: 0x100000 must be divided by (setting+1), otherwise, pclk may oscilate
  write_tft_data((LCDC_FPR&0x0000FF00)>>8);   	//  
  write_tft_data((LCDC_FPR&0x000000FF));      	//  refresh rate = pclk / (H_Sync_total * V_Sync_total) 

  //SET LCD MODE 
  write_tft_command(0xb0);                      // display period Set LCD mode / pad strength
  write_tft_data(0x18);                       	// [B5:0] - 18Bit [B2:1] LSHIFT data latch falling edge [B1:0] LLINE active low [B0:0] - LFRAME active low
  write_tft_data(0x00);
  write_tft_data(((RESOLUTION_X-1)&0xFF00)>>8);   // 800 (Horizontal)
  write_tft_data((RESOLUTION_X-1)&0x00FF);
  write_tft_data(((RESOLUTION_Y-1)&0xFF00)>>8);   //  480 (Vertical)
  write_tft_data((RESOLUTION_Y-1)&0x00FF);
  
  //Set Horizontal Period
  write_tft_command(0xb4);                        // hsync
  write_tft_data(((H_Sync_total-1)&0xFF00)>>8);   // HT
  write_tft_data((H_Sync_total-1)&0x00FF);
  write_tft_data((H_Sync_to_DE&0x0700)>>8);
  write_tft_data((H_Sync_to_DE)&0x00FF);          // HPS
  write_tft_data(H_Sync_Pluse_Wide - 1);          // HPW
  write_tft_data(0x00);                           // LPS
  write_tft_data(0x00);                           // LPSPP
  
  //Set Vertical Period 
  write_tft_command(0xb6);                        // vsync
  write_tft_data(((V_Sync_total-1)&0xFF00)>>8);   // VT
  write_tft_data((V_Sync_total-1)&0x00FF);
  write_tft_data((V_Sync_to_DE&0x0700)>>8);
  write_tft_data((V_Sync_to_DE)&0x00FF);          // VPS
  write_tft_data(V_Sync_Pluse_Wide - 1);          // VPW
  write_tft_data(0x00);                           // FPS
  write_tft_data(0x00);                           // FPS
  
  // start displaying video mem
  write_tft_command( 0x29); 
  OS_Delay (50); 
  
  //Set X Address
  write_tft_command( 0x2a); 
  write_tft_data( 0x00); 
  write_tft_data( 0x00); 
  write_tft_data( ((RESOLUTION_X-1) & 0xFF00)>>8); 
  write_tft_data( ((RESOLUTION_X-1) & 0x00FF)); 

  //Set Y Address
  write_tft_command( 0x2b); 
  write_tft_data( 0x00); 
  write_tft_data( 0x00); 
  write_tft_data( ((RESOLUTION_Y-1) & 0xFF00)>>8); 
  write_tft_data( ((RESOLUTION_Y-1) & 0x00FF)); 
  
  //Set address mode  - перевернутый экран
  write_tft_command( 0x36);
  write_tft_data   ( BIT1 + BIT0);
        
  write_tft_command( 0xd4);
  //TH1 0X1680 Conservative mode 
  //TH1 = display width * display height * 3 * 0.1 /16 
  write_tft_data( 0x00); 
  write_tft_data( 0x16); 
  write_tft_data( 0x80); 
  //TH2 0X3840 Normal mode 
  ////TH2 = display width * display height * 3 * 0.25 /16 
  write_tft_data( 0x00); 
  write_tft_data( 0x38); 
  write_tft_data( 0x40); 
  //TH3 0X8700 Aggressive mode 
  write_tft_data( 0x00); 
  write_tft_data( 0x87); 
  write_tft_data( 0x00);
    
  write_tft_command( 0xd0);
  write_tft_data   ( (0<<6) | (1<<5) | (1<<2) | (1<<0));
    
  // Set pixel format 16-bit (565 format)
  write_tft_command( 0xf0);
  write_tft_data   ( 0x03);
    
  // clear video memory
  write_tft_command( 0x2c); 
  for(U32 i = 0; i < (RESOLUTION_X * RESOLUTION_Y); i++) write_tft_data( 0x0);  
          
  // pwm config - bright on
  if(Brightness > 100) Brightness = 100;
  U16 pwm =  (U16)(128. * Brightness / 100. + 0x10);
    
  OS_Delay (100);
  write_tft_command( 0xbe);
  write_tft_data( 0x08);  // 2 kHz pwm
  write_tft_data( pwm );  // duty cycle pwm
  write_tft_data( 0x01);  //  pwm on by Host
  write_tft_data( 0xff);
  write_tft_data( 0x00);
  write_tft_data( 0x00);
  
  return 0;
}

void TFT_Task(void) 
{
  Int8U update_counter = 0;

  GUI_LogoScreen();
  GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
  
  for(;;update_counter++)
  {
    // calib
    if (system_flags.ScreenCalib)
    {
      GUI_CalibTouch();
      
      OS_Use( &SemaRAM);
        system_flags.ScreenCalib = 0;
          OS_Unuse( &SemaRAM);
    }
    
    // screenshoot    
    if(system_flags.ScreenShoot)
    {
      ScreenShoot(SD_SCREENSHOT_OFFSET);
      
      OS_Use( &SemaRAM);
        system_flags.ScreenShoot = 0;
          OS_Unuse( &SemaRAM);
    }
    
    if (system_flags.redraw_gui && draw)
    {
      draw();     
      OS_Use( &SemaRAM);
      system_flags.redraw_gui = 0;
      OS_Unuse( &SemaRAM);
    }

    if ((update_counter % 20 == 0) && update) 
    {
      write_tft_command( 0xe4);      
      U16 tft_status = read_tft_data();
      if(tft_status != 0x04)         
      {
        TFT_init();
        draw();
      }
      else
        update();
    }
    
    if (touch)
    {
      touch();
        OS_ClearMB(&TouchPad_MB);
          OS_ClearMB(&Key_MB);
    }
    
    if( OS_WaitSingleEventTimed(1, 50) )
    {
      if( (draw != GUI_DrawMeasuresScreen) && 
            (draw != GUI_DrawControlsScreen) && 
              (draw != GUI_DrawControlScreen) )
      {
        GUI_SetGUI(GUI_DrawMeasuresScreen, GUI_UpdateMeasuresScreen, GUI_TouchMeasuresScreen);
      }
    }
  }
}
